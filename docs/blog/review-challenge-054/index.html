<!DOCTYPE html>
<html class="no-js" lang="en-us">
<head>
    <!-- Basic Page Needs -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:title"       content="Ryan Thompson › Perl Weekly Review #054"/>
    <meta property="og:type"        content="website"/>
    <meta property="og:url"         content="https://theweeklychallenge.org/blog/review-challenge-054/"/>
    <meta property="og:image"       content="https://theweeklychallenge.org/images/about/about.jpg"/>
    <meta property="og:description" content="Ryan Thompson › Perl Weekly Review #054"/>
    <meta name="twitter:card"       content="summary" />
    <meta name="twitter:image"      content="https://theweeklychallenge.org/images/about/about.jpg"/>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <meta name="description" content="Ryan Thompson › Perl Weekly Review #054">
    <meta name="author" content="The Weekly Challenge Team">
    <meta name="generator" content="Hugo 0.67.0-DEV" />

    <link rel="me" href="https://fosstodon.org/@manwar">
    <link rel="canonical" href="https://theweeklychallenge.org/blog/review-challenge-054/" />

    <!-- Mobile Specific Metas -->
    <meta name="format-detection" content="telephone=no">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Ryan Thompson › Perl Weekly Review #054</title>
    <link rel="icon" href="https://theweeklychallenge.org/images/favicon.ico">

    
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css"/>

    <!-- Twitter Bootstrs CSS -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/bootstrap/bootstrap.min.css">
    <!-- Ionicons Fonts Css -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/ionicons/ionicons.min.css">
    <!-- animate css -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/animate-css/animate.css">
    <!-- Hero area slider css-->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/slider/slider.css">
    <!-- slick slider -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/slick/slick.css">
    <!-- Fancybox -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/facncybox/jquery.fancybox.css">
    <!-- hover -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/hover/hover-min.css">
    <!-- Google fonts -->
    <link href='https://fonts.googleapis.com/css?family=Source Code Pro' rel='stylesheet'>
    <!-- template main css file -->
    
    <link rel="stylesheet" href="https://theweeklychallenge.org/css/style.min.css" integrity="" media="screen">
    <link rel="stylesheet" href="https://theweeklychallenge.org/css/main.css">

    <style>
        #goTopButton {
            display: none;          
            position: fixed;        
            bottom: 20px;           
            right: 30px;            
            z-index: 99;            
            border: none;           
            outline: none;          
            background-color: red;  
            color: white;           
            cursor: pointer;        
            padding: 15px;          
            border-radius: 10px;    
            font-size: 18px;        
        }

        #goTopButton:hover {
              background-color: #555;
        }

        
        .toggle-links {
            margin: 15px 0;
            padding-left: 15px;
        }
        .toggle-links a {
            display: inline-flex;
            align-items: center;
            padding: 8px 16px;
            border-radius: 20px;
            background-color: #4285f4;
            color: white !important;
            text-decoration: none;
            font-weight: 500;
            transition: background-color 0.2s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .toggle-links a:hover {
            background-color: #3367d6;
        }
        .arrow-icon {
            margin-left: 8px;
            font-size: 1.1em;
        }

    </style>


</head>

<body>

<button onclick="goTop()" id="goTopButton" title="Go to top">Top</button>

<script>

    topButton = document.getElementById("goTopButton");

    
    window.onscroll = function() { scrollFunction() };

    function scrollFunction() {
        if (document.body.scrollTop > 40 || document.documentElement.scrollTop > 40) {
            topButton.style.display = "block";
        } else {
            topButton.style.display = "none";
        }
    }

    
    function goTop() {
        document.body.scrollTop = 0; 
        document.documentElement.scrollTop = 0; 
    }

    
    document.addEventListener('DOMContentLoaded', function() {
        
        const showMoreLinkGC = document.querySelector('.show-more-gc');
        const showLessLinkGC = document.querySelector('.show-less-gc');
        const hiddenLinksGC = document.querySelectorAll('.hidden-link-gc');

        if (showMoreLinkGC) {
            showMoreLinkGC.addEventListener('click', function(e) {
                e.preventDefault();
                hiddenLinksGC.forEach(link  => {
                    link.style.display = 'list-item';
                });
                showMoreLinkGC.style.display = 'none';
                showLessLinkGC.style.display = 'inline-flex';
            });
        }

        if (showLessLinkGC) {
            showLessLinkGC.addEventListener('click', function(e) {
                e.preventDefault();
                hiddenLinksGC.forEach(link  => {
                    link.style.display = 'none';
                });
                showLessLinkGC.style.display = 'none';
                showMoreLinkGC.style.display = 'inline-flex';
            });
        }

        
        const showMoreLinkPWC = document.querySelector('.show-more-pwc');
        const showLessLinkPWC = document.querySelector('.show-less-pwc');
        const hiddenLinksPWC = document.querySelectorAll('.hidden-link-pwc');

        if (showMoreLinkPWC) {
            showMoreLinkPWC.addEventListener('click', function(e) {
                e.preventDefault();
                hiddenLinksPWC.forEach(link  => {
                    link.style.display = 'list-item';
                });
                showMoreLinkPWC.style.display = 'none';
                showLessLinkPWC.style.display = 'inline-flex';
            });
        }

        if (showLessLinkPWC) {
            showLessLinkPWC.addEventListener('click', function(e) {
                e.preventDefault();
                hiddenLinksPWC.forEach(link  => {
                    link.style.display = 'none';
                });
                showLessLinkPWC.style.display = 'none';
                showMoreLinkPWC.style.display = 'inline-flex';
            });
        }
    });

</script>

<section class="top-bar animated-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-12">
                <nav class="navbar navbar-expand-lg navbar-light bg-light">
                    <a class="navbar-brand" href="https://theweeklychallenge.org/">
                        <img src="https://theweeklychallenge.org/images/logo.svg" alt="logo">
                    </a>

                    <button class="navbar-toggler d-lg-none"
                            type="button"
                            data-toggle="collapse"
                            data-target="#navigation"
                            aria-controls="navigation"
                            aria-expanded="false"
                            aria-label="Toggle navigation">
                        <span class="navbar-toggler-icon"></span>
                    </button>

                    <div class="navbar-collapse" id="navigation">
                        <ul class="navbar-nav ml-auto">
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/">Home</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/about">About</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/chart">Chart</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/champions">Champions</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/team">Team</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/challenges">Challenges</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/p5-reviews">Perl/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/p6-reviews">Raku/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/recaps">Recaps</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/blogs">Blogs</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/faq">FAQ</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/contact">Contact</a>
                            </li>
                            
                        </ul>
                    </div>
                </nav>
            </div>
        </div>
    </div>
</section>


<section class="global-page-header">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2>Ryan Thompson › Perl Weekly Review #054</h2>
                    <div class="portfolio-meta">
                        <span>Sunday, Apr 12, 2020</span>|
                        <span> Tags:
                            perl
                        </span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

<section class="single-post">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                
                <div style="text-align: center" class="post-img">
                    <img class="img-fluid" alt="" src="https://theweeklychallenge.org/images/blog/p5-review-challenge-054.jpg">
                </div>
                
                <div style="text-align: justify" class="post-content">
                    <p>Continues from <a href="/blog/review-challenge-053/">previous week</a>.</p>
<p>Welcome to the Perl review for Week 054 of the Weekly Challenge! For a quick overview, go through the <a href="/blog/perl-weekly-challenge-054/">original tasks</a> and <a href="/blog/recap-challenge-054/">recap</a> of the weekly challenge.</p>
<h2 id="getting-in-touch">Getting in Touch</h2>
<p><a href="mailto:rjt@cpan.org"><img src="/images/blog/Email.svg" height="50" width="50"> Email</a> › Email me (Ryan) with any feedback about this review.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge"><img src="/images/blog/Github.svg" height="50" width="50"> GitHub</a> › Submit a pull request for any issues you may find with this page.</p>
<p><a href="https://twitter.com/perlwchallenge"><img src="/images/blog/Twitter.svg" height="50" width="50"> Twitter</a> › Join the discussion on Twitter!</p>
<p>We&rsquo;d greatly appreciate any feedback you&rsquo;d like to give.</p>
<h2 id="table-of-contents">Table of Contents</h2>
<h3 id="task-1task1--kth-permutation-sequence"><a href="#task1">Task 1</a> › kth Permutation Sequence</h3>
<p>[ <a href="#andrezgz1">Andrezgz</a>  | <a href="#athanasius1">Athanasius</a>  | <a href="#cheok-yin-fung1">Cheok-Yin Fung</a>  | <a href="#colin-crain1">Colin Crain</a>  | <a href="#dave-jacoby1">Dave Jacoby</a>  | <a href="#duncan-c-white1">Duncan C. White</a>  | <a href="#e-choroba1">E. Choroba</a>  | <a href="#jaldhar-h-vyas1">Jaldhar H. Vyas</a>  | <a href="#javier-luque1">Javier Luque</a>  | <a href="#laurent-rosenfeld1">Laurent Rosenfeld</a>  | <a href="#lubos-kolouch1">Lubos Kolouch</a>  | <a href="#mohammad-anwar1">Mohammad S Anwar</a>  | <a href="#peter-meszaros1">Peter Meszaros</a>  | <a href="#roger-bell-west1">Roger Bell West</a>  | <a href="#ruben-westerberg1">Ruben Westerberg</a>  | <a href="#ryan-thompson1">Ryan Thompson</a>  | <a href="#saiftynet1">Saif Ahmed</a>  | <a href="#user-person1">User Person</a>  | <a href="#wanderdoc1">Wanderdoc</a>  | <a href="#yet-ebreo1">Yet Ebreo</a>  ]</p>
<h3 id="task-2task2--collatz-conjecture"><a href="#task2">Task 2</a> › Collatz Conjecture</h3>
<p>[ <a href="#alicia-bielsa2">Alicia Bielsa</a>  | <a href="#andrezgz2">Andrezgz</a>  | <a href="#athanasius2">Athanasius</a>  | <a href="#cheok-yin-fung2">Cheok-Yin Fung</a>  | <a href="#colin-crain2">Colin Crain</a>  | <a href="#cristian-heredia2">Cristina Heredia</a>  | <a href="#dave-jacoby2">Dave Jacoby</a>  | <a href="#duncan-c-white2">Duncan C. White</a>  | <a href="#e-choroba2">E. Choroba</a>  | <a href="#jaldhar-h-vyas2">Jaldhar H. Vyas</a>  | <a href="#javier-luque2">Javier Luque</a>  | <a href="#laurent-rosenfeld2">Laurent Rosenfeld</a>  | <a href="#lubos-kolouch2">Lubos Kolouch</a>  | <a href="#markus-holzer2">Markus Holzer</a>  | <a href="#mohammad-anwar2">Mohammad S Anwar</a>  | <a href="#peter-meszaros2">Peter Meszaros</a>  | <a href="#roger-bell-west2">Roger Bell West</a>  | <a href="#ruben-westerberg2">Ruben Westerberg</a>  | <a href="#ryan-thompson2">Ryan Thompson</a>  | <a href="#saiftynet2">Saif Ahmed</a>  | <a href="#shahed-nooshmand2">Shahed Nooshmand</a>  | <a href="#ulrich-rieke2">Ulrich Rieke</a>  | <a href="#user-person2">User Person</a>  | <a href="#wanderdoc2">Wanderdoc</a>  | <a href="#yet-ebreo2">Yet Ebreo</a>  ]</p>
<h3 id="blogsblogs"><a href="#blogs">Blogs</a></h3>
<hr>
<hr>
<h1 id="task1">Task #1 - kth Permutation Sequence</h1>
<p>Original Description:</p>
<p>Write a script to accept two integers n (&gt;=1) and k (&gt;=1). It should print the kth permutation of n integers. For more information, please follow the <a href="https://en.wikipedia.org/wiki/Permutation#k-permutations_of_n">wiki page</a>.</p>
<p>For example, n=3 and k=4, the possible permutation sequences are listed below:</p>
<p>123 132 213 231 312 321</p>
<p>The script should print the 4th permutation sequence 231.</p>
<hr>
<h2 id="solution-types">Solution Types</h2>
<h3 id="1-use-a-module">1. Use a module</h3>
<p>Several hackers used various CPAN modules to avoid having to write permutation code. <a href="https://metacpan.org/pod/Algorithm::Combinatorics"><code>Algorithm::Combinatorics</code></a> was a popular one, but there were others.</p>
<h3 id="2-roll-your-own">2. Roll your own</h3>
<p>Writing code to enumerate permutations isn&rsquo;t so bad. <a href="https://en.wikipedia.org/wiki/Heap%27s_algorithm">Heap&rsquo;s algorithm</a> or <a href="http://www.cs.utsa.edu/~wagner/knuth/fasc2b.pdf">Knuth&rsquo;s &ldquo;Algorithm L&rdquo;</a> are effective.</p>
<p>One hilarious method I considered, but did not implement, is a &ldquo;Bogoperm&rdquo; algorithm, similar to <a href="https://en.wikipedia.org/wiki/Bogosort">Bogosort</a>, that just randomly shuffles the set <em>k</em> times, and if those random shuffles are in lexicographic order, the <em>k</em>th shuffle is the winner. Implementing it would have been easy. Testing, less so.</p>
<h2 id="stats">Stats</h2>
<ul>
<li>
<p>Number of submissions: <strong>20</strong></p>
</li>
<li>
<p>Total SLOC: <strong>961</strong></p>
</li>
<li>
<p>Average SLOC: <strong>48</strong></p>
</li>
</ul>
<h2 id="andrezgz1">Andrezgz</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/andrezgz/perl/ch-1.pl">Andrezgz&rsquo;s solution</a> includes a <code>factorial</code> function to calculate the factorial of <code>$n</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">factorial</span> {
    <span style="color:#66d9ef">my</span> $n <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">if</span> ($n <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>);
    <span style="color:#66d9ef">return</span> $n <span style="color:#f92672">*</span> factorial($n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
}
</code></pre></div><p>A factorial function is useful for bounds checking. Since there are <em>n</em>!
permutations of <em>n</em> numbers, you can check if the user&rsquo;s <em>k</em> value is in
bounds:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> $n_max_perm <span style="color:#f92672">=</span> factorial($n);
die $usage <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34;$n integers have $n_max_perm permutations,&#34;</span>
           <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34;so &lt;k&gt; should be less than $n_max_perm\n&#34;</span>
    <span style="color:#66d9ef">if</span> ($k <span style="color:#f92672">&gt;</span> $n_max_perm);
</code></pre></div><p>I appreciate this attention to detail.</p>
<p>The <code>permute</code> sub generates the permutations, and <code>die</code>s when the <code>$k</code>th
permutation is reached:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> $perm_n <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
permute( [<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$n]);

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">permute</span> {
    <span style="color:#66d9ef">my</span> $numbers <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">my</span> $perm <span style="color:#f92672">=</span> shift <span style="color:#e6db74">//</span> <span style="color:#e6db74">&#39;&#39;</span>;

    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>@$numbers){
        die $perm<span style="color:#f92672">.</span>$/ <span style="color:#66d9ef">if</span> (<span style="color:#f92672">++</span>$perm_n <span style="color:#f92672">==</span> $k); <span style="color:#75715e">#finish on kth permutation</span>
        <span style="color:#66d9ef">return</span>;
    }

    <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $i (<span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> @$numbers<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
        <span style="color:#66d9ef">my</span> $c <span style="color:#f92672">=</span> $numbers<span style="color:#f92672">-&gt;</span>[$i];
        <span style="color:#66d9ef">my</span> @new_n <span style="color:#f92672">=</span> grep { $_ <span style="color:#f92672">!=</span> $c } @$numbers;
        permute( <span style="color:#f92672">\</span>@new_n  , $perm <span style="color:#f92672">.</span> $c);
    }
    <span style="color:#66d9ef">return</span>;
}
</code></pre></div><h2 id="athanasius1">Athanasius</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/athanasius/perl/ch-1.pl">Athanasius&rsquo;s solution</a> uses <a href="https://metacpan.org/pod/Algorithm::Loops"><code>Algorithm::Loops</code></a>&rsquo; <code>NextPermuteNum</code> sub to generate the next permutation of <code>@list</code> <code>$k-1</code> times:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">use</span> Algorithm::Loops      <span style="color:#e6db74">qw( NextPermuteNum )</span>;
<span style="color:#66d9ef">my</span>  @list   <span style="color:#f92672">=</span>  <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> $n;
<span style="color:#66d9ef">my</span>  $sep    <span style="color:#f92672">=</span> ($n <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>) ? <span style="color:#e6db74">&#39;&#39;</span> : <span style="color:#e6db74">&#39; &#39;</span>;

NextPermuteNum( @list ) <span style="color:#66d9ef">for</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">..</span> $k;

printf <span style="color:#e6db74">&#34;The %s permutation of %s is %s\n&#34;</span>,
        ordinal($k), join($sep, <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> $n), join($sep, @list);
}
</code></pre></div><p>Athanasius even gives us a nice little <code>ordinal</code> function to turn a number into its ordinal, like 1st, 2nd, 3rd, and so on:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">ordinal</span> {
    <span style="color:#66d9ef">my</span> ($n)     <span style="color:#f92672">=</span> @_;
    <span style="color:#66d9ef">my</span>  $suffix <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;th&#39;</span>;
    <span style="color:#66d9ef">my</span>  $dig1   <span style="color:#f92672">=</span> int(($n % 100) <span style="color:#f92672">/</span> <span style="color:#ae81ff">10</span>);

    <span style="color:#66d9ef">unless</span> ($dig1 <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
        <span style="color:#66d9ef">my</span> $dig0 <span style="color:#f92672">=</span> $n % 10;
        $suffix  <span style="color:#f92672">=</span> $dig0 <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> ? <span style="color:#e6db74">&#39;st&#39;</span> :
                   $dig0 <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span> ? <span style="color:#e6db74">&#39;nd&#39;</span> :
                   $dig0 <span style="color:#f92672">==</span> <span style="color:#ae81ff">3</span> ? <span style="color:#e6db74">&#39;rd&#39;</span> : <span style="color:#e6db74">&#39;th&#39;</span>;
    }

    <span style="color:#66d9ef">return</span> $n <span style="color:#f92672">.</span> $suffix;
}
</code></pre></div><h2 id="cheok-yin-fung1">Cheok-Yin Fung</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/cheok-yin-fung/perl/ch-1.pl">Cheok-Yin Fung&rsquo;s solution</a> generates all permutations, and then sorts them and takes the <code>$k</code>th result from the array. The code to generate the permutations is a bit lengthy, but I don&rsquo;t think I can give a partial excerpt and have it make sense:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> @result <span style="color:#f92672">=</span> ();
<span style="color:#66d9ef">my</span> @char <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$P;

<span style="color:#66d9ef">my</span> @arrow <span style="color:#f92672">=</span> map { <span style="color:#ae81ff">1</span> } @char; <span style="color:#75715e">#arrows for algorithm for generating permututations</span>
                             <span style="color:#75715e">#true for pointing to left, undef for pointing to right</span>

<span style="color:#66d9ef">my</span> $n <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;

<span style="color:#66d9ef">my</span> @mobile <span style="color:#f92672">=</span> ();    <span style="color:#75715e">#store the indices</span>

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">mmax</span> {  <span style="color:#75715e">#modified from &#34;Learning Perl&#34;, return the index of the largest char which in the status of  mobile</span>
    <span style="color:#66d9ef">my</span> @mchar <span style="color:#f92672">=</span> @char;
    <span style="color:#66d9ef">my</span> $champion <span style="color:#f92672">=</span> shift @_;
    <span style="color:#66d9ef">foreach</span> (@_) {
        <span style="color:#66d9ef">if</span> ( $mchar[$_] <span style="color:#f92672">gt</span> $mchar[$champion]) {$champion <span style="color:#f92672">=</span> $_;}
    }
    $champion;
}

<span style="color:#66d9ef">my</span> $noofperm <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
<span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i (<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$P) {$noofperm <span style="color:#f92672">*=</span> $i;}

push @result, join(<span style="color:#e6db74">&#34;&#34;</span>, @char);

<span style="color:#66d9ef">while</span> ( $n <span style="color:#f92672">&lt;=</span> $noofperm<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>  ) {
    <span style="color:#66d9ef">my</span> $j;
    @mobile <span style="color:#f92672">=</span> ();
    $j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#66d9ef">if</span> ( ($char[$j] <span style="color:#f92672">gt</span> $char[$j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]) <span style="color:#f92672">and</span> <span style="color:#f92672">not</span>($arrow[$j])) {
        push @mobile, $j;
    }
    <span style="color:#66d9ef">for</span> $j (<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$#char<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
        <span style="color:#66d9ef">if</span> ( ( $char[$j] <span style="color:#f92672">gt</span> $char[$j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">and</span> $arrow[$j]) <span style="color:#f92672">or</span>
        ( $char[$j] <span style="color:#f92672">gt</span> $char[$j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">and</span> <span style="color:#f92672">not</span>($arrow[$j])) ) {
            push @mobile, $j;
        }
    }
    $j <span style="color:#f92672">=</span> $#char; <span style="color:#66d9ef">if</span> ( $char[$j] <span style="color:#f92672">gt</span> $char[$j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">and</span> $arrow[$j]) {
        push @mobile, $j;
    }

    <span style="color:#66d9ef">if</span> ( $#mobile <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> ) {
        <span style="color:#66d9ef">my</span> $m <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>mmax(@mobile);
        <span style="color:#66d9ef">my</span> $todaychamp;   <span style="color:#75715e"># a character</span>
        <span style="color:#66d9ef">my</span> $arrowdirection; <span style="color:#75715e"># a boolean</span>
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">not</span>($arrow[$m])) {
            $todaychamp <span style="color:#f92672">=</span> $char[$m];
            $char[$m]<span style="color:#f92672">=</span>$char[$m<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>];
            $char[$m<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> $todaychamp;
            $arrowdirection <span style="color:#f92672">=</span> $arrow[$m];
            $arrow[$m] <span style="color:#f92672">=</span> $arrow[$m<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>];
            $arrow[$m<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> $arrowdirection;
    <span style="color:#75715e"># then switch the direction of all the arrows above integers p with p&gt;m</span>
            <span style="color:#66d9ef">foreach</span> (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$#char) {
                <span style="color:#66d9ef">if</span> ($char[$_] <span style="color:#f92672">gt</span> $todaychamp ) {
                    $arrow[$_] <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>knot($arrow[$_]);
                }
            }
        } <span style="color:#66d9ef">else</span> {
            $todaychamp <span style="color:#f92672">=</span> $char[$m];
            $char[$m]<span style="color:#f92672">=</span>$char[$m<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
            $char[$m<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> $todaychamp;
            $arrowdirection <span style="color:#f92672">=</span> $arrow[$m];
            $arrow[$m] <span style="color:#f92672">=</span> $arrow[$m<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
            $arrow[$m<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> $arrowdirection;
            <span style="color:#66d9ef">foreach</span> (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$#char) {
                <span style="color:#66d9ef">if</span> ($char[$_] <span style="color:#f92672">gt</span> $todaychamp  ) {
                    $arrow[$_] <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>knot($arrow[$_]);
                }
            }
        }
    }
    <span style="color:#75715e">#switch the largest mobile integer m and the adjacent integer its arrow points to;</span>
    <span style="color:#75715e">#the algorithms used here ref to</span>
    <span style="color:#75715e">#&#34;Introductory Combinatorics&#34; 4th Edition by page 88, by Richard A. Brualdi</span>
    push @result, join(<span style="color:#e6db74">&#34;&#34;</span>, @char);
    $n<span style="color:#f92672">++</span>;

}

<span style="color:#66d9ef">my</span> @result <span style="color:#f92672">=</span> sort {$a <span style="color:#e6db74">&lt;=&gt;</span> $b} @result;

<span style="color:#66d9ef">print</span> $result[$k<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
</code></pre></div><p>Cheok Yin mentions that she wrote this code as an exercise a long time ago, so I won&rsquo;t do an in-depth review, as her skills have evolved since then.</p>
<p><strong>Blog</strong> › <a href="http://blogs.perl.org/users/c_y_fung/2020/04/cys-take-on-pwc054.html">CY&rsquo;s take on PWC#054</a></p>
<h2 id="colin-crain1">Colin Crain</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/colin-crain/perl/ch-1.pl">Colin Crain&rsquo;s solution</a> includes two methods of generating permutations. First up is the recursive method:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">permute_with_recursion</span> {
    <span style="color:#66d9ef">my</span> ( $end, $selected_sequence ) <span style="color:#f92672">=</span> @_;
    <span style="color:#66d9ef">my</span> @set          <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$end);
    <span style="color:#66d9ef">my</span> @working;
    <span style="color:#66d9ef">my</span> $permutations <span style="color:#f92672">=</span> <span style="color:#f92672">[]</span>;
    <span style="color:#66d9ef">my</span> $data         <span style="color:#f92672">=</span> { seq_number <span style="color:#f92672">=&gt;</span> $selected_sequence,
                         result     <span style="color:#f92672">=&gt;</span> undef };

    permute_recursive( <span style="color:#f92672">\</span>@set, <span style="color:#f92672">\</span>@working, $permutations, $data);

    <span style="color:#66d9ef">return</span> $data<span style="color:#f92672">-&gt;</span>{result};
}

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">permute_recursive</span> {
<span style="color:#75715e">## given a starting set, a working list and a permutations set</span>
<span style="color:#75715e">## computes complete permutations as arrays and places the arrays on the permutations array</span>
<span style="color:#75715e">## which is maintained throughout by reference</span>
    <span style="color:#66d9ef">my</span> ($setref, $workref, $permutations, $data) <span style="color:#f92672">=</span> @_;
    <span style="color:#66d9ef">my</span> @set <span style="color:#f92672">=</span> $setref<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>

    <span style="color:#960050;background-color:#1e0010">##</span> if there is only one element left, push it on the working list,
    <span style="color:#75715e">## push that array reference onto the permutations array and return.</span>
    <span style="color:#75715e">## This unique permutation list is complete.</span>
    <span style="color:#66d9ef">if</span> ( scalar @set <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> ) {
        <span style="color:#66d9ef">my</span> @working <span style="color:#f92672">=</span> $workref<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>
        push @working,      $set[<span style="color:#ae81ff">0</span>];
        <span style="color:#66d9ef">if</span> (scalar $permutations<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span> <span style="color:#960050;background-color:#1e0010">==</span> <span style="color:#960050;background-color:#1e0010">$</span>data<span style="color:#f92672">-&gt;</span>{seq_number} <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) {
            $data<span style="color:#f92672">-&gt;</span>{result} <span style="color:#f92672">=</span> <span style="color:#f92672">\</span>@working;
        }
        <span style="color:#66d9ef">else</span> {
            push $permutations<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span>,  <span style="color:#f92672">\</span>@working;
        }
        <span style="color:#66d9ef">return</span>;
    }

    <span style="color:#75715e">## iterate through the remaining elements of the set,</span>
    <span style="color:#75715e">## creating  new copy of the working list, moving the element</span>
    <span style="color:#75715e">## from the set to the working list and recursing with these</span>
    <span style="color:#75715e">## new lists. The permutations list reference is passed through unchanged.</span>
    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $element ( @set ) {

        <span style="color:#75715e">## collapse the recursion if we have our result</span>
        <span style="color:#66d9ef">last</span> <span style="color:#66d9ef">if</span> defined $data<span style="color:#f92672">-&gt;</span>{result};

        <span style="color:#66d9ef">my</span> @working <span style="color:#f92672">=</span> $workref<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>
        push @working, $element;
        <span style="color:#66d9ef">my</span> @subset <span style="color:#f92672">=</span> grep { $_ <span style="color:#f92672">!=</span> $element } @set;
        permute_recursive( <span style="color:#f92672">\</span>@subset, <span style="color:#f92672">\</span>@working, $permutations, $data );
    }
}
</code></pre></div><p>Next up is the in-place algorithm, based on Knuth&rsquo;s <a href="http://www.cs.utsa.edu/~wagner/knuth/fasc2b.pdf">Algorithm L</a>, a classic in computer science:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">permute_in_place</span> {
    <span style="color:#66d9ef">my</span> ( $end, $selected_sequence ) <span style="color:#f92672">=</span> @_;
    <span style="color:#66d9ef">my</span> @set <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$end);

    <span style="color:#75715e">## the unrearranged sequence, the identity permutation,</span>
    <span style="color:#75715e">## counts as sequence #1 as per the task</span>
    <span style="color:#66d9ef">for</span> (<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$selected_sequence<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
        compute_next_permutation( <span style="color:#f92672">\</span>@set );
    }

    <span style="color:#66d9ef">return</span> <span style="color:#f92672">\</span>@set;
}
</code></pre></div><p>I&rsquo;ll let Colin&rsquo;s comments do the talking here. The L1..L4 refer to Knuth&rsquo;s own annotations from the passage I&rsquo;ve linked, above, from <em>The Art of Computer Programming.</em> Here is the in-place next permutation sub:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">compute_next_permutation</span> {
<span style="color:#75715e">## in place algorithm (from Knuth Algorithm L, The Art of Computer Programming)</span>
<span style="color:#75715e">#</span>
<span style="color:#75715e">#      «before we start we assume a sorted sequence a[0] &lt;= a[1] &lt;= ... &lt;= a[n]»</span>
<span style="color:#75715e"># L1.  «Visit»  Take the given arrangement</span>
<span style="color:#75715e"># L2.  «Find j»  Find the largest index j such that a[j] &lt; a[j + 1]. If no such index</span>
<span style="color:#75715e">#         exists, terminate the algorithm and we are done</span>
<span style="color:#75715e"># L3.  «Increase a[j]»  Find the largest index k greater than j such that a[j] &lt; a[k],</span>
<span style="color:#75715e"># L3a.    then swap the values of a[j] and a[k].</span>
<span style="color:#75715e"># L4.  «Reverse a[j+1]..a[n]»  Reverse the subsequence starting at a[j + 1] through the end of the permutation,</span>
<span style="color:#75715e">#         a[n]. Do nothing if j+1 &gt;= n. Return to L1.</span>
    <span style="color:#75715e">## L1</span>
    <span style="color:#66d9ef">my</span> $set <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">my</span> $end <span style="color:#f92672">=</span> scalar $set<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span> <span style="color:#960050;background-color:#1e0010">-</span> 1;

    <span style="color:#75715e">## L2</span>
    <span style="color:#66d9ef">my</span> @one <span style="color:#f92672">=</span> grep { $set<span style="color:#f92672">-&gt;</span>[$_] <span style="color:#f92672">&lt;</span> $set<span style="color:#f92672">-&gt;</span>[$_<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] } (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$end<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
    <span style="color:#66d9ef">my</span> $j <span style="color:#f92672">=</span> $one[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span> defined $j;

    <span style="color:#75715e">## L3</span>
    <span style="color:#66d9ef">my</span> @two <span style="color:#f92672">=</span> grep { $_ <span style="color:#f92672">&gt;</span> $j <span style="color:#f92672">and</span> $set<span style="color:#f92672">-&gt;</span>[$_] <span style="color:#f92672">&gt;</span> $set<span style="color:#f92672">-&gt;</span>[$j] } (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$end);
    <span style="color:#66d9ef">my</span> $k <span style="color:#f92672">=</span> $two[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];

    <span style="color:#75715e">## L3a</span>
    ($set<span style="color:#f92672">-&gt;</span>[$j], $set<span style="color:#f92672">-&gt;</span>[$k]) <span style="color:#f92672">=</span> ($set<span style="color:#f92672">-&gt;</span>[$k], $set<span style="color:#f92672">-&gt;</span>[$j]);

    <span style="color:#75715e">## L4</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">unless</span> ( $j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span> $end );

    <span style="color:#66d9ef">my</span> @reversed <span style="color:#f92672">=</span> reverse($set<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">[</span> <span style="color:#960050;background-color:#1e0010">($</span>j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">..</span>$end ]);
    splice $set<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span>, $j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, $end<span style="color:#f92672">-</span>$j, @reversed;
}
</code></pre></div><p>Colin mentions that he does not always go for the &ldquo;fastest, most sensible&rdquo; methodology for these tasks, and that he likes to explore the task &ldquo;to see what&rsquo;s there.&rdquo; That&rsquo;s a great attitude. After all, if we were all chasing performance and sensibility above all else, there would be very little to differentiate our solutions every week, which would make my life as a reviewer exceedingly boring.</p>
<h2 id="dave-jacoby1">Dave Jacoby</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/dave-jacoby/perl/ch-1.pl">Dave Jacoby&rsquo;s solution</a> has a <code>return_permutation</code> sub that returns the <code>$k</code>th permutation of <code>$n</code> integers:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">use</span> feature <span style="color:#e6db74">qw{ fc postderef say signatures state switch }</span>;
<span style="color:#66d9ef">no</span> warnings <span style="color:#e6db74">qw{ experimental }</span>;

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">return_permutation</span> ( $n, $k ) {
    $n <span style="color:#f92672">=</span> int $n;
    $k <span style="color:#f92672">=</span> int $k;
    croak <span style="color:#e6db74">&#39;n &lt; 1&#39;</span> <span style="color:#66d9ef">unless</span> $n <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">1</span>;
    croak <span style="color:#e6db74">&#39;k &lt; 1&#39;</span> <span style="color:#66d9ef">unless</span> $k <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">my</span> $src<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span> <span style="color:#960050;background-color:#1e0010">=</span> 1 <span style="color:#f92672">..</span> $n;
    <span style="color:#66d9ef">my</span> @permutations <span style="color:#f92672">=</span> permute_array($src);
    <span style="color:#66d9ef">my</span> @output;

    <span style="color:#66d9ef">if</span> ( $permutations[ $k <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> ] ) {
        push @output, $permutations[ $k <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> ]<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>
    <span style="color:#960050;background-color:#1e0010">}</span>

    return wantarray ? @output : <span style="color:#f92672">\</span>@output;
}
</code></pre></div><p>The recursive <a href="https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm">D&amp;C</a> <code>permute_array</code> does the hard work, however:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">permute_array</span> ( $array ) {
    <span style="color:#66d9ef">return</span> $array <span style="color:#66d9ef">if</span> scalar $array<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span> <span style="color:#960050;background-color:#1e0010">==</span> 1;
    <span style="color:#66d9ef">my</span> @response <span style="color:#f92672">=</span> map {
        <span style="color:#66d9ef">my</span> $i        <span style="color:#f92672">=</span> $_;
        <span style="color:#66d9ef">my</span> $d        <span style="color:#f92672">=</span> $array<span style="color:#f92672">-&gt;</span>[$i];
        <span style="color:#66d9ef">my</span> $copy<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span> <span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#960050;background-color:#1e0010">$</span>array<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>
        splice $copy<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span>, $i, <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">my</span> @out <span style="color:#f92672">=</span> map { unshift $_<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span>, $d; $_ } permute_array($copy);
        @out
    } <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> scalar $array<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span> <span style="color:#960050;background-color:#1e0010">-</span> 1;
    <span style="color:#66d9ef">return</span> @response;
}
</code></pre></div><p>First, if you&rsquo;re not already using post-deref syntax, let me highlight what I think one of the nice things about it is: making a shallow copy of an array ref. <code>my $copy-&gt;@* = $array-&gt;@*</code> is compact, and (provided you&rsquo;ve seen <code>-&gt;@*</code> before) neatly describes the intent of the code.</p>
<p>Dave&rsquo;s code permutes the array in order by doing a depth-first traversal, calling <code>permute_array</code> on smaller subsets of the elements. This is essentially Heap&rsquo;s algorithm in more idiomatic Perl.</p>
<p><strong>Blog</strong> › <a href="https://jacoby.github.io/2020/03/30/permutations-and-conjectures.html">Permutations and Conjectures</a></p>
<h2 id="duncan-c-white1">Duncan C. White</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/duncan-c-white/perl/ch-1.pl">Duncan C. White&rsquo;s solution</a> starts with the following fun fact:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">use</span> Function::Parameters;

fun fact( $n ) {
    <span style="color:#66d9ef">my</span> $result <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    $result <span style="color:#f92672">*=</span> $_ <span style="color:#66d9ef">for</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$n;
    <span style="color:#66d9ef">return</span> $result;
}
</code></pre></div><p>This fun <code>fun fact</code> factorial function fairly frugally fences fed-in figures. To all of the non-native (and native) English speakers out there, I sincerely apologize, but I couldn&rsquo;t resist. Please see <a href="#andrezgz1">Andrezgz</a>&lsquo;s solution for a more direct explanation.</p>
<p>The <code>nthperm</code> function recursively finds the <code>$n</code>th permutation of a string:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">fun nthperm( $permno, $alldigits, $n, $nperms ) {
    <span style="color:#66d9ef">if</span> ( $n <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> ) {
        <span style="color:#66d9ef">return</span> substr( $alldigits, $permno, <span style="color:#ae81ff">1</span> );
    }
    <span style="color:#66d9ef">my</span> $w <span style="color:#f92672">=</span> $nperms <span style="color:#f92672">/</span> $n;

    <span style="color:#66d9ef">my</span> $firstdigit <span style="color:#f92672">=</span> substr( $alldigits, int( $permno <span style="color:#f92672">/</span> $w ), <span style="color:#ae81ff">1</span> );
    <span style="color:#66d9ef">my</span> $permstr    <span style="color:#f92672">=</span> $firstdigit;
    $alldigits <span style="color:#f92672">=~</span> <span style="color:#e6db74">s/$firstdigit//</span>;
    $permstr <span style="color:#f92672">.=</span> nthperm( $permno % <span style="color:#960050;background-color:#1e0010">$</span>w, $alldigits, $n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, $nperms <span style="color:#f92672">/</span> $n );
    <span style="color:#66d9ef">return</span> $permstr;
}
</code></pre></div><h2 id="e-choroba1">E. Choroba</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/e-choroba/perl/ch-1.pl">E. Choroba&rsquo;s solution</a> uses recent <a href="https://metacpan.org/pod/List::Util"><code>List::Util</code></a>&lsquo;s <code>product</code> as an easy factorial:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> $factorial <span style="color:#f92672">=</span> product(<span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> @n);
</code></pre></div><p>The recursive D&amp;C <code>perm_recurse</code> sub finds the <code>$k</code>th permutation of <code>@n</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">use</span> List::Util <span style="color:#e6db74">qw{ product }</span>;

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">perm_recurse</span> {
    <span style="color:#66d9ef">my</span> ($k, @n) <span style="color:#f92672">=</span> @_;
    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span> <span style="color:#66d9ef">unless</span> @n;

    <span style="color:#66d9ef">my</span> $factorial <span style="color:#f92672">=</span> product(<span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> @n);
    <span style="color:#66d9ef">my</span> $step <span style="color:#f92672">=</span> $factorial <span style="color:#f92672">/</span> @n;

    <span style="color:#66d9ef">my</span> $select <span style="color:#f92672">=</span> int($k <span style="color:#f92672">/</span> $step);
    <span style="color:#f92672">--</span>$select <span style="color:#66d9ef">unless</span> $k % <span style="color:#960050;background-color:#1e0010">$</span>step;

    <span style="color:#66d9ef">return</span> $n[$select]
        <span style="color:#f92672">.</span> perm_recurse(($k % <span style="color:#960050;background-color:#1e0010">$</span>step) <span style="color:#f92672">||</span> $step,
                       @n[ grep $_ <span style="color:#f92672">!=</span> $select, <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $#n ])
}

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">kth_perm</span> { perm_recurse($_[<span style="color:#ae81ff">1</span>], <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> $_[<span style="color:#ae81ff">0</span>]) }

<span style="color:#66d9ef">my</span> ($n, $k) <span style="color:#f92672">=</span> @ARGV;
say kth_perm($n, $k);
</code></pre></div><p><strong>Blog</strong> › <a href="http://blogs.perl.org/users/e_choroba/2020/04/perl-weekly-challenge-054-kth-permutation-sequence-collatz-conjecture.html">Kth Permutation Sequence + Collatz Conjecture</a></p>
<h2 id="jaldhar-h-vyas1">Jaldhar H. Vyas</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/jaldhar-h-vyas/perl/ch-1.pl">Jaldhar H. Vyas&rsquo;s solution</a> takes the permutation code directly from <a href="https://learn.perl.org/faq/perlfaq4.html#How-do-I-permute-N-elements-of-a-list"><code>perlfaq4</code></a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">permute</span> (&amp;@) {
    <span style="color:#66d9ef">my</span> $code <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">my</span> @idx <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$#_;
    <span style="color:#66d9ef">while</span> ( $code<span style="color:#f92672">-&gt;</span>(@_[@idx]) ) {
        <span style="color:#66d9ef">my</span> $p <span style="color:#f92672">=</span> $#idx;
        <span style="color:#f92672">--</span>$p <span style="color:#66d9ef">while</span> $idx[$p<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">&gt;</span> $idx[$p];
        <span style="color:#66d9ef">my</span> $q <span style="color:#f92672">=</span> $p <span style="color:#f92672">or</span> <span style="color:#66d9ef">return</span>;
        push @idx, reverse splice @idx, $p;
        <span style="color:#f92672">++</span>$q <span style="color:#66d9ef">while</span> $idx[$p<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">&gt;</span> $idx[$q];
        @idx[$p<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,$q]<span style="color:#f92672">=</span>@idx[$q,$p<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
    }
}
</code></pre></div><p>Jaldhar provides a callback that simply pushes a reference to each permutation
onto <code>@permutations</code>, and then prints the <code>$k</code>th permutation:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> @permutations;
permute { push @permutations, <span style="color:#f92672">\</span>@_; } (<span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> $n);
say join <span style="color:#e6db74">q{}</span>, @{ $permutations[$k <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] };
</code></pre></div><p><strong>Blog</strong> › <a href="https://www.braincells.com/perl/2020/04/perl_weekly_challenge_week_54.html">Jaldhar&rsquo;s Week #054 Blog</a></p>
<h2 id="javier-luque1">Javier Luque</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/javier-luque/perl/ch-1.pl">Javier Luque&rsquo;s solution</a> uses <a href="https://metacpan.org/pod/Algorithm::Combinatorics"><code>Algorithm::Combinatorics</code></a> to generate permutations:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">use</span> Algorithm::Combinatorics <span style="color:#e6db74">qw(permutations)</span>;

<span style="color:#66d9ef">my</span> $n <span style="color:#f92672">=</span> $ARGV[<span style="color:#ae81ff">0</span>];
<span style="color:#66d9ef">my</span> $k <span style="color:#f92672">=</span> $ARGV[<span style="color:#ae81ff">1</span>];

<span style="color:#66d9ef">my</span> @data <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> $n;
<span style="color:#66d9ef">my</span> @all_permutations <span style="color:#f92672">=</span> permutations(<span style="color:#f92672">\</span>@data);
say join <span style="color:#e6db74">&#39;&#39;</span>, @{$all_permutations[$k <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]};
</code></pre></div><p><strong>Blog</strong> › <a href="https://perlchallenges.wordpress.com/2020/03/30/perl-weekly-challenge-054/">054 – Perl Weekly Challenge</a></p>
<h2 id="laurent-rosenfeld1">Laurent Rosenfeld</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/laurent-rosenfeld/perl/ch-1.pl">Laurent Rosenfeld&rsquo;s solution</a> uses a recursive D&amp;C <code>permute</code> sub:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> @start <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$n;
permute(<span style="color:#e6db74">&#34;&#34;</span>, @start);

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">permute</span> {
    <span style="color:#66d9ef">my</span> ($str, @vals) <span style="color:#f92672">=</span> @_;
    <span style="color:#66d9ef">if</span> (scalar @vals <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
        say $str <span style="color:#f92672">and</span> exit <span style="color:#66d9ef">unless</span> <span style="color:#f92672">--</span>$k;
        <span style="color:#66d9ef">return</span>;
    }
    permute(<span style="color:#e6db74">&#34;$str &#34;</span> <span style="color:#f92672">.</span> $vals[$_], @vals[<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$_<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], @vals[$_<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$#vals]) <span style="color:#66d9ef">for</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$#vals;
}
</code></pre></div><p><strong>Blog</strong> › <a href="http://blogs.perl.org/users/laurent_r/2020/04/perl-weekly-challenge-54-k-th-permutation-sequence-and-the-collatz-conjecture.html">k-th Permutation Sequence and the Collatz Conjecture</a></p>
<h2 id="lubos-kolouch1">Lubos Kolouch</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/lubos-kolouch/perl/ch-1.pl">Lubos Kolouch&rsquo;s solution</a> uses <a href="https://metacpan.org/pod/Algorithm::Permute"><code>Algorithm::Permute</code></a> to iterate all permutations until the <code>$k</code>th permutation is reached:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">use</span> Algorithm::Permute;

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">get_nth_permutations</span> {
    <span style="color:#66d9ef">my</span> ( $n, $k ) <span style="color:#f92672">=</span> @_;
    <span style="color:#66d9ef">my</span> @numbers <span style="color:#f92672">=</span> ( <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> $n );
    <span style="color:#66d9ef">my</span> $p <span style="color:#f92672">=</span> Algorithm::Permute<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">new</span>(<span style="color:#f92672">\</span>@numbers, $n);

    <span style="color:#66d9ef">my</span> @all_perms;
    <span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">my</span> @res <span style="color:#f92672">=</span> $p<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">next</span>) {
        push @all_perms, join(<span style="color:#e6db74">&#34;&#34;</span>, @res);
    }
    <span style="color:#66d9ef">my</span> @sorted_perms <span style="color:#f92672">=</span> sort @all_perms;

    <span style="color:#66d9ef">return</span> $sorted_perms[$k<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
}

say(get_nth_permutations( <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span> ));
</code></pre></div><p>Lubos keeps all permutations seen so far in <code>@all_perms</code>, and then sorts them once <code>$k</code> have been seen, as the A::P documentation states the order of permutations is not guaranteed.</p>
<h2 id="mohammad-anwar1">Mohammad S Anwar</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/mohammad-anwar/perl/ch-1.pl">Mohammad S Anwar&rsquo;s solution</a> uses <a href="https://metacpan.org/pod/Algorithm::Combinatorics"><code>Algorithm::Combinatorics</code></a> to generate permutations:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">use</span> List::Util <span style="color:#e6db74">qw(reduce)</span>;
<span style="color:#66d9ef">use</span> Algorithm::Combinatorics <span style="color:#e6db74">qw(permutations)</span>;

<span style="color:#66d9ef">my</span> $n <span style="color:#f92672">=</span> $ARGV[<span style="color:#ae81ff">0</span>];
<span style="color:#66d9ef">my</span> $k <span style="color:#f92672">=</span> $ARGV[<span style="color:#ae81ff">1</span>];

die <span style="color:#e6db74">&#34;ERROR: Missing digit count.\n&#34;</span>        <span style="color:#66d9ef">unless</span> defined $n;
die <span style="color:#e6db74">&#34;ERROR: Missing sequence number.\n&#34;</span>    <span style="color:#66d9ef">unless</span> defined $k;
die <span style="color:#e6db74">&#34;ERROR: Invalid digit count $n.\n&#34;</span>     <span style="color:#66d9ef">unless</span> $n <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>;
die <span style="color:#e6db74">&#34;ERROR: Invalid sequence number $k.\n&#34;</span> <span style="color:#66d9ef">unless</span> $k <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> ($k <span style="color:#f92672">&lt;=</span> reduce { $a <span style="color:#f92672">*</span> $b } <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> $n);

<span style="color:#66d9ef">print</span> [ map { join <span style="color:#e6db74">&#34;&#34;</span>, @$_ } permutations([ <span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$n ]) ]<span style="color:#f92672">-&gt;</span>[$k<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
</code></pre></div><p>I like the use of <code>reduce</code> to calculate the factorial inline with the error checking. After all, if you know you&rsquo;ll only need something once, there&rsquo;s often no reason to factor it out.</p>
<p><strong>Blog</strong> › <a href="https://perlweeklychallenge.org/blog/weekly-challenge-054">BLOG: The Weekly Challenge #054</a></p>
<h2 id="peter-meszaros1">Peter Meszaros</h2>
<p><strong>Peter Meszaros</strong> is submitting to the Challenge for the first time this week! Please join me in welcoming him.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/peter-meszaros/perl/ch-1.pl">Peter Meszaros&rsquo;s solution</a> uses a D&amp;C recursive solution to generate permutations in order:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">perm</span> {
    state $n <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">my</span> ($k, $perm, @set) <span style="color:#f92672">=</span> @_;
    <span style="color:#66d9ef">unless</span> (@set) {
        <span style="color:#f92672">++</span>$n;
        printf <span style="color:#e6db74">&#34;%2d %s\n&#34;</span>, $n, $perm <span style="color:#66d9ef">if</span> $k <span style="color:#f92672">==</span> $n;
        <span style="color:#66d9ef">return</span> $k <span style="color:#f92672">==</span> $n;
    }
    <span style="color:#66d9ef">foreach</span> (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$#set) {
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">if</span> perm($k, $perm<span style="color:#f92672">.</span>$set[$_], @set[<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$_<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], @set[$_<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$#set]);
    }
}
</code></pre></div><p>Usage is simple:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> @inp <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$ARGV[<span style="color:#ae81ff">0</span>];
perm($k, <span style="color:#e6db74">&#39;&#39;</span>, @inp);
</code></pre></div><p>For Peter&rsquo;s first submission, I am impressed! I hope we&rsquo;ll see a lot more from Peter in the weeks ahead.</p>
<h2 id="roger-bell-west1">Roger Bell West</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/roger-bell-west/perl/ch-1.pl">Roger Bell West&rsquo;s solution</a> generates permutations in place:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> ( $n, $k ) <span style="color:#f92672">=</span> @ARGV;

<span style="color:#66d9ef">my</span> @f;
<span style="color:#66d9ef">my</span> $b <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
<span style="color:#66d9ef">my</span> $v <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
<span style="color:#66d9ef">while</span> ( ( scalar @f <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> ) <span style="color:#f92672">||</span> $f[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">&lt;</span> $k ) {
    push @f, $v;
    $v <span style="color:#f92672">*=</span> $b;
    $b<span style="color:#f92672">++</span>;
}

<span style="color:#66d9ef">my</span> $nk <span style="color:#f92672">=</span> $k <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
<span style="color:#66d9ef">my</span> @n;
<span style="color:#66d9ef">for</span> ( <span style="color:#66d9ef">my</span> $i <span style="color:#f92672">=</span> $#f ; $i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> ; $i<span style="color:#f92672">--</span> ) {
    unshift @n, $nk <span style="color:#f92672">/</span> $f[$i];
    $nk <span style="color:#f92672">-=</span> $f[$i] <span style="color:#f92672">*</span> $n[<span style="color:#ae81ff">0</span>];
}

<span style="color:#66d9ef">my</span> @i <span style="color:#f92672">=</span> ( <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> $n );
<span style="color:#66d9ef">my</span> @o;
<span style="color:#66d9ef">for</span> ( <span style="color:#66d9ef">my</span> $i <span style="color:#f92672">=</span> $n ; $i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">1</span> ; $i<span style="color:#f92672">--</span> ) {
    <span style="color:#66d9ef">my</span> $f <span style="color:#f92672">=</span> $n[ $i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> ] <span style="color:#f92672">||</span> <span style="color:#ae81ff">0</span>;
    push @o, splice @i, $f, <span style="color:#ae81ff">1</span>;
}
</code></pre></div><p>I like the sly use of the conditional operator to sneak in commas when the numbers go above two digits:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">print</span> join( $n <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">9</span> ? <span style="color:#e6db74">&#39;,&#39;</span> : <span style="color:#e6db74">&#39;&#39;</span>, @o ), <span style="color:#e6db74">&#34;\n&#34;</span>;
</code></pre></div><h2 id="ruben-westerberg1">Ruben Westerberg</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/ruben-westerberg/perl/ch-1.pl">Ruben Westerberg&rsquo;s solution</a> also provides a <code>factorial</code> sub with <code>List::Util</code>'s <code>reduce</code>, to validate <code>$k</code>. The <code>combinations</code> sub generates and returns all permutations:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">combinations</span> {
    <span style="color:#66d9ef">my</span> @combinations<span style="color:#f92672">=</span>();
    <span style="color:#66d9ef">my</span> ($data,$size)<span style="color:#f92672">=</span>@_;
    <span style="color:#66d9ef">my</span> @indexes<span style="color:#f92672">=</span>(<span style="color:#ae81ff">0</span>) x ($size<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);;
    <span style="color:#66d9ef">my</span> $i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">until</span> ($indexes[$size]) {
        <span style="color:#66d9ef">my</span> $count<span style="color:#f92672">=</span>List::Util::uniq(@indexes[<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$size<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]);
        push @combinations, [@$data[@indexes[<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$size<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]]] <span style="color:#66d9ef">if</span> $count <span style="color:#f92672">==</span> $size;
        $indexes[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">++</span>;
        <span style="color:#66d9ef">for</span> (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$size<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
            <span style="color:#66d9ef">if</span> ($indexes[$_] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">==</span> ($indexes[$_] % <span style="color:#960050;background-color:#1e0010">@$</span>data)) {
                $indexes[$_]<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
                $indexes[$_<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">++</span>;
            }
        }
    }
    @combinations;
}
</code></pre></div><p>The permutations require sorting. After that, the <code>$k</code>th element is printed:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> @perm<span style="color:#f92672">=</span>sort {$a <span style="color:#f92672">&gt;</span> $b} map {join <span style="color:#e6db74">&#34;&#34;</span>, @$_} combinations([<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$n], $n);
say $perm[$k<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
</code></pre></div><h2 id="ryan-thompson1">Ryan Thompson</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/ryan-thompson/perl/ch-1.pl">My solution</a> uses <a href="https://metacpan.org/pod/Algorithm::Combinatorics"><code>Algorithm::Combinatorics</code></a>, which provides a nice iterator so I can stop on the <code>$k</code>th permutation:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> $it <span style="color:#f92672">=</span> permutations([<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$n], $n);
$it<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">next</span> <span style="color:#66d9ef">for</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$k<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
say join <span style="color:#e6db74">&#39;&#39;</span>, @{ $it<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">next</span> };
</code></pre></div><p>The array version is quite compact, if slower, especially as the size increases:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">say join <span style="color:#e6db74">&#39;&#39;</span>, @{ ( permutations([<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$n], $n) )[$k<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] };
</code></pre></div><p><strong>Blog</strong> › <a href="http://www.ry.ca/2020/04/kth-permutation/">kth Permutation</a></p>
<h2 id="saiftynet1">Saif Ahmed</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/saiftynet/perl/ch-1.pl">Saif Ahmed&rsquo;s solution</a> provides a flexible <code>kPermutation</code> sub that supports three different modes of operation:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;\nGetting all permutations\n&#34;</span>;
<span style="color:#66d9ef">print</span> join( <span style="color:#e6db74">&#34; &#34;</span>, @$_ ), <span style="color:#e6db74">&#34;\n&#34;</span> <span style="color:#66d9ef">foreach</span> kPermutation(<span style="color:#ae81ff">3</span>);
<span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;\nGetting kth permutation\n&#34;</span>;
<span style="color:#66d9ef">print</span> join( <span style="color:#e6db74">&#34; &#34;</span>, @$_ ), <span style="color:#e6db74">&#34;\n&#34;</span> <span style="color:#66d9ef">foreach</span> kPermutation( <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span> );
<span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;\nGetting selected permutations\n&#34;</span>;
<span style="color:#66d9ef">print</span> join( <span style="color:#e6db74">&#34; &#34;</span>, @$_ ), <span style="color:#e6db74">&#34;\n&#34;</span> <span style="color:#66d9ef">foreach</span> kPermutation( <span style="color:#ae81ff">3</span>, [ <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span> ] );
</code></pre></div><p>Here is the <code>kPermutation</code> sub, as well as the <code>permute</code> sub which handles the actual recursive permutation building:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">kPermutation</span> {
    <span style="color:#66d9ef">my</span> $n <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">our</span> $k    <span style="color:#f92672">=</span> shift <span style="color:#e6db74">//</span> <span style="color:#e6db74">&#34;all&#34;</span>;
    <span style="color:#66d9ef">our</span> @list <span style="color:#f92672">=</span> ();
    permute( [ <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> $n ], <span style="color:#ae81ff">0</span>, $n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> );

    <span style="color:#66d9ef">if</span> ( ref $k <span style="color:#f92672">eq</span> <span style="color:#e6db74">&#34;ARRAY&#34;</span> ) {
        @list <span style="color:#f92672">=</span> @list[@$k];
    }
    <span style="color:#66d9ef">return</span> @list;

    <span style="color:#75715e"># A recursive permutation function.</span>
    <span style="color:#75715e"># takes an array ref, start for swap and end of swap</span>
    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">permute</span> {
        <span style="color:#66d9ef">my</span> ( $str, $l, $r ) <span style="color:#f92672">=</span> @_;
        <span style="color:#66d9ef">my</span> @perm <span style="color:#f92672">=</span> @$str;    <span style="color:#75715e"># deref the passed array</span>
        <span style="color:#66d9ef">if</span> (    ( $l <span style="color:#f92672">==</span> $r )
            <span style="color:#f92672">and</span> ( ( ref $k ) <span style="color:#f92672">or</span> ( $k <span style="color:#f92672">eq</span> <span style="color:#e6db74">&#34;all&#34;</span> ) <span style="color:#f92672">or</span> ( <span style="color:#f92672">--</span>$k <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> ) ) )
        {
            push @list, [@perm];
        } <span style="color:#75715e"># base case, populates the entire list with permutations or just kth one</span>
        <span style="color:#66d9ef">else</span> {
            <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $idx ( $l <span style="color:#f92672">..</span> $r ) {
                ( $perm[$l], $perm[$idx] ) <span style="color:#f92672">=</span> ( $perm[$idx], $perm[$l] );  <span style="color:#75715e"># swap</span>
                permute( [@perm], $l <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, $r );    <span style="color:#75715e"># recurse</span>
                ( $perm[$l], $perm[$idx] ) <span style="color:#f92672">=</span>
                  ( $perm[$idx], $perm[$l] );      <span style="color:#75715e"># backtrack</span>
            }
        }
    }
}
</code></pre></div><h2 id="user-person1">User Person</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/user-person/perl/ch-1.pl">User Person&rsquo;s solution</a> uses <a href="https://metacpan.org/pod/List::Permutor"><code>List::Permutor</code></a> to get an iterator that they can trigger <code>$k</code> times to get the correct permutation. It works well, but it&rsquo;s worth pointing out that the solution generates sequences from <code>1..$n-1</code>, which might be initially confusing. Here is the code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">use</span> List::Permutor;

<span style="color:#66d9ef">my</span> @sequence <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> $n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
<span style="color:#66d9ef">my</span> $perm <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> List::Permutor @sequence;
<span style="color:#66d9ef">my</span> $kth <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
<span style="color:#66d9ef">my</span> $failure<span style="color:#f92672">++</span>;

LOOP:
<span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">my</span> @set <span style="color:#f92672">=</span> $perm<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">next</span>) {
    <span style="color:#66d9ef">if</span> ( $kth<span style="color:#f92672">++</span> <span style="color:#f92672">==</span> $k) {
        <span style="color:#66d9ef">print</span> @set, <span style="color:#e6db74">&#34;\n&#34;</span>;
        $failure<span style="color:#f92672">--</span>;
        <span style="color:#66d9ef">last</span> LOOP;
    }
}

<span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;There is no &#39;$k&#39;-th number in the &#39;$n sequence&#39;.\n&#34;</span> <span style="color:#66d9ef">if</span> $failure;
</code></pre></div><h2 id="wanderdoc1">Wanderdoc</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/wanderdoc/perl/ch-1.pl">Wanderdoc&rsquo;s solution</a> uses <a href="https://metacpan.org/pod/Algorithm::Combinatorics"><code>Algorithm::Combinatorics</code></a>&lsquo;s <code>permutations</code> in the iterative mode, to generate permutations:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">use</span> Algorithm::Combinatorics <span style="color:#e6db74">qw(permutations)</span>;

<span style="color:#66d9ef">my</span> $iter <span style="color:#f92672">=</span> permutations([<span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> $options{n}]);
<span style="color:#66d9ef">my</span> $counter <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">my</span> $c <span style="color:#f92672">=</span> $iter<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">next</span>) {

     $counter<span style="color:#f92672">++</span>;
     <span style="color:#66d9ef">if</span> ( $counter <span style="color:#f92672">==</span> $options{k} ) {
          <span style="color:#66d9ef">print</span> join(<span style="color:#e6db74">&#39; &#39;</span>, @$c), $/;
          <span style="color:#66d9ef">last</span>;
     }
}
<span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;Do not have so many permutations.\n&#34;</span> <span style="color:#66d9ef">if</span> $counter <span style="color:#f92672">&lt;</span> $options{k};
</code></pre></div><h2 id="yet-ebreo1">Yet Ebreo</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/yet-ebreo/perl/ch-1.pl">Yet Ebreo&rsquo;s solution</a> provides a recursive <code>generate</code>, which fills the global <code>@r</code> with permutations:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> @r;
<span style="color:#66d9ef">my</span> $n <span style="color:#f92672">=</span> $ARGV[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">||</span> <span style="color:#ae81ff">3</span>;
<span style="color:#66d9ef">my</span> $k <span style="color:#f92672">=</span> $ARGV[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">||</span> <span style="color:#ae81ff">4</span>;

<span style="color:#75715e"># Definitely not optimized, can only easily handle $n = 9,</span>
<span style="color:#75715e"># larger n should work too but would take some time</span>
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">generate</span> {
    <span style="color:#66d9ef">my</span> ($A,$k) <span style="color:#f92672">=</span> @_;
    <span style="color:#66d9ef">if</span> ($k <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
        push @r, join <span style="color:#e6db74">&#34;&#34;</span>, @{$A};
    } <span style="color:#66d9ef">else</span> {

        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$k<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
            generate(<span style="color:#f92672">\</span>@{$A},$k<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);

            <span style="color:#66d9ef">if</span> ($i <span style="color:#f92672">&lt;=</span> $k ) {
                <span style="color:#66d9ef">my</span> $h <span style="color:#f92672">=</span> $A<span style="color:#f92672">-&gt;</span>[$k<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
                <span style="color:#66d9ef">my</span> $j <span style="color:#f92672">=</span> $k % 2 ? <span style="color:#ae81ff">0</span>: $i;

                <span style="color:#75715e">#swap values</span>
                ($A<span style="color:#f92672">-&gt;</span>[$j],$A<span style="color:#f92672">-&gt;</span>[$k<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]) <span style="color:#f92672">=</span> ($A<span style="color:#f92672">-&gt;</span>[$k<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>],$A<span style="color:#f92672">-&gt;</span>[$j]);
            }
        }
    }
}
</code></pre></div><p>The results are then sorted, and the <code>$k</code>th permutation is printed:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> @x <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$n;
generate(<span style="color:#f92672">\</span>@x,$n);
@r <span style="color:#f92672">=</span> sort @r;
say $r[$k<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
</code></pre></div><hr>
<hr>
<h1 id="task2">Task #2 - Collatz Conjecture</h1>
<p>It is thought that the following sequence will always reach 1:</p>
<ul>
<li><code>$n = $n / 2</code> when <code>$n</code> is even</li>
<li><code>$n = 3*$n + 1</code> when <code>$n</code> is odd</li>
</ul>
<p>For example, if we start at 23, we get the following sequence:</p>
<p>23 → 70 → 35 → 106 → 53 → 160 → 80 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1</p>
<p>Write a function that finds the Collatz sequence for any positive integer. Notice how the sequence itself may go far above the original starting number.</p>
<p><strong>Extra Credit</strong></p>
<p>Have your script calculate the sequence length for all starting numbers up to 1000000 (1e6), and output the starting number and sequence length for the longest 20 sequences.</p>
<hr>
<p>Since I contributed this task, I can give you a glimpse into my thought process. First, you are asked to write a function to find a Collatz sequence for any positive integer. Supposing you named that function <code>collatz()</code>, you could solve the Extra Credit portion by simply looping from 1..1e6 and running <code>collatz()</code>. A decent brute force implementation will run in under a minute, but my hope was that some of you would strive for an even faster solution. I was not disappointed.</p>
<p>It was a real joy to see all of the solutions, and all of the interesting ways people reasoned their way through the extra credit part. Even those of you who did not do the extra credit part managed to provide differing implementations of the Collatz sequence (iterative, recursive, string return, array return, etc.)</p>
<h2 id="solution-types-1">Solution Types</h2>
<h3 id="1-no-extra-credit">1. No Extra Credit</h3>
<p>Several people opted out of doing the extra credit part, and just focused on providing a great Collatz sequence generator. For the most part, this looks like a <code>while</code> loop that either divides by two or multiplies by 3 and adds 1, but people differed on how they structured the conditional, and how they provided the result.</p>
<h3 id="2-extra-credit--brute-force">2. Extra Credit › Brute Force</h3>
<p>A simple way to solve the Extra Credit is to simply loop from 1..1e6, then loop to find the sequence (and hence its length), as in #1, above, and print the top 20. On my machine, with a decently-optimized <code>collatz</code>, it took 38 seconds to calculate the length of the first million Collatz sequences. Printing the top 20 by storing all one million lengths and <code>sort</code>ing that, adds 2-3 seconds to the run time.</p>
<h3 id="3-extra-credit--memoization">3. Extra Credit › Memoization</h3>
<p>The key optimization to make with the extra credit part is <a href="https://en.wikipedia.org/wiki/Memoization">memoization</a>. Since all Collatz sequences (except for Collatz(1) of course) contain other Collatz sequences, we can avoid the vast majority of the looping by simply keeping a record of the length of each sequence seen so far. Let&rsquo;s say we have <code>$collatz[$n]</code> mean &ldquo;The length of the Collatz sequence starting at <code>$n</code>&rdquo;. Then if we have already stored <code>$collatz[1..22]</code>, when we get to Collatz(23), this happens:</p>
<ul>
<li>Steps = 0, Collatz(23) › 23 odd, so Collatz(23) = 3*23 + 1 = 70</li>
<li>Steps = 1, Collatz(71) › 70 even, so Collatz(70) = 70 / 2 = 35</li>
<li>Steps = 2, Collatz(35) › 35 odd, so Collatz(35) = 3*35 + 1 = 106</li>
<li>Steps = 3, Collatz(106) › 106 even, so Collatz(106) = 106 / 2 = 53</li>
<li>Steps = 4, Collatz(53) › 53 odd, so Collatz(53) = 3*53 / 2 = 160</li>
<li>Steps = 5, Collatz(160) › 160 even, so Collatz(160) = 160 / 2 = 80</li>
<li>Steps = 6, Collatz(80) › 80 even, so Collatz(80) = 80 / 2 = 40</li>
<li>Steps = 7, Collatz(40) › 40 even, so Collatz(40) = 40 / 2 = 20</li>
<li>Steps = 8, <code>$collatz[20] = 8</code>. Steps = 8 + 7 = 15</li>
</ul>
<p>As soon as the sequence landed on a known number (20), we got a cache hit that saved us 8 out of 15 iterations. As the starting number increases, however, the average savings is much greater. By 100000, the savings is 85.6%, by 500000, it is 87.6%, and by one million, 88.2%.</p>
<p>Further optimizations (such as avoiding function call overhead) are possible, but memoization gets you most of the way there.</p>
<h3 id="4-optimizing-the-top-20">4. Optimizing the Top 20</h3>
<p>Once you get a well-optimized memoized solution, you would find that actually finding the top 20 becomes the bottleneck. For instance, in my solution, the million iterations took 1.5 seconds, but sorting the results took an extra 3 seconds! There are a few options for optimizing this. Choroba implemented his own heap, while I and a few others used the <a href="https://en.wikipedia.org/wiki/Insertion_sort">insertion algorithm</a>.</p>
<h2 id="stats-1">Stats</h2>
<ul>
<li>
<p>Number of submissions: <strong>25</strong></p>
</li>
<li>
<p>Total SLOC: <strong>1424</strong></p>
</li>
<li>
<p>Average SLOC: <strong>56</strong></p>
</li>
</ul>
<h2 id="alicia-bielsa2">Alicia Bielsa</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/alicia-bielsa/perl/ch-2.pl">Alicia Bielsa&rsquo;s solution</a> uses memoization, but stores every sequence (not just the length) in <code>%hSequences</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> %hSequences <span style="color:#f92672">=</span> ();
<span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i ( <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> <span style="color:#ae81ff">1000000</span> ) {
    <span style="color:#66d9ef">my</span> @aSequence <span style="color:#f92672">=</span> findCollatzSequence($i);
    push( @{ $hSequences{$i} }, @aSequence );
}
</code></pre></div><p>Here is the sequence generator. Note the <code>if exists</code> check, to use the cache:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">findCollatzSequence</span> {
    <span style="color:#66d9ef">my</span> $currentPoint <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">my</span> $endPoint     <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">my</span> @aSequence    <span style="color:#f92672">=</span> ();
    <span style="color:#66d9ef">while</span> ( $currentPoint <span style="color:#f92672">!=</span> $endPoint ) {
        <span style="color:#66d9ef">if</span> ( exists( $hSequences{$currentPoint} ) ) {
            push( @aSequence, @{ $hSequences{$currentPoint} } );
            <span style="color:#66d9ef">return</span> @aSequence;
        }
        push( @aSequence, $currentPoint );
        <span style="color:#66d9ef">if</span> ( $currentPoint % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> ) {
            $currentPoint <span style="color:#f92672">=</span> $currentPoint <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
        }
        <span style="color:#66d9ef">else</span> {
            $currentPoint <span style="color:#f92672">=</span> $currentPoint <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
        }
    }
    push( @aSequence, $endPoint );
    <span style="color:#66d9ef">return</span> @aSequence;
}
</code></pre></div><p>Finally, the sequence lengths are printed as follows:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> $count <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;
<span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $number (
    sort { scalar( @{ $hSequences{$b} } ) <span style="color:#e6db74">&lt;=&gt;</span> scalar( @{ $hSequences{$a} } ) }
    keys %hSequences )
{
    <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;$number\t&#34;</span> <span style="color:#f92672">.</span> scalar( @{ $hSequences{$number} } ) <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34;\n&#34;</span>;
    <span style="color:#66d9ef">last</span> <span style="color:#66d9ef">if</span> ( $count <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> );
    $count<span style="color:#f92672">--</span>;
}
</code></pre></div><p>This script ran my 2GB virtual machine out of memory. (131.4 million numbers with SV and other overhead adds up!)</p>
<h2 id="andrezgz2">Andrezgz</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/andrezgz/perl/ch-2.pl">Andrezgz&rsquo;s solution</a> first provides <code>collatz_seq</code> which returns a string of the Collatz sequence for the given number:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">collatz_seq</span> {
    <span style="color:#66d9ef">my</span> $n <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">my</span> $s;
    <span style="color:#66d9ef">while</span> ($n <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>) {
        $s <span style="color:#f92672">.=</span> $n <span style="color:#f92672">.</span> <span style="color:#e6db74">&#39; -&gt; &#39;</span>;
        <span style="color:#66d9ef">if</span> ($n % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) { $n <span style="color:#f92672">=</span> $n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;   }
        <span style="color:#66d9ef">else</span>             { $n <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span><span style="color:#f92672">*</span>$n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; }
    }
    <span style="color:#66d9ef">return</span> $s <span style="color:#f92672">.</span> <span style="color:#ae81ff">1</span>;
}
</code></pre></div><p>Andrezgz then tackles the extra credit challenge by looping in reverse from
1000000 to 1, to minimize the number of <code>sort</code>s required on the <code>@long_seq</code>
array:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">top_seq</span> {

    <span style="color:#66d9ef">my</span> @long_seq;
    <span style="color:#66d9ef">my</span> $min <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

    <span style="color:#66d9ef">for</span> (reverse <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> <span style="color:#ae81ff">1_000_000</span>) {
        <span style="color:#66d9ef">my</span> $l <span style="color:#f92672">=</span> seq_length($_);

        <span style="color:#75715e"># Add sequence</span>
        <span style="color:#66d9ef">next</span> <span style="color:#66d9ef">if</span> ($l <span style="color:#f92672">&lt;</span> $min);
        push @long_seq, {<span style="color:#e6db74">&#39;n&#39;</span> <span style="color:#f92672">=&gt;</span> $_, <span style="color:#e6db74">&#39;l&#39;</span> <span style="color:#f92672">=&gt;</span> $l};
        @long_seq <span style="color:#f92672">=</span> sort { $a<span style="color:#f92672">-&gt;</span>{l} <span style="color:#e6db74">&lt;=&gt;</span> $b<span style="color:#f92672">-&gt;</span>{l} } @long_seq;

        <span style="color:#75715e"># Adjust minimum sequence</span>
        <span style="color:#66d9ef">next</span> <span style="color:#66d9ef">if</span> (@long_seq <span style="color:#f92672">&lt;=</span> TOP_SEQ);
        shift @long_seq;
        $min <span style="color:#f92672">=</span> $long_seq[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">-&gt;</span>{l};

    }

    <span style="color:#66d9ef">print</span> $_<span style="color:#f92672">-&gt;</span>{n} <span style="color:#f92672">.</span> <span style="color:#e6db74">&#39;: &#39;</span> <span style="color:#f92672">.</span> $_<span style="color:#f92672">-&gt;</span>{l}<span style="color:#f92672">.</span>$/ <span style="color:#66d9ef">for</span> (reverse @long_seq);

    <span style="color:#66d9ef">return</span>;
}
</code></pre></div><p>The following <code>seq_length</code> sub calculates the sequence length for a given
starting number:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">seq_length</span> {
    <span style="color:#66d9ef">my</span> $n <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">my</span> $l <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">while</span> ($n <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>) {
        <span style="color:#f92672">++</span>$l;
        <span style="color:#66d9ef">if</span> ($n % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) { $n <span style="color:#f92672">=</span> $n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;   }
        <span style="color:#66d9ef">else</span>             { $n <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span><span style="color:#f92672">*</span>$n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; }
    }
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">++</span>$l;
}
</code></pre></div><h2 id="athanasius2">Athanasius</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/athanasius/perl/ch-2.pl">Athanasius&rsquo;s solution</a> uses <a href="https://metacpan.org/pod/List::Priority"><code>List::Priority</code></a> to maintain the top 20 list more efficiently. His script supports both single sequences, and the extra credit top 20. It also includes some timing code to display its own run time, which for me was 9.6 seconds.</p>
<p>Here is the main loop that handles the Top 20:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">find_longest_seqs</span> {
    <span style="color:#66d9ef">my</span> $longest_seqs <span style="color:#f92672">=</span> List::Priority<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">new</span>( capacity <span style="color:#f92672">=&gt;</span> $MAX_TERMS );
    $longest_seqs<span style="color:#f92672">-&gt;</span>insert( <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span> );

    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $start ( <span style="color:#ae81ff">2</span> <span style="color:#f92672">..</span> $MAX_N ) {
        <span style="color:#66d9ef">my</span> $terms <span style="color:#f92672">=</span> count_terms($start);
        $longest_seqs<span style="color:#f92672">-&gt;</span>insert( $terms, $start );
    }

    <span style="color:#66d9ef">my</span> @longest_seqs;

    <span style="color:#66d9ef">while</span> ( $longest_seqs<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> ) {
        <span style="color:#66d9ef">my</span> $seq_len <span style="color:#f92672">=</span> $longest_seqs<span style="color:#f92672">-&gt;</span>highest_priority;
        <span style="color:#66d9ef">my</span> $start   <span style="color:#f92672">=</span> $longest_seqs<span style="color:#f92672">-&gt;</span>pop;

        push @longest_seqs, [ $start, $seq_len ];
    }

    <span style="color:#66d9ef">return</span> <span style="color:#f92672">\</span>@longest_seqs;
}
</code></pre></div><p>The Collatz sequence lengths are memoized, recursively, in the following block:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">{
    <span style="color:#66d9ef">my</span> %chains;

    <span style="color:#66d9ef">BEGIN</span> {
        $chains{<span style="color:#ae81ff">1</span>} <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    }

    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">count_terms</span> {
        <span style="color:#66d9ef">my</span> ($n) <span style="color:#f92672">=</span> @_;

        <span style="color:#66d9ef">return</span> $chains{$n} <span style="color:#66d9ef">if</span> exists $chains{$n};

        <span style="color:#66d9ef">return</span> $chains{$n} <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> count_terms( $n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span> ) <span style="color:#66d9ef">unless</span> $n % 2;
        <span style="color:#66d9ef">return</span> $chains{$n} <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> count_terms( $n <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> );
    }
}
</code></pre></div><h2 id="cheok-yin-fung2">Cheok-Yin Fung</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/cheok-yin-fung/perl/ch-2.pl">Cheok-Yin Fung&rsquo;s solution</a>, when supplied instead with an integer on the commandline, calculates a single sequence with the following code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">if</span> ($ARGV[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">!=</span> undef ) {
    <span style="color:#66d9ef">my</span> $mazed <span style="color:#f92672">=</span> $ARGV[<span style="color:#ae81ff">0</span>];
    <span style="color:#66d9ef">print</span> $mazed, <span style="color:#e6db74">&#34; &#34;</span>;
    <span style="color:#66d9ef">while</span> ($mazed <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>) {
            <span style="color:#66d9ef">if</span> ($mazed % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
                $mazed <span style="color:#f92672">=</span> $mazed<span style="color:#f92672">*</span><span style="color:#ae81ff">3</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
            } <span style="color:#66d9ef">else</span> {
                $mazed <span style="color:#f92672">=</span> $mazed<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>;
            }
            <span style="color:#66d9ef">print</span> $mazed, <span style="color:#e6db74">&#34; &#34;</span>;
    }
} <span style="color:#66d9ef">else</span> {
</code></pre></div><p>The extra credit code is extensive, and contains a number of small optimizations, such as pre-seeding the sequence length table with powers of two, which are easy to calculate:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">foreach</span> (<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span><span style="color:#ae81ff">27</span>) {
    $seqlength[<span style="color:#ae81ff">2</span><span style="color:#f92672">**</span>$_] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">+</span>$_;
    $SeqlengthLargeInt{<span style="color:#ae81ff">2</span><span style="color:#f92672">**</span>$_} <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">+</span>$_;
}
</code></pre></div><p>By itself, this optimization would give a ~4.3% savings in the total sequence length for the first million starting integers. Once memoization is added, however, this savings would be greatly reduced.</p>
<p>Cheok Yin maintains two data structures: <code>@seqlen</code> maps array index to Collatz sequence length, and is used for smaller integers, under <code>$MAX_U</code>. <code>%SeqlengthLargeInt</code> performs a similar task for large integers. I assume Cheok Yin uses a hash after <code>$MAX_U</code> to save memory.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#75715e">#space allocation</span>
<span style="color:#66d9ef">my</span> @seqlength;
<span style="color:#66d9ef">my</span> %SeqlengthLargeInt <span style="color:#f92672">=</span> { <span style="color:#ae81ff">1</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">1</span> };

$seqlength[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</code></pre></div><p>The following sub takes a partial sequence and updates the <code>@seqlength</code> array:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">traceSmallint</span> {
    <span style="color:#66d9ef">my</span> @route <span style="color:#f92672">=</span> reverse @_;

    <span style="color:#66d9ef">my</span> $h <span style="color:#f92672">=</span> shift @route;
    <span style="color:#66d9ef">my</span> $ref;
    <span style="color:#66d9ef">foreach</span> $ref (@route) {
        $seqlength[$ref] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> $seqlength[$h];
        $h <span style="color:#f92672">=</span> $ref;
    }
    $SeqlengthLargeInt{ $route[<span style="color:#ae81ff">0</span>] } <span style="color:#f92672">=</span> $seqlength[ $route[<span style="color:#ae81ff">0</span>] ];
}
</code></pre></div><p>Lastly, here is the main code that calculates the Extra Credit sequences. Cheok Yin does not calculate the top twenty; instead, every sequence length is output to a million-line log file:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> $MAX_U <span style="color:#f92672">=</span> <span style="color:#ae81ff">333334</span>;

open LOG, <span style="color:#e6db74">&#34;&gt;&#34;</span>, <span style="color:#e6db74">&#34;ch-2_logfile&#34;</span>;
<span style="color:#66d9ef">foreach</span> ( $TARGET_BEGIN <span style="color:#f92672">..</span> $TARGET_END ) {
    <span style="color:#66d9ef">my</span> @temp  <span style="color:#f92672">=</span> ();
    <span style="color:#66d9ef">my</span> @tempB <span style="color:#f92672">=</span> ();
    push @temp, $_;
    <span style="color:#66d9ef">my</span> $mazed <span style="color:#f92672">=</span> $_;
    <span style="color:#66d9ef">while</span> (
        $mazed <span style="color:#f92672">&lt;</span> $MAX_U
        <span style="color:#f92672">and</span> <span style="color:#f92672">not</span>( defined( $SeqlengthLargeInt{$mazed} ) )

      )
    {
        <span style="color:#66d9ef">if</span> ( $mazed % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> ) {
            $mazed <span style="color:#f92672">=</span> $mazed <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
            push @temp, $mazed;
        }
        <span style="color:#66d9ef">else</span> {
            $mazed <span style="color:#f92672">=</span> $mazed <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
            push @temp, $mazed;
        }
    }
    <span style="color:#66d9ef">if</span> ( $mazed <span style="color:#f92672">&lt;</span> $MAX_U ) {
        traceSmallint(@temp);
    }
    <span style="color:#66d9ef">else</span> {
        push @tempB, $mazed;
        <span style="color:#66d9ef">while</span> ( <span style="color:#f92672">not</span>( defined( $SeqlengthLargeInt{$mazed} ) ) ) {
            <span style="color:#66d9ef">if</span> ( $mazed % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> ) {
                $mazed <span style="color:#f92672">=</span> $mazed <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
                push @tempB, $mazed;
            }
            <span style="color:#66d9ef">else</span> {
                $mazed <span style="color:#f92672">=</span> $mazed <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
                push @tempB, $mazed;
            }
        }
        $seqlength[$_] <span style="color:#f92672">=</span> $#tempB <span style="color:#f92672">+</span> $#temp <span style="color:#f92672">+</span> $SeqlengthLargeInt{$mazed};
    }

    <span style="color:#66d9ef">print</span> LOG $seqlength[$_], <span style="color:#e6db74">&#34;\n&#34;</span>;

}

close LOG;
</code></pre></div><p>Note the two distinct cases for large and small numbers. I would be curious to know how much of a difference this optimization made.</p>
<p>Cheok Yin&rsquo;s blog this week is another great story of the journey Cheok Yin went on in the completion of this task.</p>
<p><strong>Blog</strong> › <a href="http://blogs.perl.org/users/c_y_fung/2020/04/cys-take-on-pwc054.html">CY&rsquo;s take on PWC#054</a></p>
<h2 id="colin-crain2">Colin Crain</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/colin-crain/perl/ch-2.pl">Colin Crain&rsquo;s solution</a>, always with the excellent commentary, ponders the following:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#75715e">#         method: since the conjecture is that _all_ such sequences converge, it</span>
<span style="color:#75715e">#             seems safe to say that the it&#39;s been checked for a lot of numbers.</span>
</code></pre></div><p>Indeed, the Collatz sequence has been calculated for starting numbers exceeding 10<sup>17</sup>, and in fact may be even higher by now. The longest known sequence (that I could find reference to) is for the number 93,571,393,692,802,302, clocking in at 2091 steps, which was easy and fun to verify with <code>bigint</code>. It&rsquo;s a sure bet that anything smaller than that will eventually reach 1.</p>
<p>Here&rsquo;s Colin&rsquo;s <code>make_collatz_sequence</code>, which returns an array ref of the Collatz sequence for the given starting number:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">make_collatz_sequence</span> {
    <span style="color:#66d9ef">my</span> $prev <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">my</span> @seq <span style="color:#f92672">=</span> ($prev);
    <span style="color:#66d9ef">my</span> $next;

    <span style="color:#66d9ef">while</span> ($prev <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>) {
        $next <span style="color:#f92672">=</span> next_collatz($prev);
        push @seq, $next;
        $prev <span style="color:#f92672">=</span> $next;
    }

    <span style="color:#66d9ef">return</span> <span style="color:#f92672">\</span>@seq;
}

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">next_collatz</span> {
    $_[<span style="color:#ae81ff">0</span>] % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>  ?   $_[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>
                    :   <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> $_[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
}
</code></pre></div><p>For the Extra Credit portion, Colin gives us the following calling code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> $data <span style="color:#f92672">=</span> {  seq_lengths    <span style="color:#f92672">=&gt;</span> {},
              highest_number <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">0</span>,
              highest_value  <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">0</span>   };

get_collatz_metadata($data);

<span style="color:#75715e">## display length totals</span>
<span style="color:#66d9ef">my</span> $count;
<span style="color:#66d9ef">my</span> @sorted <span style="color:#f92672">=</span> sort { $data<span style="color:#f92672">-&gt;</span>{seq_lengths}<span style="color:#f92672">-&gt;</span>{$b} <span style="color:#e6db74">&lt;=&gt;</span> $data<span style="color:#f92672">-&gt;</span>{seq_lengths}<span style="color:#f92672">-&gt;</span>{$a} <span style="color:#f92672">||</span> $a <span style="color:#e6db74">&lt;=&gt;</span> $b } keys $data<span style="color:#f92672">-&gt;</span>{seq_lengths}<span style="color:#f92672">-&gt;</span>%<span style="color:#960050;background-color:#1e0010">*;</span>
say <span style="color:#e6db74">&#39;-&#39;</span> x <span style="color:#ae81ff">35</span>;
say <span style="color:#e6db74">&#39; count   number   sequence length&#39;</span>;
say <span style="color:#e6db74">&#39;-------+--------+------------------&#39;</span>;
printf <span style="color:#e6db74">&#34;  %2d     %6d %6d\n&#34;</span>, <span style="color:#f92672">++</span>$count, $_, $data<span style="color:#f92672">-&gt;</span>{seq_lengths}<span style="color:#f92672">-&gt;</span>{$_} <span style="color:#66d9ef">for</span> @sorted[<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">19</span>];

<span style="color:#75715e">## display max number found</span>
say <span style="color:#e6db74">&#39;-&#39;</span> x <span style="color:#ae81ff">35</span>;
say <span style="color:#e6db74">&#34;largest value found was &#34;</span>, $data<span style="color:#f92672">-&gt;</span>{highest_value};
say <span style="color:#e6db74">&#34;for number &#34;</span>, $data<span style="color:#f92672">-&gt;</span>{highest_number};
</code></pre></div><p>The <code>get_collatz_metadata</code> does the hard work of looping through the first million counting numbers, memoizing into <code>$data-&gt;{seq_lengths}</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">get_collatz_metadata</span> {
    <span style="color:#66d9ef">my</span> $data <span style="color:#f92672">=</span> shift;

    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $number (<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span><span style="color:#ae81ff">1000000</span>) {
        <span style="color:#66d9ef">my</span> $prev <span style="color:#f92672">=</span> $number;
        <span style="color:#66d9ef">my</span> $len  <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">my</span> $next;

        <span style="color:#66d9ef">while</span> ($prev <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>) {
            $next <span style="color:#f92672">=</span> $prev % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>  ?   $prev <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>
                                    :   <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> $prev <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
            $prev <span style="color:#f92672">=</span> $next;
            <span style="color:#66d9ef">if</span> ($next <span style="color:#f92672">&gt;</span> $data<span style="color:#f92672">-&gt;</span>{highest_value}) {
                $data<span style="color:#f92672">-&gt;</span>{highest_number} <span style="color:#f92672">=</span> $number;
                $data<span style="color:#f92672">-&gt;</span>{highest_value}  <span style="color:#f92672">=</span> $next;
            }
            $len<span style="color:#f92672">++</span>;
        }
        $data<span style="color:#f92672">-&gt;</span>{seq_lengths}<span style="color:#f92672">-&gt;</span>{$number} <span style="color:#f92672">=</span> $len;
    }
}
</code></pre></div><h2 id="cristian-heredia2">Cristina Heredia</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/cristian-heredia/perl/ch-2.pl">Cristina Heredia&rsquo;s solution</a> gives the option to find a single Collatz sequence, or solve the extra credit problem. Here is the recursive <code>findCollatz</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">findCollatz</span> {

    <span style="color:#66d9ef">if</span> ($number <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
        <span style="color:#66d9ef">if</span> ($option <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>){
            <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;The Collatz sequence for $origin is:\n$result\n&#34;</span>;
        }
        <span style="color:#66d9ef">else</span> {
            countResult();
        }
    }
    <span style="color:#66d9ef">elsif</span> ($number % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
        $number <span style="color:#f92672">=</span> $number <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
        $result <span style="color:#f92672">=</span> $result<span style="color:#f92672">.</span><span style="color:#e6db74">&#34; - $number&#34;</span>;
        findCollatz();
    }
    <span style="color:#66d9ef">else</span> {
        $number <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span><span style="color:#f92672">*</span>$number <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
        $result <span style="color:#f92672">=</span> $result<span style="color:#f92672">.</span><span style="color:#e6db74">&#34; - $number&#34;</span>;
        findCollatz();
    }
}
</code></pre></div><p>The <code>extraCredit</code> sub solves the extra credit part, by calling <code>findCollatz</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">extraCredit</span> {

    $sizes{<span style="color:#ae81ff">1</span>} <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">foreach</span> (<span style="color:#66d9ef">my</span> $i <span style="color:#f92672">=</span> $minimum; $i <span style="color:#f92672">&lt;=</span> $maximum; $i<span style="color:#f92672">++</span>) {
        $result <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;&#39;</span>;
        $number <span style="color:#f92672">=</span> $i;
        findCollatz();
        $sizes{$i} <span style="color:#f92672">=</span> $length;
    }

    sortHash();

}
</code></pre></div><p>Helper subs:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">countResult</span> {
    @array <span style="color:#f92672">=</span> split(<span style="color:#e6db74">&#39; - &#39;</span>, $result);
    $length <span style="color:#f92672">=</span> @array;
}

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">sortHash</span> {
    <span style="color:#66d9ef">my</span> $count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

    <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $key (sort { $sizes{$b} <span style="color:#e6db74">&lt;=&gt;</span> $sizes{$a} } keys %sizes) {
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;The starting number is: $key and the length is:$sizes{$key}\n&#34;</span>;
        $count<span style="color:#f92672">++</span>;
        <span style="color:#66d9ef">if</span> ($count <span style="color:#f92672">==</span> $numberToShow) {
            <span style="color:#66d9ef">last</span>;
        }
    }
}
</code></pre></div><h2 id="dave-jacoby2">Dave Jacoby</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/dave-jacoby/perl/ch-2.pl">Dave Jacoby&rsquo;s solution</a> solves the base task with the <code>collatz</code> recursive sub:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">use</span> feature <span style="color:#e6db74">qw{ postderef say signatures state switch }</span>;
<span style="color:#66d9ef">no</span> warnings <span style="color:#e6db74">qw{ experimental recursion }</span>;

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">collatz</span> ( $n ) {
    $n <span style="color:#f92672">=</span> int $n;
    croak <span style="color:#66d9ef">if</span> $n <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">my</span> @sec;
    <span style="color:#66d9ef">if</span> ( $n <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> ) {
        push @sec, <span style="color:#ae81ff">1</span>;
    }
    <span style="color:#66d9ef">elsif</span> ( $n % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> ) {    <span style="color:#75715e">#odd</span>
        <span style="color:#66d9ef">my</span> $o <span style="color:#f92672">=</span> ( <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> $n ) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
        push @sec, $n, collatz($o);
    }
    <span style="color:#66d9ef">elsif</span> ( $n % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> ) {    <span style="color:#75715e">#even</span>
        <span style="color:#66d9ef">my</span> $o <span style="color:#f92672">=</span> $n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
        push @sec, $n, collatz($o);
    }
    <span style="color:#66d9ef">return</span> wantarray ? @sec : <span style="color:#f92672">\</span>@sec;
}
</code></pre></div><p><strong>Blog</strong> › <a href="https://jacoby.github.io/2020/03/30/permutations-and-conjectures.html">Permutations and Conjectures</a></p>
<h2 id="duncan-c-white2">Duncan C. White</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/duncan-c-white/perl/ch-2.pl">Duncan C. White&rsquo;s solution</a> gives us a nice and concise <code>collatz</code> function:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">use</span> Function::Parameters;

fun collatz( $n ) {
    <span style="color:#66d9ef">my</span> @seq <span style="color:#f92672">=</span> ( $n );
    <span style="color:#66d9ef">while</span>( $n <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span> ) {
        <span style="color:#66d9ef">if</span>( $n%2<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span> ) { $n <span style="color:#f92672">=</span> $n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span> } <span style="color:#66d9ef">else</span> { $n <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span><span style="color:#f92672">*</span>$n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> }
        push @seq, $n;
    }
    <span style="color:#66d9ef">return</span> @seq;
}
</code></pre></div><p>Here is Duncan&rsquo;s extra credit code. Note the <code>-$n</code> in the loop is because his script will run <code>collatz</code> on a single integer if the argument (<code>$n</code>) is positive, or all integers <code>1..-$n</code> if <code>$n</code> is negative.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> @longest20;    <span style="color:#75715e"># array of [ len, sequence ]</span>

<span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $x (<span style="color:#ae81ff">1</span><span style="color:#f92672">..-</span>$n) {
    <span style="color:#66d9ef">my</span> @seq <span style="color:#f92672">=</span> collatz( $x );
    <span style="color:#66d9ef">my</span> $len <span style="color:#f92672">=</span> @seq;
    push @longest20, [ $len, @seq ];
    @longest20 <span style="color:#f92672">=</span> sort { $b<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] <span style="color:#e6db74">&lt;=&gt;</span> $a<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] } @longest20;
    $#longest20 <span style="color:#f92672">=</span> <span style="color:#ae81ff">19</span> <span style="color:#66d9ef">if</span> @longest20<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">20</span>;
    <span style="color:#75715e">#say &#34;x=$x longest: &#34;, join(&#39;,&#39;,@$_) for @longest20;</span>
}

say <span style="color:#e6db74">&#34;longest 20 collatz sequences:&#34;</span>;
<span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $longest (@longest20) {
    <span style="color:#66d9ef">my</span>( $len, @seq ) <span style="color:#f92672">=</span> @$longest;
    say <span style="color:#e6db74">&#34;len=$len: &#34;</span>, join(<span style="color:#e6db74">&#39;,&#39;</span>,@seq);
}
</code></pre></div><h2 id="e-choroba2">E. Choroba</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/e-choroba/perl/ch-2.pl">E. Choroba&rsquo;s solution</a> solves the base and extra credit, concisely:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">collatz</span> {
    <span style="color:#66d9ef">my</span> ($start) <span style="color:#f92672">=</span> @_;
    <span style="color:#66d9ef">my</span> @seq <span style="color:#f92672">=</span> $start;
    push @seq, ($seq[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> $seq[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)[$seq[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] % 2]
        <span style="color:#66d9ef">while</span> $seq[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">return</span> @seq
}

<span style="color:#66d9ef">my</span> @sizes;
push @sizes, [$_, scalar collatz($_)] <span style="color:#66d9ef">for</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> <span style="color:#ae81ff">1e6</span>;
say <span style="color:#e6db74">&#34;@$_&#34;</span> <span style="color:#66d9ef">for</span> (sort { $b<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>] <span style="color:#e6db74">&lt;=&gt;</span> $a<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>] } @sizes)[<span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> <span style="color:#ae81ff">19</span>];
</code></pre></div><p>It is relatively quick for a brute force implementation at ~58 seconds on my VM. Choroba mentions dynamic programming in his blog, but did not try it.</p>
<h3 id="second-solution-myheap">Second solution: <code>My::Heap</code></h3>
<p>Choroba also provided a <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/e-choroba/perl/ch-2b.pl">second solution</a> that includes a <code>My::Heap</code> class to maintain the top 20. He found that it was even slower:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> $h <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;My::Heap&#39;</span><span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">new</span>(<span style="color:#ae81ff">20</span>);

$h<span style="color:#f92672">-&gt;</span>add($_, scalar collatz($_)) <span style="color:#66d9ef">for</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> <span style="color:#ae81ff">1e6</span>;
</code></pre></div><p>Choroba&rsquo;s <code>add</code> method and its dependencies looks like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">add</span> {
    <span style="color:#66d9ef">my</span> ($self, $key, $value) <span style="color:#f92672">=</span> @_;
    push @{ $self<span style="color:#f92672">-&gt;</span>{heap} }, [$key, $value];
    $self<span style="color:#f92672">-&gt;</span>_up($#{ $self<span style="color:#f92672">-&gt;</span>{heap} });
    $self<span style="color:#f92672">-&gt;</span>extract_top <span style="color:#66d9ef">if</span> @{ $self<span style="color:#f92672">-&gt;</span>{heap} } <span style="color:#f92672">&gt;</span> $self<span style="color:#f92672">-&gt;</span>{max_size};
}

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">extract_top</span> {
    <span style="color:#66d9ef">my</span> ($self) <span style="color:#f92672">=</span> @_;
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">unless</span> @{ $self<span style="color:#f92672">-&gt;</span>{heap} };
    <span style="color:#66d9ef">my</span> $top <span style="color:#f92672">=</span> shift @{ $self<span style="color:#f92672">-&gt;</span>{heap} };
    unshift @{ $self<span style="color:#f92672">-&gt;</span>{heap} }, pop @{ $self<span style="color:#f92672">-&gt;</span>{heap} };
    $self<span style="color:#f92672">-&gt;</span>_down(<span style="color:#ae81ff">0</span>);
    <span style="color:#66d9ef">return</span> @$top
}

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">_up</span> {
    <span style="color:#66d9ef">my</span> ($self, $idx) <span style="color:#f92672">=</span> @_;
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">if</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">==</span> $idx;

    <span style="color:#66d9ef">my</span> $parent <span style="color:#f92672">=</span> int(($idx <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">if</span> ($self<span style="color:#f92672">-&gt;</span>{heap}[$idx][VALUE] <span style="color:#f92672">&lt;</span> $self<span style="color:#f92672">-&gt;</span>{heap}[$parent][VALUE]) {
        @{ $self<span style="color:#f92672">-&gt;</span>{heap} }[$idx, $parent]
            <span style="color:#f92672">=</span> @{ $self<span style="color:#f92672">-&gt;</span>{heap} }[$parent, $idx];
        $self<span style="color:#f92672">-&gt;</span>_up($parent);
    }
}

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">_down</span> {
    <span style="color:#66d9ef">my</span> ($self, $idx) <span style="color:#f92672">=</span> @_;
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">if</span> $idx <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>  <span style="color:#f92672">&gt;</span> $#{ $self<span style="color:#f92672">-&gt;</span>{heap} };

    <span style="color:#66d9ef">my</span> @ch_indices <span style="color:#f92672">=</span> ($idx <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, $idx <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>);
    $ch_indices[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> $ch_indices[<span style="color:#ae81ff">0</span>] <span style="color:#66d9ef">if</span> $idx <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">&gt;</span> $#{ $self<span style="color:#f92672">-&gt;</span>{heap} };
    <span style="color:#66d9ef">my</span> $ch_idx <span style="color:#f92672">=</span> $ch_indices[ $self<span style="color:#f92672">-&gt;</span>{heap}[$ch_indices[<span style="color:#ae81ff">0</span>] ][VALUE]
                              <span style="color:#f92672">&gt;</span> $self<span style="color:#f92672">-&gt;</span>{heap}[ $ch_indices[<span style="color:#ae81ff">1</span>] ][VALUE] ];
    <span style="color:#66d9ef">if</span> ($self<span style="color:#f92672">-&gt;</span>{heap}[$idx][VALUE] <span style="color:#f92672">&gt;</span> $self<span style="color:#f92672">-&gt;</span>{heap}[$ch_idx][VALUE]) {
        @{ $self<span style="color:#f92672">-&gt;</span>{heap} }[$idx, $ch_idx]
            <span style="color:#f92672">=</span> @{ $self<span style="color:#f92672">-&gt;</span>{heap} }[$ch_idx, $idx];
        $self<span style="color:#f92672">-&gt;</span>_down($ch_idx);
    }
}
</code></pre></div><p>Since <code>$h-&gt;add()</code> is called for every Collatz sequence, and <code>add</code> always triggers a rather complex sequence of method calls, array manipulation, and list creation, this imposes a significant penalty on each iteration. <code>add()</code> really only needs to be called when the top 20 would change.</p>
<p>Thus, the efficiency penalty could be mostly avoided with a bit of bookkeeping by remembering the minimum value in the heap and only calling <code>$h-&gt;add()</code> if it would fit in the heap (or calling a <code>find_min</code> method right at the top of add, if you want to stick with traditional heap semantics and encapsulation).</p>
<p>I still like this idea!</p>
<p><strong>Blog</strong> › <a href="http://blogs.perl.org/users/e_choroba/2020/04/perl-weekly-challenge-054-kth-permutation-sequence-collatz-conjecture.html">Kth Permutation Sequence + Collatz Conjecture</a></p>
<h2 id="jaldhar-h-vyas2">Jaldhar H. Vyas</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/jaldhar-h-vyas/perl/ch-2.pl">Jaldhar H. Vyas&rsquo;s solution</a> gives us the following iterative <code>collatzSequence</code> sub:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">collatzSequence</span> {
    <span style="color:#66d9ef">my</span> ($n) <span style="color:#f92672">=</span> @_;
    <span style="color:#66d9ef">my</span> @sequence <span style="color:#f92672">=</span> ($n);

    <span style="color:#66d9ef">while</span> ($n <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>) {
        $n <span style="color:#f92672">=</span> ($n % 2) ? (<span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> $n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) : ($n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>);
        push @sequence, $n;
    }

    <span style="color:#66d9ef">return</span> @sequence;
}
</code></pre></div><p>That sub is then used to find the 20 numbers with the longest sequences:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> $maxlength <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#66d9ef">my</span> @longest <span style="color:#f92672">=</span> ();

<span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $n (<span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> <span style="color:#ae81ff">1e6</span>) {
    <span style="color:#66d9ef">my</span> $length <span style="color:#f92672">=</span> scalar collatzSequence($n);

    <span style="color:#66d9ef">if</span> ($length <span style="color:#f92672">&gt;=</span> $maxlength) {
        $maxlength <span style="color:#f92672">=</span> (scalar @longest) ? $longest[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>] : $length;
        push @longest, [$n, $length];

        @longest <span style="color:#f92672">=</span> sort {$b<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>] <span style="color:#e6db74">&lt;=&gt;</span> $a<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>] } @longest;
        <span style="color:#66d9ef">if</span> (scalar @longest <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">20</span>) {
            pop @longest;
        }
    }
}

<span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $long (@longest) {
    say $long<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>], <span style="color:#e6db74">&#39;: &#39;</span>, $long<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>];
}
</code></pre></div><p>Jaldhar <code>sort</code>s the <code>@longest</code> array every time a sequence is inserted, and then <code>pop</code>s off an element if the array has more than 20 elements. Jaldhar&rsquo;s code runs in 50 seconds, which is not bad for a brute force implementation.</p>
<p><strong>Blog</strong> › <a href="https://www.braincells.com/perl/2020/04/perl_weekly_challenge_week_54.html">Jaldhar&rsquo;s Week #054 Blog</a></p>
<h2 id="javier-luque2">Javier Luque</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/javier-luque/perl/ch-2.pl">Javier Luque&rsquo;s solution</a> cuts to the chase with a <code>collatz</code> sub that returns the sequence length:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">collatz</span> {
    <span style="color:#66d9ef">my</span> $n <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">my</span> $length <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

    <span style="color:#66d9ef">while</span> ($n <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>) {
        $length<span style="color:#f92672">++</span>;

        $n <span style="color:#f92672">=</span> ($n % 2) ?
            <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> $n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>  :
            $n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
    }

    <span style="color:#66d9ef">return</span> $length;
}
</code></pre></div><p>He then takes a brute force approach to find the 22 (not 20) longest sequences, making his output at least 10% better, by my calculation!</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> %lengths;
<span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i (<span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> <span style="color:#ae81ff">1_000_000</span>) {
    <span style="color:#66d9ef">my</span> $length <span style="color:#f92672">=</span> collatz($i);
    $lengths{$i} <span style="color:#f92672">=</span> $length
        <span style="color:#66d9ef">if</span> ($length <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">440</span>);
}

<span style="color:#75715e"># Grab the 22 longest numbers</span>
<span style="color:#66d9ef">my</span> @keys <span style="color:#f92672">=</span> (
    sort {
        $lengths{$b} <span style="color:#e6db74">&lt;=&gt;</span> $lengths{$a}
    } keys %lengths
)[<span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> <span style="color:#ae81ff">21</span>] ;

<span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i ( @keys ) {
    say <span style="color:#e6db74">&#34;$i : Length &#34;</span> <span style="color:#f92672">.</span> $lengths{$i};
}
</code></pre></div><p>Javier&rsquo;s code runs in 37 seconds, which is good for brute force solution.</p>
<p><strong>Blog</strong> › <a href="https://perlchallenges.wordpress.com/2020/03/30/perl-weekly-challenge-054/">054 – Perl Weekly Challenge</a></p>
<h2 id="laurent-rosenfeld2">Laurent Rosenfeld</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/laurent-rosenfeld/perl/ch-2.pl">Laurent Rosenfeld&rsquo;s solution</a> uses memoization, but stores the entire sequence, not just the length, so it unfortunately ran my 2GB sandbox VM out of memory after 27 seconds.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">use</span> constant MAX <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">300000</span>;

<span style="color:#66d9ef">my</span> %cache;

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">collatz_seq</span> {
    <span style="color:#66d9ef">my</span> $input <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">my</span> $n <span style="color:#f92672">=</span> $input;
    <span style="color:#66d9ef">my</span> @result;
    <span style="color:#66d9ef">while</span> ($n <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>) {
        <span style="color:#66d9ef">if</span> (exists $cache{$n}) {
            push @result, @{$cache{$n}};
            <span style="color:#66d9ef">last</span>;
        } <span style="color:#66d9ef">else</span> {
            <span style="color:#66d9ef">my</span> $new_n <span style="color:#f92672">=</span> $n % 2 ? <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> $n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> : $n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
            push @result, $new_n;
            $cache{$n} <span style="color:#f92672">=</span> [$new_n, @{$cache{$new_n}}]
                <span style="color:#66d9ef">if</span> defined ($cache{$new_n}) <span style="color:#f92672">and</span> $n <span style="color:#f92672">&lt;</span> MAX;
            $n <span style="color:#f92672">=</span> $new_n;
        }
    }
    $cache{$input} <span style="color:#f92672">=</span> [@result] <span style="color:#66d9ef">if</span> $n <span style="color:#f92672">&lt;</span> MAX;
    <span style="color:#66d9ef">return</span> @result;
}

<span style="color:#66d9ef">my</span> @long_seqs;
<span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $num (<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span><span style="color:#ae81ff">1000000</span>) {
    <span style="color:#66d9ef">my</span> @seq <span style="color:#f92672">=</span> ($num, collatz_seq $num);
    push @long_seqs, [ $num, scalar @seq] <span style="color:#66d9ef">if</span> scalar @seq <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">400</span>;
}

@long_seqs <span style="color:#f92672">=</span> sort { $b<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>] <span style="color:#e6db74">&lt;=&gt;</span> $a<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>]} @long_seqs;
say  <span style="color:#e6db74">&#34;$_-&gt;[0]: $_-&gt;[1]&#34;</span> <span style="color:#66d9ef">for</span> @long_seqs[<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">19</span>];
</code></pre></div><p><strong>Blog</strong> › <a href="http://blogs.perl.org/users/laurent_r/2020/04/perl-weekly-challenge-54-k-th-permutation-sequence-and-the-collatz-conjecture.html">k-th Permutation Sequence and the Collatz Conjecture</a></p>
<h2 id="lubos-kolouch2">Lubos Kolouch</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/lubos-kolouch/perl/ch-2.pl">Lubos Kolouch&rsquo;s solution</a> revolves around the <code>get_sequence_length</code> sub:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> %length_cache;

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">get_next_sequence</span> {
    <span style="color:#66d9ef">my</span> $seq_pos <span style="color:#f92672">=</span> shift;

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">if</span> $seq_pos <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> $seq_pos <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">if</span> $seq_pos % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">return</span> int( $seq_pos <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span> );
}

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">get_sequence_length</span> {
    <span style="color:#66d9ef">my</span> $seq_pos <span style="color:#f92672">=</span> shift;

    <span style="color:#66d9ef">if</span> ($seq_pos <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
        $length_cache{<span style="color:#ae81ff">1</span>} <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
    }

    <span style="color:#66d9ef">my</span> $seq_length;
    <span style="color:#66d9ef">my</span> $cur_pos <span style="color:#f92672">=</span> $seq_pos;

    <span style="color:#66d9ef">while</span> ( $cur_pos <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">1</span> ) {
        <span style="color:#66d9ef">if</span> ( $length_cache{$cur_pos} ) {
            <span style="color:#75715e"># If we have already the length cached, return it</span>
            $seq_length <span style="color:#f92672">+=</span> $length_cache{$cur_pos};
            <span style="color:#66d9ef">last</span>;
        }
        <span style="color:#75715e"># otherwise increse the length and move to next step</span>
        $seq_length<span style="color:#f92672">++</span>;
        $cur_pos <span style="color:#f92672">=</span> get_next_sequence($cur_pos);
    }
    $length_cache{$seq_pos} <span style="color:#f92672">=</span> $seq_length;

    <span style="color:#66d9ef">return</span> $seq_length;
}
</code></pre></div><p>The first 20 results from <code>%length_cache</code> are then sorted and displayed:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> $count;
<span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $name (sort { $length_cache{$b} <span style="color:#e6db74">&lt;=&gt;</span> $length_cache{$a} } keys %length_cache) {
    printf <span style="color:#e6db74">&#34;%-8s %s\n&#34;</span>, $name, $length_cache{$name};
    $count<span style="color:#f92672">++</span>;
    <span style="color:#66d9ef">last</span> <span style="color:#66d9ef">if</span> $count <span style="color:#f92672">==</span> <span style="color:#ae81ff">20</span>;
}
</code></pre></div><p>Lubos&rsquo;s code runs in 9.2 seconds, thanks to the memoization. It&rsquo;s worth noting that the <code>sort</code> at the end takes about 3 seconds by itself, making it a candidate for optimization if more performance is needed.</p>
<h2 id="markus-holzer2">Markus Holzer</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/markus-holzer/perl/ch-2.pl">Markus Holzer&rsquo;s solution</a> also clocks in at 9.2 seconds, thanks to a similar algorithm:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> %result <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">1</span>);

<span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $n ( <span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$N ) {
    <span style="color:#66d9ef">my</span> $current <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">my</span> $next    <span style="color:#f92672">=</span> $n;

    <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>) {
        <span style="color:#75715e"># Dynamic programming:</span>
        <span style="color:#75715e"># see what you have computed so far, so you</span>
        <span style="color:#75715e"># don&#39;t have to compute it again</span>
        $result{ $n } <span style="color:#f92672">=</span> $result{ $next } <span style="color:#f92672">and</span> <span style="color:#66d9ef">last</span>
            <span style="color:#66d9ef">if</span> $result{ $next };

        $next <span style="color:#f92672">=</span> $next % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> ? $next <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span> : $next <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
        $current<span style="color:#f92672">++</span>;
    }

    $result{ $n } <span style="color:#f92672">+=</span> $current;
}
</code></pre></div><p>Results sorting and printing:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;n: $_, length: &#34;</span>, $result{ $_ }, <span style="color:#e6db74">&#34;\n&#34;</span> <span style="color:#66d9ef">for</span>
    (sort { $result{ $b } <span style="color:#e6db74">&lt;=&gt;</span> $result{ $a } } keys %result)[<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">19</span>]
;
</code></pre></div><h2 id="mohammad-anwar2">Mohammad S Anwar</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/mohammad-anwar/perl/ch-2.pl">Mohammad S Anwar&rsquo;s solution</a> finds the <code>@collatz</code> sequence for a starting integer as follows:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> @collatz <span style="color:#f92672">=</span> ($n);
<span style="color:#66d9ef">while</span> ($n <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>) {
    $n <span style="color:#f92672">=</span> ($n % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) ? ($n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>) : ((<span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> $n) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
    push @collatz, $n;
}

<span style="color:#66d9ef">print</span> sprintf(<span style="color:#e6db74">&#34;%s\n&#34;</span>, join <span style="color:#e6db74">&#34; -&gt; &#34;</span>, @collatz);
</code></pre></div><p>In his blog, Mohammad mentions there is &ldquo;hardly anything to talk about in this solution.&rdquo; I suppose I&rsquo;ll have to come up with a more difficult challenge next time! :-)</p>
<p><strong>Blog</strong> › <a href="https://perlweeklychallenge.org/blog/weekly-challenge-054">BLOG: The Weekly Challenge #054</a></p>
<h2 id="peter-meszaros2">Peter Meszaros</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/peter-meszaros/perl/ch-2.pl">Peter Meszaros&rsquo;s solution</a> gives us an iterative <code>collatz</code> sub first:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">collatz</span> {
    <span style="color:#66d9ef">my</span> $n <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">my</span> @r <span style="color:#f92672">=</span> $n;
    <span style="color:#66d9ef">while</span> ($n <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>) {
        $n <span style="color:#f92672">=</span> ($n % 2) ? ($n <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) : (int($n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>));
        push @r, $n;
    }
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">\</span>@r;
}
</code></pre></div><p>That <code>collatz</code> sub is then used to help find the sequence lengths for the first million starting integers, as follows:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> @n <span style="color:#f92672">=</span> @ARGV ? @ARGV : <span style="color:#ae81ff">1</span><span style="color:#f92672">..</span><span style="color:#ae81ff">1_000_000</span>;

<span style="color:#66d9ef">my</span> %res;
<span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i (@n) {
    <span style="color:#66d9ef">my</span> $c <span style="color:#f92672">=</span> collatz($i);
    $res{$i} <span style="color:#f92672">=</span> {
        num <span style="color:#f92672">=&gt;</span> scalar @$c,
        max <span style="color:#f92672">=&gt;</span> max(@$c),
    };
}
</code></pre></div><p>Finally, the results are sorted and printed:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> @ores <span style="color:#f92672">=</span> sort { $res{$b}<span style="color:#f92672">-&gt;</span>{num} <span style="color:#e6db74">&lt;=&gt;</span> $res{$a}<span style="color:#f92672">-&gt;</span>{num} } keys %res;
<span style="color:#66d9ef">my</span> $e <span style="color:#f92672">=</span> $#ores;

<span style="color:#66d9ef">my</span> $j;
<span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i (@ores[<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>(<span style="color:#ae81ff">19</span>, $e)[<span style="color:#ae81ff">19</span> <span style="color:#f92672">&gt;</span> $e]]) {
    printf <span style="color:#e6db74">&#34;%2d %6d length: %6d max: %12d\n&#34;</span>, <span style="color:#f92672">++</span>$j, $i, $res{$i}<span style="color:#f92672">-&gt;</span>{num}, $res{$i}<span style="color:#f92672">-&gt;</span>{max};
}
</code></pre></div><p>Peter&rsquo;s code runs in just over a minute on my VM, and, interestingly, also prints the maximum value that each sequence reaches. While 837799 has the longest sequence at 525 steps, it only reaches a maximum of 2974984576, putting it in 6th place overall. 1st place goes to 886953, which reaches a whopping 52483285312 before going all the way back down to 1.</p>
<h2 id="roger-bell-west2">Roger Bell West</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/roger-bell-west/perl/ch-2.pl">Roger Bell West&rsquo;s solution</a> is a clean, no-frills Collatz sequence generator:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">use</span> integer;

<span style="color:#66d9ef">while</span> ( <span style="color:#66d9ef">my</span> $n <span style="color:#f92672">=</span> shift @ARGV ) {
    <span style="color:#66d9ef">my</span> @k <span style="color:#f92672">=</span> ($n);
    <span style="color:#66d9ef">while</span> ( $n <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span> ) {
        <span style="color:#66d9ef">if</span> ( $n % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> ) {
            $n <span style="color:#f92672">/=</span> <span style="color:#ae81ff">2</span>;
        }
        <span style="color:#66d9ef">else</span> {
            $n <span style="color:#f92672">*=</span> <span style="color:#ae81ff">3</span>;
            $n<span style="color:#f92672">++</span>;
        }
        push @k, $n;
    }
    <span style="color:#66d9ef">print</span> join( <span style="color:#e6db74">&#39;, &#39;</span>, @k ), <span style="color:#e6db74">&#34;\n&#34;</span>;
}
</code></pre></div><h3 id="extra-credit-solution">Extra Credit Solution</h3>
<p>Roger provided a <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/roger-bell-west/perl/ch-2a.pl">second solution</a> that tackles the extra credit part, using memoization:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> %l;
<span style="color:#66d9ef">my</span> %s;

$l{<span style="color:#ae81ff">1</span>} <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;

<span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $n ( <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> <span style="color:#ae81ff">1e6</span> ) {
    <span style="color:#66d9ef">my</span> $k  <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">my</span> $na <span style="color:#f92672">=</span> $n;
    <span style="color:#66d9ef">while</span> ( <span style="color:#f92672">!</span>exists $l{$na} ) {
        <span style="color:#66d9ef">if</span> ( $na % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> ) {
            $na <span style="color:#f92672">/=</span> <span style="color:#ae81ff">2</span>;
        }
        <span style="color:#66d9ef">else</span> {
            $na <span style="color:#f92672">*=</span> <span style="color:#ae81ff">3</span>;
            $na<span style="color:#f92672">++</span>;
        }
        $k<span style="color:#f92672">++</span>;
    }
    $l{$n} <span style="color:#f92672">=</span> $k <span style="color:#f92672">+</span> $l{$na};
    push @{ $s{ $l{$n} } }, $n;
}
</code></pre></div><p>The results (<code>%s</code>) are then sorted and the top 20 printed:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> $k <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;
<span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $c ( sort { $b <span style="color:#e6db74">&lt;=&gt;</span> $a } keys %s ) {
    <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;$c: &#34;</span> <span style="color:#f92672">.</span> join( <span style="color:#e6db74">&#39;, &#39;</span>, sort @{ $s{$c} } ), <span style="color:#e6db74">&#34;\n&#34;</span>;
    $k <span style="color:#f92672">-=</span> scalar @{ $s{$c} };
    <span style="color:#66d9ef">if</span> ( $k <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span> ) {
        <span style="color:#66d9ef">last</span>;
    }
}
</code></pre></div><h2 id="ruben-westerberg2">Ruben Westerberg</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/ruben-westerberg/perl/ch-2.pl">Ruben Westerberg&rsquo;s solution</a> includes the following recursive <code>collaz</code> sub:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">collaz</span> {
    <span style="color:#66d9ef">my</span> ($seq)<span style="color:#f92672">=</span>@_;
    given ($seq<span style="color:#f92672">-&gt;</span>[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]) {
        when ($_%2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
            push @$seq, $_<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>;
        }
        default {
            push @$seq, <span style="color:#ae81ff">3</span><span style="color:#f92672">*</span>$_<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
        }
    }
    <span style="color:#f92672">&amp;</span>collaz <span style="color:#66d9ef">unless</span> $seq<span style="color:#f92672">-&gt;</span>[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">==</span><span style="color:#ae81ff">1</span>;
    $seq;
}
</code></pre></div><p>That sub is then used <code>$ARGV[0]</code> times to find the sequence lengths for the entire integer range:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> $max<span style="color:#f92672">=</span>$ARGV[<span style="color:#ae81ff">0</span>]<span style="color:#e6db74">//</span><span style="color:#ae81ff">23</span>;         <span style="color:#75715e">#sane default without cmd line args</span>
<span style="color:#66d9ef">my</span> @seqs<span style="color:#f92672">=</span>( (<span style="color:#f92672">[]</span>) x <span style="color:#ae81ff">20</span>);        <span style="color:#75715e">#Initalise the largest 20 sequences found</span>

<span style="color:#66d9ef">for</span> ( <span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$max) {
    <span style="color:#66d9ef">my</span> $s<span style="color:#f92672">=</span>collaz([int($_)]);
    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>@seqs<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
        <span style="color:#66d9ef">if</span> (@$s  <span style="color:#f92672">&gt;</span> @{$seqs[$i]}) {
            pop @seqs <span style="color:#66d9ef">unless</span> @seqs <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">20</span>;
            splice @seqs,$i,<span style="color:#ae81ff">0</span>,$s;
            <span style="color:#66d9ef">last</span>;
        }
    }
};

say <span style="color:#e6db74">&#34;Top 20 Collaz Sequence lengths for starting numbers 1..$max&#34;</span>;
<span style="color:#66d9ef">for</span>(grep { @$_ <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>} @seqs) {
    printf <span style="color:#e6db74">&#34;Starting Number: %10d Sequence Length: %d\n&#34;</span>, $_<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>],scalar @$_;
}
</code></pre></div><p>Ruben&rsquo;s code runs in about 1m45s on my VM, which is reasonable for a recursive brute force approach that works with full sequences (rather than lengths only).</p>
<h2 id="ryan-thompson2">Ryan Thompson</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/ryan-thompson/perl/ch-2.pl">My solution</a> uses memoization, and an O(n) insertion into the <code>@top</code> array of top 20 sequences. A few variables are required:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> @seqlen <span style="color:#f92672">=</span> (<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>);    <span style="color:#75715e"># Memoize sequence length</span>
<span style="color:#66d9ef">my</span> $top    <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;        <span style="color:#75715e"># Report this many of the top sequences</span>
<span style="color:#66d9ef">my</span> @top    <span style="color:#f92672">=</span> [ <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> ]; <span style="color:#75715e"># Top $top sequences</span>
<span style="color:#66d9ef">my</span> $upper  <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e6</span>;       <span style="color:#75715e"># Upper limit starting term</span>
<span style="color:#66d9ef">my</span> $mintop <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;         <span style="color:#75715e"># Lowest value in @top</span>
</code></pre></div><p>Here is the main array:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">my</span> $start <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>; $start <span style="color:#f92672">&lt;</span> $upper; $start <span style="color:#f92672">+=</span> <span style="color:#ae81ff">2</span>) {
    <span style="color:#66d9ef">my</span> ($n, $len) <span style="color:#f92672">=</span> ($start, <span style="color:#ae81ff">0</span>);
    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span> defined $seqlen[$n]) {
        $len <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> $n % 2;
        $n <span style="color:#f92672">=</span> $n % 2 ? (<span style="color:#ae81ff">3</span><span style="color:#f92672">*</span>$n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)<span style="color:#e6db74">/2 : $n /</span> <span style="color:#ae81ff">2</span>;
    }

    $len <span style="color:#f92672">+=</span> $seqlen[$n];
    $seqlen[$start] <span style="color:#f92672">=</span> $len <span style="color:#66d9ef">if</span> $start <span style="color:#f92672">&lt;</span> $upper <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>; <span style="color:#75715e"># Cache</span>

    top($start <span style="color:#f92672">=&gt;</span> $len)            <span style="color:#66d9ef">if</span> $len <span style="color:#f92672">&gt;</span> $mintop  <span style="color:#f92672">and</span>     $start <span style="color:#f92672">&lt;=</span> $upper;
    top($n <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">=&gt;</span> $seqlen[$n] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">if</span>   $n <span style="color:#f92672">&lt;</span> $upper<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">and</span> $seqlen[$n] <span style="color:#f92672">&gt;</span> $mintop;
}
</code></pre></div><p>There are a couple of other minor optimizations, here: first, note that instead of doing <code>3*$n + 1</code> on odd numbers, I do <code>(3*$n + 1)/2</code>, and I add 2 to <code>$len</code> for odd numbers, which bypasses some iteration while keeping the sequence length correctly tallied.</p>
<p>I also call another sub, <code>top</code> to handle inserts to <code>@top</code> instead of just <code>push</code>ing and <code>sort</code>ing later. This saved a few seconds (which, in my case, was most of the execution time):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#75715e"># Sorted insert [ $n, $len ] to @top, keep @top to $top length</span>
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">top</span> {
    <span style="color:#66d9ef">my</span> ($n, $len) <span style="color:#f92672">=</span> @_;

    <span style="color:#66d9ef">my</span> $idx <span style="color:#f92672">=</span> first { $top[$_][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&lt;</span> $len } <span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$#top;
    splice @top, $idx, <span style="color:#ae81ff">0</span>, [ $n, $len ];

    pop @top <span style="color:#66d9ef">if</span> @top <span style="color:#f92672">&gt;</span> $top;
    $mintop <span style="color:#f92672">=</span> $top[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>];
}
</code></pre></div><p>The execution time on my VM is 1.7 seconds.</p>
<p><strong>Blog</strong> › <a href="http://www.ry.ca/2020/04/collatz-conjecture/">Collatz Conjecture</a></p>
<h2 id="saiftynet2">Saif Ahmed</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/saiftynet/perl/ch-2.pl">Saif Ahmed&rsquo;s solution</a> gives us the following curious Collatz sub:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">Collatz</span> {
    <span style="color:#66d9ef">my</span> $n <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">my</span> @sequence;
    <span style="color:#66d9ef">while</span> ( $n <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span> ) {
        push @sequence, $n;
        $n <span style="color:#f92672">=</span> $n % 2 ? <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> $n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> : $n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;    <span style="color:#75715e"># comment this line and uncomment the next two</span>
                                              <span style="color:#75715e"># to enable caching.  On my system, caching takes</span>
                                              <span style="color:#75715e"># 50% longer</span>
            <span style="color:#75715e"># $next{$n} = $n %2 ? 3*$n + 1: $n / 2  unless defined $next{$n};;</span>
            <span style="color:#75715e"># $n=$next{$n};</span>
    }
    <span style="color:#66d9ef">return</span> @sequence, <span style="color:#ae81ff">1</span>;
}
</code></pre></div><p>The comment about caching taking 50% longer is unexpected, given what we already know about memoization in this task. The script does indeed take longer to run with the caching lines enabled. Can you see why?</p>
<p>Saif is only caching the next number in the sequence. As a result, this code essentially just adds a hash lookup to the existing code, and that&rsquo;s why it&rsquo;s slow. Caching the sequence length would result in large savings.</p>
<p>Here is the top 20 code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> %next;    <span style="color:#75715e"># cache of next numbers in the Collatz sequence;</span>
             <span style="color:#75715e"># helps if look up quicker than the math</span>

<span style="color:#66d9ef">print</span> join( <span style="color:#e6db74">&#34;-&gt;&#34;</span>, Collatz(<span style="color:#ae81ff">837799</span>) ), <span style="color:#e6db74">&#34;\n\n\n&#34;</span>;

top20Collatz(<span style="color:#ae81ff">1000000</span>);

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">top20Collatz</span> {    <span style="color:#75715e"># this uses pop instead of the usual &#34;shift&#34;</span>
    <span style="color:#66d9ef">my</span> $end   <span style="color:#f92672">=</span> pop;        <span style="color:#75715e"># if one parameter is supplied it is used as the end</span>
    <span style="color:#66d9ef">my</span> $start <span style="color:#f92672">=</span> pop <span style="color:#e6db74">//</span> <span style="color:#ae81ff">1</span>;   <span style="color:#75715e"># if two are supplied, then they are start and end</span>
    <span style="color:#66d9ef">my</span> @top20 <span style="color:#f92672">=</span> ();
    <span style="color:#66d9ef">my</span> $stopwatch <span style="color:#f92672">=</span> time();
    <span style="color:#66d9ef">for</span> ( $start <span style="color:#f92672">..</span> $end ) {
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;Calculating $_ \r&#34;</span>;    <span style="color:#75715e"># takes some time to work out 1000_000</span>
                                      <span style="color:#75715e"># gives visual feedback oc activity</span>
        <span style="color:#66d9ef">my</span> @seq <span style="color:#f92672">=</span> Collatz($_);        <span style="color:#75715e"># get the Collatz sequence</span>
            <span style="color:#75715e"># perl handily uses size of array if array is used in scalar context</span>
        <span style="color:#66d9ef">if</span> ( ( @top20 <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">20</span> ) <span style="color:#f92672">or</span> ( @seq <span style="color:#f92672">&gt;</span> @{ $top20[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] } ) )
        {    <span style="color:#75715e"># will end in top 20</span>
            unshift @top20, [@seq];    <span style="color:#75715e"># store the sequence</span>
            @top20 <span style="color:#f92672">=</span> sort { @$b <span style="color:#e6db74">&lt;=&gt;</span> @$a } @top20;    <span style="color:#75715e"># resort (reverse</span>
            pop @top20 <span style="color:#66d9ef">if</span> @top20 <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">20</span>;               <span style="color:#75715e"># remove any surplus</span>
        }
    }
    $stopwatch <span style="color:#f92672">-=</span> time();

    <span style="color:#75715e">#  section that displays results</span>
    <span style="color:#66d9ef">my</span> $count <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;Top 20 longest Collatz Sequences between $start and $end\n&#34;</span>;
    <span style="color:#66d9ef">foreach</span> (@top20) {
        printf <span style="color:#e6db74">&#34;Rank: %3d  Number: %8d  Sequence Size: %4d\n&#34;</span>, $count<span style="color:#f92672">++</span>,
          $$_[<span style="color:#ae81ff">0</span>],, scalar @$_;
    }
    <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;takes &#34;</span> <span style="color:#f92672">.</span> <span style="color:#f92672">-</span>$stopwatch <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34; seconds&#34;</span>;
}
</code></pre></div><h2 id="shahed-nooshmand2">Shahed Nooshmand</h2>
<p>Shahed submitted a Raku solution last week, but this is their first time submitting a Perl solution, meaning it&rsquo;s my first chance to welcome them to the Challenge. Welcome!</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/shahed-nooshmand/perl/ch-2.pl">Shahed Nooshmand&rsquo;s solution</a> is impressively concise for an extra credit solution:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> %hail <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">1</span>);

<span style="color:#66d9ef">for</span> (<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span><span style="color:#ae81ff">1e6</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
    <span style="color:#66d9ef">my</span> $n <span style="color:#f92672">=</span> $_;
    <span style="color:#66d9ef">my</span> $i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">until</span> (exists $hail{$n}) {
        $n <span style="color:#f92672">=</span> $n % 2 ? $n <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> : $n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
        $i<span style="color:#f92672">++</span>
    }
    $hail{$_} <span style="color:#f92672">=</span> $i <span style="color:#f92672">+</span> $hail{$n}
}

<span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;$_    $hail{$_}\n&#34;</span> <span style="color:#66d9ef">for</span> (sort { $hail{$b} <span style="color:#e6db74">&lt;=&gt;</span> $hail{$a} } keys %hail)[<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">19</span>]
</code></pre></div><p>The Collatz sequence is sometimes called the hailstone sequence, which is why you see the alternative symbol names, here. This code runs in 9.5 seconds, which is about average for a memoized solution.</p>
<p>It&rsquo;s really great to have another blogger participating in the challenge.</p>
<p><strong>Blog</strong> › <a href="https://rafraichisso.ir/2020/04/03/pwc-54">Perl Weekly Challenge: week 54</a></p>
<h2 id="ulrich-rieke2">Ulrich Rieke</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/ulrich-rieke/perl/ch-2.pl">Ulrich Rieke&rsquo;s solution</a> begins with a <code>findSequence</code> sub:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">findSequence</span> {
    <span style="color:#66d9ef">my</span> $n <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">my</span> @sequence;
    <span style="color:#66d9ef">while</span> ( $n <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span> ) {
        push( @sequence, $n );
        <span style="color:#66d9ef">if</span> ( $n % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> ) {
            $n <span style="color:#f92672">/=</span> <span style="color:#ae81ff">2</span>;
        }
        <span style="color:#66d9ef">else</span> {
            $n <span style="color:#f92672">=</span> $n <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
        }
    }
    push( @sequence, $n );
    <span style="color:#66d9ef">return</span> @sequence;
}
</code></pre></div><p>The one million loop uses <code>findSequence</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> @sequences;
<span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i ( <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> <span style="color:#ae81ff">1000000</span> ) {
    @sequence <span style="color:#f92672">=</span> findSequence($i);
    push( @sequences, [ $i, scalar @sequence ] );
}
<span style="color:#66d9ef">my</span> @sorted <span style="color:#f92672">=</span> sort { ${$b}[<span style="color:#ae81ff">1</span>] <span style="color:#e6db74">&lt;=&gt;</span> ${$a}[<span style="color:#ae81ff">1</span>] } @sequences;
<span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;The 20 longest Collatz sequences in numbers up to 1000000:\n&#34;</span>;
map { <span style="color:#66d9ef">print</span> ${$_}[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">.</span> ${$_}[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34;\n&#34;</span> } @sorted[ <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> <span style="color:#ae81ff">19</span> ];
</code></pre></div><p>This brute force implementation runs in about 1m7sec.</p>
<h2 id="user-person2">User Person</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/user-person/perl/ch-2.pl">User Person&rsquo;s solution</a> is a rather comprehensive script. When run with the <code>m{-{0,2}extra[-~!@#$%^&amp;*=+|\\;:'&quot;,.?/ ]?credit}i</code> option (better to be permissive with inputs, right‽), the following loop runs through <code>2..$MAX</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> %high <span style="color:#f92672">=</span> ();
<span style="color:#66d9ef">my</span> $i <span style="color:#f92672">=</span> $n;

OUTER_LOOP:
<span style="color:#66d9ef">while</span> ($i <span style="color:#f92672">&lt;=</span> $MAX) {
    <span style="color:#66d9ef">my</span> $count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

    <span style="color:#66d9ef">while</span> ($n <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>) {

        <span style="color:#66d9ef">if</span> ($extraCredit) {
            $count<span style="color:#f92672">++</span>;
        } <span style="color:#66d9ef">else</span> {
            <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;$n -&gt; &#34;</span>;
        }

        <span style="color:#66d9ef">if</span> ($n % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {          <span style="color:#75715e"># EVEN</span>
            $n <span style="color:#f92672">/=</span> <span style="color:#ae81ff">2</span>;
        } <span style="color:#66d9ef">else</span> {                    <span style="color:#75715e"># ODD</span>
            $n <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span><span style="color:#f92672">*</span>$n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
        }
    }

    <span style="color:#66d9ef">if</span> ($extraCredit) {
        checkHighKeys( $i, $count, <span style="color:#f92672">\</span>%high);
        $n <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>$i;
        <span style="color:#66d9ef">if</span> ($n % 20_000 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
            <span style="color:#66d9ef">print</span> STDOUT <span style="color:#e6db74">&#34;#&#34;</span>;
        }
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;1\n&#34;</span>;
        <span style="color:#66d9ef">last</span> OUTER_LOOP;
    }
}
</code></pre></div><p>Finally, the top results are printed:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">if</span> ($extraCredit) {
    <span style="color:#66d9ef">print</span> STDERR <span style="color:#e6db74">&#34;\n\n&#34;</span>;
    <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $key (sort { $high{$b} <span style="color:#e6db74">&lt;=&gt;</span> $high{$a} <span style="color:#f92672">or</span> $b <span style="color:#e6db74">&lt;=&gt;</span> $a } keys %high) {
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;Starting number: &#34;</span>, $key, <span style="color:#e6db74">&#34; with sequence length: &#34;</span>,  $high{$key}, <span style="color:#e6db74">&#34;\n&#34;</span>;
    }
}
</code></pre></div><h2 id="wanderdoc2">Wanderdoc</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/wanderdoc/perl/ch-2.pl">Wanderdoc&rsquo;s solution</a> begins with <code>collatz</code>, which memoizes the next number in the sequence:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> %collatz_mem <span style="color:#f92672">=</span> ( <span style="color:#ae81ff">4</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">1</span> ); <span style="color:#75715e"># ( 5 =&gt; 16, 16 =&gt; 8, 8 =&gt; 4, 4 =&gt; 2, 2 =&gt; 1, );</span>

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">collatz</span> {
    <span style="color:#66d9ef">my</span> $n <span style="color:#f92672">=</span> $_[<span style="color:#ae81ff">0</span>];
    <span style="color:#66d9ef">my</span> @seq;
    <span style="color:#66d9ef">while</span> ( $n <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span> ) {
        <span style="color:#66d9ef">if</span> ( exists $collatz_mem{$n} ) {
            <span style="color:#66d9ef">my</span> $key <span style="color:#f92672">=</span> $n;
            <span style="color:#66d9ef">while</span> ( $key <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span> ) {
                push @seq, $key;

                $key <span style="color:#f92672">=</span> $collatz_mem{$key};
            }
            push @seq, <span style="color:#ae81ff">1</span>;

            <span style="color:#66d9ef">return</span> @seq;
        } <span style="color:#66d9ef">else</span> {

            <span style="color:#66d9ef">my</span> $old_n <span style="color:#f92672">=</span> $n;
            push @seq, $n;

            <span style="color:#66d9ef">if</span> ( <span style="color:#ae81ff">0</span> <span style="color:#f92672">==</span> $n % 2 ) {
                $n <span style="color:#f92672">=</span> $n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
            } <span style="color:#66d9ef">else</span> {
                $n <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> $n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
            }
            $collatz_mem{$old_n} <span style="color:#f92672">=</span> $n;
        }
    }
}
</code></pre></div><p>As I&rsquo;ve explained previously, caching the next number in sequence trades a hash lookup for a quick arithmetic operation, which is going to be slower than just doing the arithmetic operation every time.</p>
<p>Here is the million Collatz loop:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> $EDGE <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;
<span style="color:#66d9ef">my</span> %longest;
<span style="color:#66d9ef">my</span> $PRINT_SEQUENCE <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

<span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $N ( <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> <span style="color:#ae81ff">1_000_000</span> ) {
    <span style="color:#66d9ef">my</span> @sequence <span style="color:#f92672">=</span> collatz($N);

    <span style="color:#66d9ef">my</span> $length <span style="color:#f92672">=</span> scalar @sequence;

    <span style="color:#66d9ef">my</span> $max <span style="color:#f92672">=</span> max keys %longest <span style="color:#f92672">||</span> <span style="color:#ae81ff">1</span>;

    <span style="color:#66d9ef">if</span> ( $length <span style="color:#f92672">&gt;</span> $max ) {
        $longest{$length} <span style="color:#f92672">=</span> [@sequence];
    }

    <span style="color:#66d9ef">my</span> $how_many <span style="color:#f92672">=</span> scalar keys %longest;

    <span style="color:#66d9ef">if</span> ( $how_many <span style="color:#f92672">&gt;</span> $EDGE ) {
        <span style="color:#66d9ef">my</span> $min <span style="color:#f92672">=</span> min keys %longest;
        delete $longest{$min};
    }
}

<span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $n ( sort { $b <span style="color:#e6db74">&lt;=&gt;</span> $a } keys %longest ) {
    <span style="color:#66d9ef">print</span> ${ $longest{$n} }[<span style="color:#ae81ff">0</span>], <span style="color:#e6db74">&#39;: &#39;</span>, scalar @{ $longest{$n} }, $/;
    <span style="color:#66d9ef">print</span> join( <span style="color:#e6db74">&#39; -&gt; &#39;</span>, @{ $longest{$n} } ), $/ <span style="color:#66d9ef">if</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">==</span> $PRINT_SEQUENCE;
}
</code></pre></div><p>This code runs in 1m22sec on my VM.</p>
<h2 id="yet-ebreo2">Yet Ebreo</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/yet-ebreo/perl/ch-2.pl">Yet Ebreo&rsquo;s solution</a> has a memoized recursive <code>gen_seq</code> sub, and I really like to see the hints of iterative development, with the code comment, below:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> @out;
<span style="color:#66d9ef">my</span> $r;
<span style="color:#66d9ef">my</span> %mem;
<span style="color:#66d9ef">my</span> $cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#66d9ef">my</span> $ctr <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">gen_seq</span> {
    <span style="color:#66d9ef">my</span> ($n) <span style="color:#f92672">=</span> @_;
    <span style="color:#75715e">#The if statement below improved execution time from 75 secs to 10 secs</span>
    <span style="color:#66d9ef">if</span> ($mem{$n}) {
        $cnt    <span style="color:#f92672">+=</span> $mem{$n} <span style="color:#f92672">=~</span>y<span style="color:#e6db74">/ /</span><span style="color:#f92672">/</span>;
        $r      <span style="color:#f92672">.=</span> $mem{$n};
        <span style="color:#66d9ef">return</span>
    }
    $r <span style="color:#f92672">.=</span> <span style="color:#e6db74">&#34;$n &#34;</span>;
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">if</span> ($n <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>);
    gen_seq( $n <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span> ? <span style="color:#ae81ff">3</span><span style="color:#f92672">*</span>$n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> : $n<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span> );
}
</code></pre></div><p>It&rsquo;s worth noting that <code>gen_seq</code> and the <code>%mem</code> table both work with string-based sequences.  The global <code>$cnt</code> keeps track of how many total iterations are saved with memoization, and that is obtained by counting the spaces between elements in the sequence with <code>y///</code>.</p>
<p>Up next is the one million sequence code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $n (<span style="color:#ae81ff">2</span><span style="color:#f92672">..</span><span style="color:#ae81ff">1e6</span>) {
    $r <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>;
    gen_seq($n);
    $mem{$n} <span style="color:#f92672">=</span> $r;
    push @{$out[$r<span style="color:#f92672">=~</span>y<span style="color:#e6db74">/ /</span><span style="color:#f92672">/</span>]}, <span style="color:#e6db74">&#34;$r&#34;</span>;
}
</code></pre></div><hr>
<hr>
<h2 id="blogs">See Also</h2>
<h3 id="blogs-this-week">Blogs this week:</h3>
<p><strong>Cheok-Yin Fung</strong> › <a href="http://blogs.perl.org/users/c_y_fung/2020/04/cys-take-on-pwc054.html">CY&rsquo;s take on PWC#054</a></p>
<p><strong>Dave Jacoby</strong> › <a href="https://jacoby.github.io/2020/03/30/permutations-and-conjectures.html">Permutations and Conjectures</a></p>
<p><strong>E. Choroba</strong> › <a href="http://blogs.perl.org/users/e_choroba/2020/04/perl-weekly-challenge-054-kth-permutation-sequence-collatz-conjecture.html">Kth Permutation Sequence + Collatz Conjecture</a></p>
<p><strong>Jaldhar H. Vyas</strong> › <a href="https://www.braincells.com/perl/2020/04/perl_weekly_challenge_week_54.html">Jaldhar&rsquo;s Week #054 Blog</a></p>
<p><strong>Javier Luque</strong> › <a href="https://perlchallenges.wordpress.com/2020/03/30/perl-weekly-challenge-054/">054 – Perl Weekly Challenge</a></p>
<p><strong>Kevin Colyer</strong> › <a href="https://kevincolyer.wordpress.com/2020/04/05/perl-weekly-challenge-week-54/">Perl Weekly Challenge – Week 54</a></p>
<p><strong>Laurent Rosenfeld</strong> › <a href="http://blogs.perl.org/users/laurent_r/2020/04/perl-weekly-challenge-54-k-th-permutation-sequence-and-the-collatz-conjecture.html">k-th Permutation Sequence and the Collatz Conjecture</a></p>
<p><strong>Mohammad S Anwar</strong> › <a href="https://perlweeklychallenge.org/blog/weekly-challenge-054">BLOG: The Weekly Challenge #054</a></p>
<p><strong>Ryan Thompson</strong> › <a href="http://www.ry.ca/2020/04/kth-permutation/">kth Permutation</a> | <a href="http://www.ry.ca/2020/04/collatz-conjecture/">Collatz Conjecture</a></p>
<p><strong>Shahed Nooshmand</strong> › <a href="https://rafraichisso.ir/2020/04/03/pwc-54">week 54 ― Rafraîchissoir</a></p>

                </div>
            </div>
        </div>
    </div>
</section>


<!-- Call To Action Section Start -->
<section id="call-to-action">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2 class="title wow fadeInDown" data-wow-delay=".3s" data-wow-duration="500ms">SO WHAT DO YOU THINK ?</h2>
                    <p class="wow fadeInDown" data-wow-delay=".5s" data-wow-duration="500ms">If you have any suggestions or ideas then please do share with us.</p>
                    <a href="mailto:mohammad.anwar@yahoo.com" class="btn btn-default btn-contact wow fadeInDown" data-wow-delay=".7s" data-wow-duration="500ms">Contact with me</a>
                </div>
            </div>

        </div>
    </div>
</section>
<!-- Call To Action Section End -->



<!-- Footer Section Start -->
<footer id="footer">
    <div class="container">
        <div class="row content-justify-between">
            <div class="col-md-8 col-12 text-center text-lg-left text-md-left">
                <p class="copyright">Copyright:
                    <span>
                        2019 - 2025
                    </span> The Weekly Challenge. Theme Design and Developed by
                    <a href="http://www.Themefisher.com" rel="noreferrer" rel="noreferrer" target="_blank">Themefisher</a>.
                </p>
            </div>
            <div class="col-md-4 col-12">
                <!-- Social Media -->
                <ul class="social text-center text-md-right text-lg-right">
                    <li>
                        <a href="https://twitter.com/PerlWChallenge" class="twitter" rel="noreferrer" target="_blank" title="Follow us">
                            <i class="ion-social-twitter"></i>
                        </a>
                    </li>
                    <li>
                        <a href="/rss.xml" class="rss" target="_blank" title="RSS Feed">
                            <i class="ion-social-rss"></i>
                        </a>
                    </li>
                </ul>
            </div>
        </div>
    </div>
</footer>
<!-- footer section end -->

<!-- jquery -->
<script src="https://theweeklychallenge.org/plugins/jquery/jquery.min.js"></script>
<!-- Form Validation -->
<script src="https://theweeklychallenge.org/plugins/form-validation/jquery.form.min.js"></script>
<script src="https://theweeklychallenge.org/plugins/form-validation/jquery.validate.min.js"></script>
<!-- slick slider -->
<script src="https://theweeklychallenge.org/plugins/slick/slick.min.js"></script>
<!-- bootstrap js -->
<script src="https://theweeklychallenge.org/plugins/bootstrap/bootstrap.min.js"></script>
<!-- chart js -->
<script src="https://theweeklychallenge.org/plugins/chart/highstock.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/drilldown.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/data.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/chart.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/pwc-challenge.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/gc-challenge.js"></script>
<!-- wow js -->
<script src="https://theweeklychallenge.org/plugins/wow-js/wow.min.js"></script>
<!-- slider js -->
<script src="https://theweeklychallenge.org/plugins/slider/slider.js"></script>
<!-- Fancybox -->
<script src="https://theweeklychallenge.org/plugins/facncybox/jquery.fancybox.js"></script>
<!-- template main js -->

<script src="https://theweeklychallenge.org/js/script.min.js"></script>
<!-- google analitycs -->

<script async src="https://www.googletagmanager.com/gtag/js?id=G-CJTPYM9SB8"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-CJTPYM9SB8');
</script>
</body>

</html>

