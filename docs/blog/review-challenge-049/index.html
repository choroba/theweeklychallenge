<!DOCTYPE html>
<html class="no-js" lang="en-us">
<head>
    <!-- Basic Page Needs -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:title"       content="Ryan Thompson › Perl Weekly Review #049"/>
    <meta property="og:type"        content="website"/>
    <meta property="og:url"         content="https://theweeklychallenge.org/blog/review-challenge-049/"/>
    <meta property="og:image"       content="https://theweeklychallenge.org/images/about/about.jpg"/>
    <meta property="og:description" content="Ryan Thompson › Perl Weekly Review #049"/>
    <meta name="twitter:card"       content="summary" />
    <meta name="twitter:image"      content="https://theweeklychallenge.org/images/about/about.jpg"/>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <meta name="description" content="Ryan Thompson › Perl Weekly Review #049">
    <meta name="author" content="The Weekly Challenge Team">
    <meta name="generator" content="Hugo 0.67.0-DEV" />

    <link rel="me" href="https://fosstodon.org/@manwar">
    <link rel="canonical" href="https://theweeklychallenge.org/blog/review-challenge-049/" />

    <!-- Mobile Specific Metas -->
    <meta name="format-detection" content="telephone=no">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Ryan Thompson › Perl Weekly Review #049</title>
    <link rel="icon" href="https://theweeklychallenge.org/images/favicon.ico">

    
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css"/>

    <!-- Twitter Bootstrs CSS -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/bootstrap/bootstrap.min.css">
    <!-- Ionicons Fonts Css -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/ionicons/ionicons.min.css">
    <!-- animate css -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/animate-css/animate.css">
    <!-- Hero area slider css-->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/slider/slider.css">
    <!-- slick slider -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/slick/slick.css">
    <!-- Fancybox -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/facncybox/jquery.fancybox.css">
    <!-- hover -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/hover/hover-min.css">
    <!-- Google fonts -->
    <link href='https://fonts.googleapis.com/css?family=Source Code Pro' rel='stylesheet'>
    <!-- template main css file -->
    
    <link rel="stylesheet" href="https://theweeklychallenge.org/css/style.min.css" integrity="" media="screen">
    <link rel="stylesheet" href="https://theweeklychallenge.org/css/main.css">

    <style>
        #goTopButton {
            display: none;          
            position: fixed;        
            bottom: 20px;           
            right: 30px;            
            z-index: 99;            
            border: none;           
            outline: none;          
            background-color: red;  
            color: white;           
            cursor: pointer;        
            padding: 15px;          
            border-radius: 10px;    
            font-size: 18px;        
        }

        #goTopButton:hover {
              background-color: #555;
        }
    </style>


</head>

<body>

<button onclick="goTop()" id="goTopButton" title="Go to top">Top</button>

<script>

    topButton = document.getElementById("goTopButton");

    
    window.onscroll = function() { scrollFunction() };

    function scrollFunction() {
        if (document.body.scrollTop > 40 || document.documentElement.scrollTop > 40) {
            topButton.style.display = "block";
        } else {
            topButton.style.display = "none";
        }
    }

    
    function goTop() {
        document.body.scrollTop = 0; 
        document.documentElement.scrollTop = 0; 
    }

</script>

<section class="top-bar animated-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-12">
                <nav class="navbar navbar-expand-lg navbar-light bg-light">
                    <a class="navbar-brand" href="https://theweeklychallenge.org/">
                        <img src="https://theweeklychallenge.org/images/logo.svg" alt="logo">
                    </a>

                    <button class="navbar-toggler d-lg-none"
                            type="button"
                            data-toggle="collapse"
                            data-target="#navigation"
                            aria-controls="navigation"
                            aria-expanded="false"
                            aria-label="Toggle navigation">
                        <span class="navbar-toggler-icon"></span>
                    </button>

                    <div class="navbar-collapse" id="navigation">
                        <ul class="navbar-nav ml-auto">
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/">Home</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/about">About</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/chart">Chart</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/champions">Champions</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/team">Team</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/challenges">Challenges</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/p5-reviews">Perl/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/p6-reviews">Raku/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/recaps">Recaps</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/blogs">Blogs</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/faq">FAQ</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/contact">Contact</a>
                            </li>
                            
                        </ul>
                    </div>
                </nav>
            </div>
        </div>
    </div>
</section>


<section class="global-page-header">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2>Ryan Thompson › Perl Weekly Review #049</h2>
                    <div class="portfolio-meta">
                        <span>Monday, Mar 16, 2020</span>|
                        <span> Tags:
                            perl
                        </span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

<section class="single-post">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                
                <div style="text-align: center" class="post-img">
                    <img class="img-fluid" alt="" src="https://theweeklychallenge.org/images/blog/p5-review-challenge-049.jpg">
                </div>
                
                <div style="text-align: justify" class="post-content">
                    <p>Continues from <a href="/blog/review-challenge-048/">previous week</a>.</p>
<p>Welcome to the Perl review for Week 049 of the Weekly Challenge! For a quick overview, go through the <a href="/blog/perl-weekly-challenge-049/">original tasks</a> and <a href="/blog/recap-challenge-049/">recap</a> of the weekly challenge.</p>
<h2 id="getting-in-touch">Getting in Touch</h2>
<p><a href="mailto:rjt@cpan.org"><img src="http://ry.ca/misc/Email.svg" height="50" width="50"> Email</a> › Email me (Ryan) with any feedback about this review.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge"><img src="http://ry.ca/misc/Github.svg" height="50" width="50"> GitHub</a> › Submit a pull request for any issues you may find with this page.</p>
<p><a href="https://twitter.com/perlwchallenge"><img src="http://ry.ca/misc/Twitter.svg" height="50" width="50"> Twitter</a> › Join the discussion on Twitter!</p>
<p>We&rsquo;d greatly appreciate any feedback you&rsquo;d like to give.</p>
<h2 id="table-of-contents">Table of Contents</h2>
<h3 id="task-1task1"><a href="#task1">Task 1</a></h3>
<p>[ <a href="#alicia-bielsa1">Alicia Bielsa</a>  | <a href="#cheok-yin-fung1">Cheok-Yin Fung</a>  | <a href="#colin-crain1">Colin Crain</a>  | <a href="#cristian-heredia1">Cristina Heredia</a>  | <a href="#dave-cross1">Dave Cross</a>  | <a href="#dave-jacoby1">Dave Jacoby</a>  | <a href="#duane-powell1">Duane Powell</a>  | <a href="#duncan-c-white1">Duncan C. White</a>  | <a href="#e-choroba1">E. Choroba</a>  | <a href="#ianrifkin1">Ian Rifkin</a>  | <a href="#jaldhar-h-vyas1">Jaldhar H. Vyas</a>  | <a href="#javier-luque1">Javier Luque</a>  | <a href="#laurent-rosenfeld1">Laurent Rosenfeld</a>  | <a href="#lubos-kolouch1">Lubos Kolouch</a>  | <a href="#mohammad-anwar1">Mohammad S Anwar</a>  | <a href="#peter-scott1">Peter Scott</a>  | <a href="#roger-bell-west1">Roger Bell West</a>  | <a href="#ruben-westerberg1">Ruben Westerberg</a>  | <a href="#ryan-thompson1">Ryan Thompson</a>  | <a href="#saiftynet1">Saif Ahmed</a>  | <a href="#southpawgeek1">Jen Guerra</a>  | <a href="#steven-wilson1">Steven Wilson</a>  | <a href="#user-person1">User Person</a>  | <a href="#wanderdoc1">Wanderdoc</a>  | <a href="#yet-ebreo1">Yet Ebreo</a>  ]</p>
<h3 id="task-2task2"><a href="#task2">Task 2</a></h3>
<p>[ <a href="#alicia-bielsa2">Alicia Bielsa</a>  | <a href="#cheok-yin-fung2">Cheok-Yin Fung</a>  | <a href="#colin-crain2">Colin Crain</a>  | <a href="#dave-jacoby2">Dave Jacoby</a>  | <a href="#duane-powell2">Duane Powell</a>  | <a href="#duncan-c-white2">Duncan C. White</a>  | <a href="#e-choroba2">E. Choroba</a>  | <a href="#ianrifkin2">Ian Rifkin</a>  | <a href="#javier-luque2">Javier Luque</a>  | <a href="#laurent-rosenfeld2">Laurent Rosenfeld</a>  | <a href="#lubos-kolouch2">Lubos Kolouch</a>  | <a href="#mohammad-anwar2">Mohammad S Anwar</a>  | <a href="#roger-bell-west2">Roger Bell West</a>  | <a href="#ruben-westerberg2">Ruben Westerberg</a>  | <a href="#ryan-thompson2">Ryan Thompson</a>  | <a href="#saiftynet2">Saif Ahmed</a>  | <a href="#southpawgeek2">Jen Guerra</a>  | <a href="#user-person2">User Person</a>  | <a href="#wanderdoc2">Wanderdoc</a>  | <a href="#yet-ebreo2">Yet Ebreo</a>  ]</p>
<h3 id="blogsblogs"><a href="#blogs">Blogs</a></h3>
<hr>
<hr>
<h1 id="task1">Task #1 - Smallest Multiple</h1>
<p>Write a script to accept a positive number as command line argument and print the smallest multiple of the given number consists of digits 0 and 1.</p>
<p>For example:</p>
<p>For given number 55, the smallest multiple is 110 consisting of digits 0 and 1.</p>
<hr>
<p>Solutions for this task came in two basic flavours:</p>
<h3 id="brute-force-check-every-multiple">Brute Force (check every multiple)</h3>
<p>The most obvious way to solve this problem is to simply loop through every multiple of the given number, and return the first number containing only 1s and 0s. For numbers with small answers, this works fine, but even small input numbers can lead to some very large results. Multiples of 9 in particular, are very bad:</p>
<h3 id="breadth-first-search-or-binary-counting">Breadth First Search or Binary counting</h3>
<p>A more efficient solution can be had by using a breadth first search to explore the solution space. That is, one can totally skip any numbers that contain unwanted digits, by looping through numbers containing only 1s and 0s. This can be done with a BFS, or by counting in binary.</p>
<h3 id="deeper-mathematical-analysis">Deeper mathematical analysis</h3>
<p>It&rsquo;s possible to get even better results with some more analysis. <a href="#cheok-yin-fung1">Cheok-Yin Fung&rsquo;s solution</a> is, I believe, the most analytical of the solutions up for review this week.</p>
<h2 id="alicia-bielsa1">Alicia Bielsa</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/alicia-bielsa/perl/ch-1.pl">Alicia Bielsa&rsquo;s solution</a> checks every multiple:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> $smallestMultiple <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#66d9ef">my</span> $count <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
<span style="color:#66d9ef">while</span> ($smallestMultiple <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> ){
    $smallestMultiple <span style="color:#f92672">=</span> ( $numberInput <span style="color:#f92672">*</span> $count ) <span style="color:#f92672">=~</span><span style="color:#e6db74"> /^[01]+$/</span> ? ( $numberInput <span style="color:#f92672">*</span> $count) : <span style="color:#ae81ff">0</span>;
    $count<span style="color:#f92672">++</span>;
}
<span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;$smallestMultiple\n&#34;</span>
</code></pre></div><h2 id="cheok-yin-fung1">Cheok-Yin Fung</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/cheok-yin-fung/perl/ch-1.pl">Cheok-Yin Fung&rsquo;s solution</a> does a deep dive on the math behind this problem. I had a very pleasant conversation with Cheok Yin, who contacted me via email to discuss the performance.</p>
<p>Cheok Yin first removes (and counts) factors of 2 (<code>$s</code>) and 5 (<code>$t</code>), with the remainder in <code>$C</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> $N <span style="color:#f92672">=</span> $ARGV[<span style="color:#ae81ff">0</span>];
<span style="color:#66d9ef">my</span> $C <span style="color:#f92672">=</span> $N;
<span style="color:#66d9ef">my</span> $s <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#66d9ef">my</span> $t <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#66d9ef">while</span> ( $C % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
    $C <span style="color:#f92672">/=</span> <span style="color:#ae81ff">2</span>; $s<span style="color:#f92672">++</span>;
}
<span style="color:#66d9ef">while</span> ( $C % 5 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
    $C <span style="color:#f92672">/=</span> <span style="color:#ae81ff">5</span>; $t<span style="color:#f92672">++</span>;
}
</code></pre></div><p>The answer we&rsquo;re looking for is a multiple of the original number, but now also a multiple of <code>2^s * 5^t * C</code>. The main body of the solution uses modulo arithmetic in an interesting way:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> @D <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1</span>);
<span style="color:#66d9ef">my</span> $k <span style="color:#f92672">=</span> ( ($C<span style="color:#f92672">==</span><span style="color:#ae81ff">1</span>) ? <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> : <span style="color:#ae81ff">0</span>);
<span style="color:#66d9ef">my</span> @key <span style="color:#f92672">=</span> ();
<span style="color:#66d9ef">while</span> ( $k <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">and</span> @key <span style="color:#f92672">==</span> () ) {
    <span style="color:#66d9ef">my</span> $temp;
    $temp <span style="color:#f92672">=</span> ( <span style="color:#ae81ff">10</span> <span style="color:#f92672">*</span> $D[ <span style="color:#ae81ff">2</span><span style="color:#f92672">**</span>( $k <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> ) ] )
      % <span style="color:#960050;background-color:#1e0010">$</span>C;    <span style="color:#75715e"># in simpler but slower terms, $temp = (10**$k) % $C;</span>
    $D[ <span style="color:#ae81ff">2</span><span style="color:#f92672">**</span>($k) ] <span style="color:#f92672">=</span> $temp;
    $k<span style="color:#f92672">++</span>;
    <span style="color:#66d9ef">if</span> ( $k <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span> $k <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span> ) {
        <span style="color:#66d9ef">for</span> ( <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">**</span>( $k <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> ) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> ) {
            $D[ <span style="color:#ae81ff">2</span><span style="color:#f92672">**</span>( $k <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> ) <span style="color:#f92672">+</span> $_ ] <span style="color:#f92672">=</span> ( $D[$_] <span style="color:#f92672">+</span> $temp ) % <span style="color:#960050;background-color:#1e0010">$</span>C; <span style="color:#75715e"># Ryan[0]</span>
            <span style="color:#66d9ef">if</span> ( $D[ <span style="color:#ae81ff">2</span><span style="color:#f92672">**</span>( $k <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> ) <span style="color:#f92672">+</span> $_ ] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> ) {
                push @key, <span style="color:#ae81ff">2</span><span style="color:#f92672">**</span>( $k <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> ) <span style="color:#f92672">+</span> $_;

                <span style="color:#75715e"># We cannot simply write:  $key = 2**($k-1) + $_;</span>
                <span style="color:#75715e"># because there could be more than one mulitples in 100...000 to 111..111, e.g. C=27;</span>
            }
        }
    }
}
@key <span style="color:#f92672">=</span> sort {$a <span style="color:#e6db74">&lt;=&gt;</span> $b} @key;
<span style="color:#66d9ef">if</span> ($C <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>) {printf <span style="color:#e6db74">&#34;%0b&#34;</span>, $key[<span style="color:#ae81ff">0</span>];} <span style="color:#66d9ef">else</span> {<span style="color:#66d9ef">print</span> <span style="color:#ae81ff">1</span>;}
<span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;0&#34;</span> x max($s,$t);
</code></pre></div><p>Cheok Yin did not provide any other documentation with this code, so I had to reverse-engineer the math myself. I first noted that the outer <code>if ($k != 0 or $k != 1) {</code> statement&rsquo;s condition is <em>always</em> true, so it could be removed.</p>
<p>The potential solutions are built up in <code>@key</code>. By the end of the loop, <code>@key</code> may contain multiple solutions, so Cheok Yin prints the minimum. I&rsquo;d personally use <code>List::Util</code>'s O(n) <code>min</code> for this instead of the O(n log n) <code>sort</code>, but only because it is cleaner:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">printf <span style="color:#e6db74">&#34;%b%s\n&#34;</span>, min(@key) <span style="color:#f92672">||</span> <span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#39;0&#39;</span> x max($s, $t); <span style="color:#75715e"># Ryan&#39;s version</span>
</code></pre></div><p>The <code>@D</code> array grows in powers of two, each time through the outer <code>while</code> loop, and stores the remainders of the current power of two in the next power of two at the line marked <code>Ryan[0]</code>. Thus Cheok Yin is doubling the search space for every iteration of the <code>while</code> loop. If a result is found where the remainder was zero, then we have a valid solution, so it is pushed to the result array, <code>@key</code>. The solution is found when <code>@key</code> is non-empty.</p>
<p>In my opinion (for what it&rsquo;s worth!), a solution this complex needs more documentation. A future maintainer (or reviewer!) should not have to spend more than a few minutes to figure out code of this length. Without documentation, variable names like <code>@D</code> and <code>$temp</code> are hard to follow. Factoring out repeated calculations and otherwise simplifying the code would also help.</p>
<p>Still, I am quite impressed. Cheok Yin&rsquo;s solution is extremely quick compared to every other solution tested, and the math is interesting.</p>
<h2 id="colin-crain1">Colin Crain</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/colin-crain/perl/ch-1.pl">Colin Crain&rsquo;s solution</a> tries every multiple until one is found that doesn&rsquo;t contain any digits from <code>[2-9]</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> $input <span style="color:#f92672">=</span> shift @ARGV;
<span style="color:#66d9ef">my</span> $multiplier <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
<span style="color:#66d9ef">my</span> $value;
<span style="color:#66d9ef">while</span> ( $multiplier<span style="color:#f92672">++</span> ) {
    $value <span style="color:#f92672">=</span> $input <span style="color:#f92672">*</span> $multiplier;
    <span style="color:#66d9ef">next</span> <span style="color:#66d9ef">if</span> $value <span style="color:#f92672">=~</span><span style="color:#e6db74"> /[23456789]/</span>;
    <span style="color:#66d9ef">last</span>;
}
printf <span style="color:#e6db74">&#34;number: %5d       smallest multiple: %-15d\n&#34;</span>, $input, $value;
</code></pre></div><h2 id="cristian-heredia1">Cristina Heredia</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/cristian-heredia/perl/ch-1.pl">Cristina Heredia&rsquo;s solution</a> is mutually recursive, and uses global variables:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">no</span> warnings <span style="color:#e6db74">&#39;recursion&#39;</span>;
<span style="color:#66d9ef">my</span> $number <span style="color:#f92672">=</span> $ARGV[<span style="color:#ae81ff">0</span>]; <span style="color:#75715e"># RyanT: Input routines not shown</span>
<span style="color:#66d9ef">my</span> $result;
<span style="color:#66d9ef">my</span> $multiple <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">smallestMultiple</span> {
    $result <span style="color:#f92672">=</span> $number <span style="color:#f92672">*</span> $multiple;
    checkValues();
}
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">checkValues</span> {
   <span style="color:#66d9ef">if</span> ( $result <span style="color:#f92672">=~</span><span style="color:#e6db74"> /^[01]+$/</span> ) {
        $number<span style="color:#f92672">=~</span> <span style="color:#e6db74">s/^\s+|\s+$//g</span>;
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;The smallest multiple is $result\n$number * $multiple = $result\n&#34;</span>;
   }
   <span style="color:#66d9ef">else</span> {
       $multiple<span style="color:#f92672">++</span>;
       smallestMultiple();
   }
}
</code></pre></div><p><code>smallestMultiple</code> calls <code>checkValues</code> to see if the <code>$result</code> contains only 1s and 0s. Otherwise, it calls back to <code>smallestMultiple</code> on the next highest multiple.</p>
<p>Due to the mutual recursion, the stack grows quickly. With an input number of 99, it runs my VM out of memory within a few seconds. On numbers with smaller answers, however, it works just fine.</p>
<h2 id="dave-cross1">Dave Cross</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/dave-cross/perl/ch-1.pl">Dave Cross&rsquo;s solution</a> checks every multiple until one is found that doesn&rsquo;t contain any character that isn&rsquo;t a 1 or a 0:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">die <span style="color:#e6db74">&#34;I need a positive integer\n&#34;</span>
  <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>@ARGV <span style="color:#f92672">or</span> $ARGV[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=~</span><span style="color:#e6db74"> /\D/</span> <span style="color:#f92672">or</span> $ARGV[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span>;
<span style="color:#66d9ef">my</span> $num <span style="color:#f92672">=</span> shift;
<span style="color:#66d9ef">my</span> $x   <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
$x<span style="color:#f92672">++</span> <span style="color:#66d9ef">while</span> ($num <span style="color:#f92672">*</span> $x) <span style="color:#f92672">=~</span><span style="color:#e6db74"> /[^01]/</span>;
say <span style="color:#e6db74">&#34;$num x $x = &#34;</span>, $num <span style="color:#f92672">*</span> $x;
</code></pre></div><h2 id="dave-jacoby1">Dave Jacoby</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/dave-jacoby/perl/ch-1.pl">Dave Jacoby&rsquo;s solution</a> counts in decimal, then converts that to binary with <code>sprintf</code>. The answer is the first number that is evenly divisible by the input <code>$n</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#75715e">#!/usr/bin/env perl</span>
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">smallest_multiple</span>( $n ) {
    <span style="color:#66d9ef">my</span> $dec <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">while</span> ( <span style="color:#ae81ff">1</span> ) {
        <span style="color:#66d9ef">my</span> $bin <span style="color:#f92672">=</span> sprintf <span style="color:#e6db74">&#39;%b&#39;</span>, $dec;
        <span style="color:#66d9ef">return</span> $bin <span style="color:#66d9ef">if</span> $bin % <span style="color:#960050;background-color:#1e0010">$</span>n <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> ;
        $dec<span style="color:#f92672">++</span>;
    }
}
</code></pre></div><p>This solution is quite fast, finding <code>smallest_multiple(99)</code> in a mere 1/8th of a second on my machine.</p>
<h2 id="duane-powell1">Duane Powell</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/duane-powell/perl/ch-1.pl">Duane Powell&rsquo;s solution</a> checks every multiple, returning the first that matches <code>/^([01]+)$/</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> ($multiple, $next, $solved) <span style="color:#f92672">=</span> (<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>);
<span style="color:#66d9ef">until</span> ($solved) {
    $multiple <span style="color:#f92672">=</span> $number <span style="color:#f92672">*</span> <span style="color:#f92672">++</span>$next;
    <span style="color:#75715e"># Test if number is comprised just 0&#39;s and 1&#39;s</span>
    <span style="color:#66d9ef">if</span> ($multiple <span style="color:#f92672">=~</span> <span style="color:#e6db74">m/^([01]+)$/</span>) {
        <span style="color:#75715e"># Confirm it&#39;s not just all 1&#39;s</span>
        $solved <span style="color:#f92672">=</span> ($multiple <span style="color:#f92672">=~</span> <span style="color:#e6db74">m/0/</span>);
    }
}
</code></pre></div><p>Duane included an additional constraint that the answer must contain at least one zero, so some answers will not line up with those without that constraint. For example, without that constraint, the answer for 9 is 9 x 12_345_679 = 111_111_111, whereas Duane&rsquo;s code returns 9 x 112_345_679 = 1_011_111_111.</p>
<h2 id="duncan-c-white1">Duncan C. White</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/duncan-c-white/perl/ch-1.pl">Duncan C. White&rsquo;s solution</a> is self-described as being both &ldquo;cute&rdquo; <em>and</em> &ldquo;easy&rdquo;!</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#75715e"># My notes: cute, sounds easy.</span>
<span style="color:#66d9ef">use</span> Function::Parameters;

fun smallest_binary_multiple( $n ) {
    <span style="color:#66d9ef">my</span> $mult <span style="color:#f92672">=</span> $n;
    <span style="color:#66d9ef">do</span> {
        $mult <span style="color:#f92672">+=</span> $n;
    } <span style="color:#66d9ef">while</span> ( $mult <span style="color:#f92672">=~</span><span style="color:#e6db74"> /[2-9]/</span> );
    <span style="color:#66d9ef">return</span> $mult;
}
</code></pre></div><p>Duncan&rsquo;s use of the regex and simple <code>$mult</code> iteration makes for some &ldquo;cute&rdquo; and &ldquo;easy&rdquo; code indeed.</p>
<h2 id="e-choroba1">E. Choroba</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/e-choroba/perl/ch-1.pl">E. Choroba&rsquo;s first solution</a> also uses the regex approach:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">smallest_multiple</span> {
    <span style="color:#66d9ef">my</span> ($n) <span style="color:#f92672">=</span> @_;
    <span style="color:#66d9ef">my</span> $r <span style="color:#f92672">=</span> $n;
    $r <span style="color:#f92672">+=</span> $n <span style="color:#66d9ef">until</span> $r <span style="color:#f92672">=~</span><span style="color:#e6db74"> /^[01]+$/</span>;
    $r
}
</code></pre></div><hr>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/e-choroba/perl/ch-1a.pl">His second solution</a>, however, sacrifices a little brevity for a lot of efficiency, by using a variation of the binary counting method:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">smallest_multiple</span> {
    <span style="color:#66d9ef">my</span> ($n) <span style="color:#f92672">=</span> @_;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">unless</span> $n;

    <span style="color:#66d9ef">my</span> $binary <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">.</span> (<span style="color:#ae81ff">0</span> x (length($n) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>));
    increment($binary) <span style="color:#66d9ef">while</span> $binary % <span style="color:#960050;background-color:#1e0010">$</span>n;
    $binary
}

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">increment</span> {
    <span style="color:#66d9ef">my</span> $pos <span style="color:#f92672">=</span> rindex $_[<span style="color:#ae81ff">0</span>], <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">if</span> ($pos <span style="color:#f92672">&gt;</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
        substr $_[<span style="color:#ae81ff">0</span>], $pos, <span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#39;1&#39;</span>;
        substr $_[<span style="color:#ae81ff">0</span>], $pos <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, length($_[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">-</span> $pos <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>,
                         <span style="color:#e6db74">&#39;0&#39;</span> x (length($_[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">-</span> $pos <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
    } <span style="color:#66d9ef">else</span> {
        $_[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;1&#39;</span> <span style="color:#f92672">.</span> (<span style="color:#e6db74">&#39;0&#39;</span> x length $_[<span style="color:#ae81ff">0</span>]);
    }
}
</code></pre></div><p>Choroba&rsquo;s <code>increment</code> sub is interesting. He has deconstructed the process of counting in binary into this sub, which increments a binary string representation of a number. This solution finds <code>smallest_multiple(99)</code> in 0.3 seconds.</p>
<p><strong>Blog</strong> › <a href="http://blogs.perl.org/users/e_choroba/2020/03/perl-weekly-challenge-048-smallest-multiple-and-lru-cache.html">Smallest Multiple and LRU Cache</a></p>
<h2 id="ianrifkin1">Ian Rifkin</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/ianrifkin/perl/ch-1.pl">Ian Rifkin&rsquo;s solution</a> counts in decimal and converts to binary for a more efficient loop:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">use</span> Scalar::Util::Numeric <span style="color:#e6db74">qw(isint)</span>;
<span style="color:#66d9ef">use</span> Math::BigInt;
<span style="color:#66d9ef">use</span> Math::BigFloat;

<span style="color:#75715e"># [Ryan] Ian credits Perl Cookbook for this technique</span>
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">dec2bin</span> {
    <span style="color:#66d9ef">my</span> $str <span style="color:#f92672">=</span> unpack(<span style="color:#e6db74">&#34;B32&#34;</span>, pack(<span style="color:#e6db74">&#34;N&#34;</span>, shift));
    $str <span style="color:#f92672">=~</span> <span style="color:#e6db74">s/^0+(?=\d)//</span>;   <span style="color:#75715e"># otherwise you&#39;ll get leading zeros</span>
    <span style="color:#66d9ef">return</span> $str;
}

<span style="color:#66d9ef">my</span> $i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
<span style="color:#66d9ef">my</span> $output <span style="color:#f92672">=</span> undef;
<span style="color:#66d9ef">while</span> ($output <span style="color:#f92672">==</span> undef) {
    <span style="color:#66d9ef">my</span> $bin_i <span style="color:#f92672">=</span> dec2bin($i);
    $i<span style="color:#f92672">++</span> <span style="color:#f92672">and</span> <span style="color:#66d9ef">next</span> <span style="color:#66d9ef">unless</span> $bin_i <span style="color:#f92672">=~</span><span style="color:#e6db74"> /^1[1]*[0]+[0-1]*$/</span>;
    <span style="color:#66d9ef">my</span> $test <span style="color:#f92672">=</span> Math::BigFloat<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">new</span>($bin_i);
    $test<span style="color:#f92672">-&gt;</span>bdiv($input);
    $output <span style="color:#f92672">=</span> $bin_i <span style="color:#66d9ef">if</span> $test <span style="color:#f92672">==</span> $test<span style="color:#f92672">-&gt;</span>as_int() <span style="color:#f92672">and</span> $input <span style="color:#f92672">!=</span> $bin_i;
    $i<span style="color:#f92672">++</span>;
}
<span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;\n\nThe smallest multiple of $input with only digits 0 and 1 is: $output\n\n&#34;</span>;
</code></pre></div><p>Even though <code>dec2bin()</code> should always give a valid binary string, Ian also checks with a regex: <code>/^1[1]*[0]+[0-1]*$/</code>. This regex enforces the additional constraint that the answer must contain at least one zero, which means his answer for, e.g., 99 = <code>1_101_111_111_111_111_111</code>, versus <code>111_111_111_111_111_111</code>.</p>
<p>The regex also introduces the constraint that the answer be at least two digits, which means, for example, 2 x 5 = 10 and 11 x 1 = 11 are not valid solutions under Ian&rsquo;s interpretation of the challenge.</p>
<p>I would not, in general, recommend <code>Math::BigFloat</code> for integers. I did not try to find a case where it produces an invalid result, but I&rsquo;m fairly certain it will, sooner or later, because of <a href="https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html">floating point error</a> when converting a decimal number to and from fractional powers of two. These errors can be difficult to detect. I would use <a href="https://perldoc.perl.org/Math/BigInt.html"><code>Math::BigInt</code></a> instead, to store numbers precisely and avoid any chance of floating point error.</p>
<h2 id="jaldhar-h-vyas1">Jaldhar H. Vyas</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/jaldhar-h-vyas/perl/ch-1.pl">Jaldhar H. Vyas&rsquo;s solution</a> uses the regex approach to find a multiple:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> $num <span style="color:#f92672">=</span> shift;
<span style="color:#66d9ef">my</span> $multiple <span style="color:#f92672">=</span> $num;
<span style="color:#66d9ef">while</span> ($multiple <span style="color:#f92672">!~</span> <span style="color:#e6db74">/ \A [01]+ \z /gmx</span>) {
    $multiple <span style="color:#f92672">+=</span> $num;
}
say $num, <span style="color:#e6db74">&#39; x &#39;</span>, $multiple <span style="color:#f92672">/</span> $num, <span style="color:#e6db74">&#39; = &#39;</span>, $multiple;
</code></pre></div><h2 id="javier-luque1">Javier Luque</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/javier-luque/perl/ch-1.pl">Javier Luque&rsquo;s solution</a> also uses a regex:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> $new_number <span style="color:#f92672">=</span> $number;
<span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>($new_number <span style="color:#f92672">=~</span><span style="color:#e6db74"> /^[01]+$/</span>)) {
    $new_number <span style="color:#f92672">=</span> $number <span style="color:#f92672">*</span> $i<span style="color:#f92672">++</span>;
}
say <span style="color:#e6db74">&#34;Smallest multiple of $number is $new_number&#34;</span>;
</code></pre></div><p><strong>Blog</strong> › <a href="https://perlchallenges.wordpress.com/2020/02/28/perl-weekly-challenge-049/">049 – Perl Weekly Challenge</a></p>
<h2 id="laurent-rosenfeld1">Laurent Rosenfeld</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/laurent-rosenfeld/perl/ch-1.pl">Laurent Rosenfeld&rsquo;s solution</a> also uses a regex to find the lucky winner:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> $num <span style="color:#f92672">=</span> shift;
<span style="color:#66d9ef">my</span> $i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
<span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>) {
    <span style="color:#66d9ef">my</span> $result <span style="color:#f92672">=</span> $num <span style="color:#f92672">*</span> $i;
    <span style="color:#66d9ef">if</span> ($result <span style="color:#f92672">=~</span><span style="color:#e6db74"> /^[01]*$/</span>) {
        say <span style="color:#e6db74">&#34;$num * $i = $result&#34;</span>;
        <span style="color:#66d9ef">last</span>;
    }
    $i<span style="color:#f92672">++</span>;
}
</code></pre></div><p><strong>Blog</strong> › <a href="http://blogs.perl.org/users/laurent_r/2020/02/perl-weekly-challenge-smallest-multiple-and-lru-cache.html">Smallest Multiple and LRU Cache</a></p>
<h2 id="lubos-kolouch1">Lubos Kolouch</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/lubos-kolouch/perl/ch-1.pl">Lubos Kolouch&rsquo;s solution</a> uses a regex, and gives up early if a solution isn&rsquo;t found within 1000 iterations:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">find_multiple_0_1</span> {
    <span style="color:#66d9ef">my</span> $input <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">my</span> $count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">while</span> ($input <span style="color:#f92672">!~</span> <span style="color:#e6db74">/^[01]+$/</span>) {
        $input <span style="color:#f92672">+=</span> $input;
        <span style="color:#75715e"># for some numbers there is probably no result, so let&#39;s just return -1</span>
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#66d9ef">if</span> $count <span style="color:#f92672">==</span> <span style="color:#ae81ff">1000</span>;
        $count<span style="color:#f92672">++</span>;
    }
    <span style="color:#66d9ef">return</span> $input;
}
</code></pre></div><p>In case you are wondering, 55 out of the first 100 input numbers have multiples that would require more than 1000 iterations. The first such number is 9 x 12345679, for more than 12 million iterations! Even non-multiples of 9, like 23 = 4787, make a strong showing.</p>
<h2 id="mohammad-anwar1">Mohammad S Anwar</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/mohammad-anwar/perl/ch-1.pl">Mohammad S Anwar&rsquo;s solution</a> uses a regex, concisely:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> ($res, $i);
<span style="color:#66d9ef">do</span> { $res <span style="color:#f92672">=</span> $num <span style="color:#f92672">*</span> <span style="color:#f92672">++</span>$i; } <span style="color:#66d9ef">until</span> ($res <span style="color:#f92672">=~</span><span style="color:#e6db74"> /^[01]+$/</span>);
<span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;$num =&gt; $res\n&#34;</span>;
</code></pre></div><p><strong>Blog</strong> › <a href="https://perlweeklychallenge.org/blog/weekly-challenge-049">BLOG: The Weekly Challenge #049</a></p>
<h2 id="peter-scott1">Peter Scott</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/peter-scott/perl/ch-1.sh">Peter Scott&rsquo;s solution</a> unleashed another one-liner:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#75715e">#!/bin/sh
</span><span style="color:#75715e"></span>perl -E <span style="color:#e6db74">&#39;$x = shift; $i = 1; $i++ until ($i*$x) =~ /^[01]+$/; say &#34;$i * $x = &#34;, $i*$x&#39;</span> $*
</code></pre></div><p>Although it&rsquo;s already easy to see it is another multiple/regex-based solution, here it is, unrolled:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">$x <span style="color:#f92672">=</span> shift;
$i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
$i<span style="color:#f92672">++</span> <span style="color:#66d9ef">until</span> ( $i <span style="color:#f92672">*</span> $x ) <span style="color:#f92672">=~</span><span style="color:#e6db74"> /^[01]+$/</span>;
say <span style="color:#e6db74">&#34;$i * $x = &#34;</span>, $i <span style="color:#f92672">*</span> $x
</code></pre></div><h2 id="roger-bell-west1">Roger Bell West</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/roger-bell-west/perl/ch-1.pl">Roger Bell West&rsquo;s solution</a> is another regex-based one:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $n (@ARGV) {
    <span style="color:#66d9ef">my</span> $t <span style="color:#f92672">=</span> $n;
    <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>) {
        <span style="color:#66d9ef">if</span> ( $t <span style="color:#f92672">=~</span><span style="color:#e6db74"> /^[01]+$/</span> ) {
            <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;$t\n&#34;</span>;
            <span style="color:#66d9ef">last</span>;
        }
        <span style="color:#66d9ef">else</span> {
            $t <span style="color:#f92672">+=</span> $n;
        }
    }
}
</code></pre></div><p>It&rsquo;s an easy yet thoughtful addition to support multiple numbers on the commandline.</p>
<h2 id="ruben-westerberg1">Ruben Westerberg</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/ruben-westerberg/perl/ch-1.pl">Ruben Westerberg&rsquo;s solution</a> also uses a regex:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> ($num, $factor)<span style="color:#f92672">=</span>($ARGV[<span style="color:#ae81ff">0</span>]<span style="color:#e6db74">//</span><span style="color:#ae81ff">55</span>,<span style="color:#ae81ff">1</span>);
$factor<span style="color:#f92672">++</span> <span style="color:#66d9ef">until</span>  ($num<span style="color:#f92672">*</span>$factor) <span style="color:#f92672">=~</span><span style="color:#e6db74"> /^[01]+$/</span>;
printf <span style="color:#e6db74">&#34;Smallest multiple: %d\n&#34;</span>,$num<span style="color:#f92672">*</span>$factor;
</code></pre></div><h2 id="ryan-thompson1">Ryan Thompson</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/ryan-thompson/perl/ch-1.pl">My solution</a> looks at a few different ways of solving the problem. First is a regex one:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#75715e"># For... illustrative purposes only</span>
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">mult_brute</span> {
    local ($_) <span style="color:#f92672">=</span> @_;
    $_ <span style="color:#f92672">+=</span> $_[<span style="color:#ae81ff">0</span>] <span style="color:#66d9ef">while</span> <span style="color:#e6db74">/[^10]/</span>;
    $_;
}
</code></pre></div><p>I then flipped the problem around and iterated over the possible solutions (binary numbers) and I did that first by doing a breadth-first-search, using a queue:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#75715e"># 1,478,988% faster than mult_brute</span>
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">mult_bfs</span> {
    <span style="color:#66d9ef">my</span> $n <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">my</span> $cur;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">my</span> (@r) <span style="color:#f92672">=</span> $cur <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; $cur % <span style="color:#960050;background-color:#1e0010">$</span>n; $cur <span style="color:#f92672">=</span> shift @r) {
        push @r, $cur <span style="color:#f92672">.</span> <span style="color:#ae81ff">0</span>, $cur <span style="color:#f92672">.</span> <span style="color:#ae81ff">1</span>;
    }
    $cur;
}
</code></pre></div><p>As the comment indicates, the above function was about 1.5 million % faster than the brute force method. I realized that since I was basically just counting in binary, I may as well leave that to the well-optimized Perl builtin:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">mult_sprintf</span> {
    <span style="color:#66d9ef">my</span> $n <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">my</span> $i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; ; $i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">my</span> $cur <span style="color:#f92672">=</span> sprintf <span style="color:#e6db74">&#39;%b&#39;</span>, $i;
        <span style="color:#66d9ef">return</span> $cur <span style="color:#66d9ef">if</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">==</span> $cur % <span style="color:#960050;background-color:#1e0010">$</span>n;
    }
}
</code></pre></div><p>That simple optimization was another 30% improvement, and the code is nicer to look at, too.</p>
<p><strong>Blog</strong> › <a href="http://www.ry.ca/2020/03/smallest-multiple/">Smallest multiple containing only 1 and 0</a></p>
<h2 id="saiftynet1">Saif Ahmed</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/saiftynet/perl/ch-1.pl">Saif Ahmed&rsquo;s solution</a> includes two methods. First, the &ldquo;naive&rdquo; <code>method1</code>, is a regex-based one:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">method1</span> {
    <span style="color:#66d9ef">my</span> $input <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;Computer says NO!\n&#34;</span>,
                 <span style="color:#e6db74">&#34;Multiples of 9 are quicker with method2\n&#34;</span>
                      <span style="color:#66d9ef">unless</span> $input % 9;
    <span style="color:#66d9ef">my</span> $multiplier <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">while</span> ( ( ( $input <span style="color:#f92672">*</span> $multiplier ) <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34;&#34;</span> ) <span style="color:#f92672">=~</span><span style="color:#e6db74"> /[2-9]/</span> ) { $multiplier<span style="color:#f92672">++</span> }; increment unt
    <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;Input: $input, Multiplier: $multiplier Result: &#34;</span>,
        $input <span style="color:#f92672">*</span> $multiplier, <span style="color:#e6db74">&#34;\n&#34;</span>;
}
</code></pre></div><p>My guess is that <code>increment unt</code> was meant to be a comment, but since <code>method1</code> wasn&rsquo;t called from anywhere, it slipped through.</p>
<p><code>method2</code> uses a more efficient iterative approach, essentially a BFS with the queue elements being modified in-place rather than <code>push</code>ed and <code>shift</code>ed:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">method2</span> {
    <span style="color:#66d9ef">my</span> $input <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">my</span> $found <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;                              <span style="color:#75715e"># no answer yet</span>
    <span style="color:#66d9ef">my</span> @list  <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1</span>);                            <span style="color:#75715e"># start with @list containing 1</span>
    <span style="color:#66d9ef">while</span> ( <span style="color:#f92672">!</span>$found ) {
        @list <span style="color:#f92672">=</span> map { $_<span style="color:#f92672">.</span><span style="color:#e6db74">&#34;0&#34;</span>, $_<span style="color:#f92672">.</span><span style="color:#e6db74">&#34;1&#34;</span> } @list;   <span style="color:#75715e"># appends &#34;0&#34; or &#34;1&#34; to each element</span>
        <span style="color:#66d9ef">foreach</span> (@list) {
            $found <span style="color:#f92672">=</span> $_
              <span style="color:#66d9ef">unless</span> $_ % <span style="color:#960050;background-color:#1e0010">$</span>input;               <span style="color:#75715e"># $result stored in $found if multiple found</span>
            <span style="color:#66d9ef">last</span> <span style="color:#66d9ef">if</span> $found;                     <span style="color:#75715e"># exit loop once $found</span>
        }
    }
    <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;Input: $input, Multiplier: &#34;</span>, $found <span style="color:#f92672">/</span> $input, <span style="color:#e6db74">&#34;  Result: &#34;</span>, $found, <span style="color:#e6db74">&#34;\n&#34;</span>;
}
</code></pre></div><h2 id="southpawgeek1">Jen Guerra</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/southpawgeek/perl/ch-1.pl">Jen Guerra&rsquo;s solution</a> counts in binary with the help of <code>sprintf</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">my</span> $i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;;$i<span style="color:#f92672">++</span>){
    <span style="color:#66d9ef">my</span> $bin <span style="color:#f92672">=</span> sprintf(<span style="color:#e6db74">&#34;%b&#34;</span>, $i);
    <span style="color:#66d9ef">next</span> <span style="color:#66d9ef">if</span> $bin <span style="color:#f92672">==</span> $int;

    <span style="color:#75715e"># we know it starts with 1, but make sure there&#39;s at least one 0</span>
    <span style="color:#66d9ef">next</span> <span style="color:#66d9ef">unless</span> $bin <span style="color:#f92672">=~</span><span style="color:#e6db74"> /0+/</span>;

    say <span style="color:#e6db74">&#34;$bin is the smallest multiple of $int with 1s *and* 0s.&#34;</span>
        <span style="color:#f92672">and</span> <span style="color:#66d9ef">last</span>
        <span style="color:#66d9ef">unless</span> $bin % <span style="color:#960050;background-color:#1e0010">$</span>int;
}
</code></pre></div><p>Jen is another hacker who enforces the constraint of the answer containing at least one zero. The solution is fast, finding the (significantly larger) 99 -&gt; 1101111111111111111 in just 0.45 seconds on my machine.</p>
<h2 id="steven-wilson1">Steven Wilson</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/steven-wilson/perl/ch-1.pl">Steven Wilson&rsquo;s solution</a> uses a regex:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> $number     <span style="color:#f92672">=</span> $ARGV[<span style="color:#ae81ff">0</span>];
<span style="color:#66d9ef">my</span> $mulitplier <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
<span style="color:#66d9ef">my</span> $smallest_multiple;
<span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>) {
    <span style="color:#66d9ef">my</span> $mulitple <span style="color:#f92672">=</span> $mulitplier <span style="color:#f92672">*</span> $number;
    <span style="color:#66d9ef">if</span> ( $mulitple <span style="color:#f92672">=~</span><span style="color:#e6db74"> /^[01]*$/</span> ) {
        $smallest_multiple <span style="color:#f92672">=</span> $mulitple;
        <span style="color:#66d9ef">last</span>;
    }
    $mulitplier<span style="color:#f92672">++</span>;
}
say $smallest_multiple;
</code></pre></div><h2 id="user-person1">User Person</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/user-person/perl/ch-1.sh">User Person&rsquo;s solution</a> is not one, but <em>two</em> one-liners!</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">perl -e<span style="color:#e6db74">&#39;$a=&#39;</span>$1<span style="color:#e6db74">&#39;;$a+=&#39;</span>$1<span style="color:#e6db74">&#39;while$a=~/[^01]/;print$a,$/&#39;</span>
perl -e <span style="color:#e6db74">&#39;my $a = $ARGV[0]; my $b = $a; $a += $b while $a =~ /[^01]/; print&#34;$a\n&#34;&#39;</span> $1
</code></pre></div><p>The first, a regex-based one, expands to this (I&rsquo;ve replaced the shell <code>$1</code> with <code>$ARGV[0]</code> for clarity):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">$a <span style="color:#f92672">=</span> $ARGV[<span style="color:#ae81ff">0</span>];
$a <span style="color:#f92672">+=</span> $ARGV[<span style="color:#ae81ff">0</span>] <span style="color:#66d9ef">while</span> $a <span style="color:#f92672">=~</span><span style="color:#e6db74"> /[^01]/</span>;
<span style="color:#66d9ef">print</span> $a, $/
</code></pre></div><p>One-liner number two is a slight variation, presumably to be a bit more readable and avoid the tedious shell quoting from the first one:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> $a <span style="color:#f92672">=</span> $ARGV[<span style="color:#ae81ff">0</span>];
<span style="color:#66d9ef">my</span> $b <span style="color:#f92672">=</span> $a;
$a <span style="color:#f92672">+=</span> $b <span style="color:#66d9ef">while</span> $a <span style="color:#f92672">=~</span><span style="color:#e6db74"> /[^01]/</span>;
<span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;$a\n&#34;</span>
</code></pre></div><h2 id="wanderdoc1">Wanderdoc</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/wanderdoc/perl/ch-1.pl">Wanderdoc&rsquo;s solution</a> uses <code>sprintf</code> to help count in binary, and also selectively uses <code>Math::BigInt</code> when the numbers get too large for Perl&rsquo;s native integers.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">use</span> Math::BigInt;
Math::BigInt<span style="color:#f92672">-&gt;</span>accuracy(<span style="color:#ae81ff">30</span>);
<span style="color:#66d9ef">my</span> $NUM      <span style="color:#f92672">=</span> shift <span style="color:#f92672">or</span> die <span style="color:#e6db74">&#34;Which number?\n&#34;</span>;
<span style="color:#66d9ef">my</span> $FLAG_2_5 <span style="color:#f92672">=</span> ( $NUM % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span> $NUM % 5 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> ) ? <span style="color:#ae81ff">1</span> : <span style="color:#ae81ff">0</span>;

<span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i ( <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> <span style="color:#ae81ff">1_000_000_000</span> ) {
    <span style="color:#66d9ef">my</span> $multiple <span style="color:#f92672">=</span> sprintf( <span style="color:#e6db74">&#34;%b&#34;</span>, $i );
X:  <span style="color:#66d9ef">if</span> ( $FLAG_2_5 <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">and</span> substr( $multiple, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span> ) <span style="color:#f92672">eq</span> <span style="color:#e6db74">&#39;1&#39;</span> ) { <span style="color:#66d9ef">next</span>; }
    <span style="color:#66d9ef">if</span> ( length($multiple) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">17</span> ) {
        <span style="color:#66d9ef">my</span> $x      <span style="color:#f92672">=</span> Math::BigInt<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">new</span>($multiple);
        <span style="color:#66d9ef">my</span> $modulo <span style="color:#f92672">=</span> $x<span style="color:#f92672">-&gt;</span>bmod($NUM);
        <span style="color:#66d9ef">if</span> ( <span style="color:#ae81ff">0</span> <span style="color:#f92672">==</span> $modulo ) {
            <span style="color:#66d9ef">print</span> $multiple, $/;
            <span style="color:#66d9ef">last</span>;
        }
    }
    <span style="color:#66d9ef">else</span> {
        <span style="color:#66d9ef">if</span> ( <span style="color:#ae81ff">0</span> <span style="color:#f92672">==</span> $multiple % <span style="color:#960050;background-color:#1e0010">$</span>NUM ) {
            <span style="color:#66d9ef">print</span> $multiple, $/;
            <span style="color:#66d9ef">last</span>;
        }
    }
}
</code></pre></div><p>Wanderdoc also uses the <a href="https://en.wikipedia.org/wiki/Pigeonhole_principle">Pigeonhole Principle</a> to potentially avoid a costly <code>Math::BigInt</code> conversion. With the <code>X:</code> line as-is, n=99 took 13.2 seconds on my system. Commenting that line out, it only took 11.5 seconds. There is quite possibly a savings for larger numbers, that use <code>Math::BigInt</code> more heavily, but I did not have the CPU cycles to spare, so I&rsquo;ll take Wanderdoc&rsquo;s word for it. :-)</p>
<h2 id="yet-ebreo1">Yet Ebreo</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/yet-ebreo/perl/ch-1.pl">Yet Ebreo&rsquo;s solution</a> uses <code>sprintf</code> to iterate over binary numbers to quickly and concisely find the solution:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> $init <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
<span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>) {
    <span style="color:#66d9ef">my</span> $bin <span style="color:#f92672">=</span> sprintf <span style="color:#e6db74">&#34;%b&#34;</span>, $init<span style="color:#f92672">++</span>;
    ($bin % <span style="color:#960050;background-color:#1e0010">$</span>num <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">&amp;&amp;</span> (say $bin) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#66d9ef">last</span>
}
</code></pre></div><p>You know it&rsquo;s compact Perl code when the syntax highlighter gets it wrong.</p>
<hr>
<hr>
<h1 id="task2">Task #2 - LRU Cache</h1>
<p>Mohammad&rsquo;s description:</p>
<p><em>Write a script to demonstrate <strong>LRU Cache</strong> feature. It should support operations <code>get</code> and <code>set</code>. Accept the capacity of the LRU Cache as command line argument.</em></p>
<p><em>Definition of LRU: An access to an item is defined as a get or a set operation of the item. “Least recently used” item is the one with the oldest access time.</em></p>
<hr>
<p>This task, being relatively complex compared to other tasks, required more code to implement. Compared to task 1, the solutions were about 3.3 times as long, with a couple being nearly 200 lines. This is therefore one of those tasks I will have to be more selective in the code I highlight. Please do follow the links to see the full code, as many of you put a lot of effort into this one, and I really enjoyed looking at the solutions.</p>
<h2 id="solution-types">Solution types</h2>
<h3 id="doubly-linked-list">Doubly-Linked List</h3>
<p>Several solutions used some form of <a href="https://en.wikipedia.org/wiki/Linked_list">linked list</a>, although because Perl does not have a core linked list type, the underlying implementations varied.</p>
<p>Tracking the <strong>head</strong> and <strong>tail</strong> of the list is of particular importance here, because you would typically move items to the <strong>head</strong> of the list as part of a <code>set</code> or <code>get</code> operation, and expire items from the <strong>tail</strong> if the list is over its capacity.</p>
<p>It&rsquo;s possible to implement an LRU cache without maintaining <strong>head</strong> and <strong>tail</strong> references, but the operations are more expensive, as you then need to perform an O(n) scan through the list to find the end, rather than an O(1) lookup. The additional O(1) housekeeping to maintain a <strong>tail</strong> pointer is therefore well worth it for this problem.</p>
<h3 id="perl-list-builtins">Perl list builtins</h3>
<p>Many hackers chose to simply use Perl list builtins (i.e., <code>splice</code>) to move and remove elements from the cache. While this makes many operations O(n) instead of O(1) in theory, in practice when the lists are small, the extremely well optimized Perl builtins may be faster. The code is usually simpler, too.</p>
<h2 id="alicia-bielsa2">Alicia Bielsa</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/alicia-bielsa/perl/ch-2.pl">Alicia Bielsa&rsquo;s solution</a> stores everything in an <code>%hCache</code> hash, and tracks the <code>$head</code> and <code>$tail</code>. Each cache element is a hash ref with the following structure:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#75715e"># Ryan&#39;s summary</span>
$hCache{$id} <span style="color:#f92672">=</span> {
   <span style="color:#66d9ef">next</span>      <span style="color:#f92672">=&gt;</span> $next_node,
   prev      <span style="color:#f92672">=&gt;</span> $previous_node,
   value     <span style="color:#f92672">=&gt;</span> $value,  <span style="color:#75715e"># May be any scalar or ref</span>
   id        <span style="color:#f92672">=&gt;</span> $id,     <span style="color:#75715e"># Key/identifier</span>
},
</code></pre></div><p>Here are the <code>set</code> and <code>get</code> routines:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">set</span> {
    <span style="color:#66d9ef">my</span> $id <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">my</span> $value <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">if</span> (exists $hCache{$id}){
        $hCache{$id}<span style="color:#f92672">-&gt;</span>{value} <span style="color:#f92672">=</span> $value;
        moveToHead($hCache{$id});
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#66d9ef">my</span> $newNode <span style="color:#f92672">=</span> createNode($id, $value);
        $hCache{$id} <span style="color:#f92672">=</span> $newNode;
        addToHead($newNode);
        resetTail($newNode);
    }
}

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">get</span>  {
    <span style="color:#66d9ef">my</span> $id <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">if</span> (exists $hCache{$id}){
        moveToHead($hCache{$id});
        <span style="color:#66d9ef">return</span> $hCache{$id}<span style="color:#f92672">-&gt;</span>{value};
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    }
}
</code></pre></div><p>The sub <code>moveToHead</code> is an important one in Alicia&rsquo;s algorithm, as of course any element access in an LRU cache means it must move to the front (MRU end) of the list:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">moveToHead</span> {
    <span style="color:#66d9ef">my</span> $node <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">if</span> ($node <span style="color:#f92672">eq</span> $head ){
        <span style="color:#66d9ef">return</span>;
    }
    <span style="color:#66d9ef">if</span> ($node <span style="color:#f92672">eq</span> $tail ){
        resetTail($node);
    } <span style="color:#66d9ef">else</span> {
        extractNode($node);
    }
    addToHead($node);
}
</code></pre></div><p>Many of the other helper routines in Alicia&rsquo;s solution are worth looking at, as she does a really good job of factoring actions out into logical subroutines, and giving things sensible names.</p>
<h2 id="cheok-yin-fung2">Cheok-Yin Fung</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/cheok-yin-fung/perl/ch-2.pl">Cheok-Yin Fung&rsquo;s solution</a> has a doubly-linked list implementation that uses an integer array to maintain indices of <code>previous</code> and <code>coming</code> (next) list items. The <code>%cachehash</code> provides an O(1) map from key to linked list position:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> $capacity <span style="color:#f92672">=</span> $ARGV[<span style="color:#ae81ff">0</span>];
<span style="color:#66d9ef">my</span> @cacheprevious <span style="color:#f92672">=</span> ( <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> $capacity<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
<span style="color:#66d9ef">my</span> @cachecoming <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$capacity, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);    <span style="color:#75715e">#doubly-linked list</span>
<span style="color:#66d9ef">my</span> %cachehash;   <span style="color:#75715e">#cache item as key, position as value</span>
</code></pre></div><p>Here is the <code>set</code> routine, which shows off the type of logic that Cheok Yin uses throughout this solution:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">set</span> {
    $hot <span style="color:#f92672">=</span> $_[<span style="color:#ae81ff">0</span>];
    <span style="color:#66d9ef">if</span> ($L <span style="color:#f92672">&lt;</span> $capacity) {
         <span style="color:#75715e">#the subroutine laundry makes sure when $L==$capacity, $cachecoming[$L-1] = -1;</span>
        $L<span style="color:#f92672">++</span>;
        $cachehash{$_[<span style="color:#ae81ff">0</span>]} <span style="color:#f92672">=</span> $L<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">if</span> ($L <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
            $cacheprevious[$cachehash{$_[<span style="color:#ae81ff">0</span>]}] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>} <span style="color:#66d9ef">else</span> {
            $cacheprevious[$cachehash{$_[<span style="color:#ae81ff">0</span>]}] <span style="color:#f92672">=</span> $tailposition;
        }
        $tailposition <span style="color:#f92672">=</span> $L<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> ;
        $cachecoming[$cachehash{$_[<span style="color:#ae81ff">0</span>]}] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#75715e"># cache is full, get rid of the least recently used element</span>
        <span style="color:#66d9ef">foreach</span> (keys %cachehash) {
            <span style="color:#66d9ef">if</span> ( $cachehash{$_} <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
                $headposition <span style="color:#f92672">=</span> $cachecoming[$headposition];
                delete $cachehash{$_};
            } <span style="color:#66d9ef">else</span> {
                <span style="color:#66d9ef">my</span> $v <span style="color:#f92672">=</span> <span style="color:#f92672">--</span>$cachehash{$_};
                $cacheprevious[$v]<span style="color:#f92672">--</span>;
                $cachecoming[$v]<span style="color:#f92672">--</span>;
            }
        }
        $cachecoming[$tailposition] <span style="color:#f92672">=</span> $L<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
        $cachehash{$_[<span style="color:#ae81ff">0</span>]} <span style="color:#f92672">=</span> $L<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
        $cachecoming[$L<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
        $cacheprevious[$L<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> $tailposition<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
        $tailposition <span style="color:#f92672">=</span> $L<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    }
    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span>;
}
</code></pre></div><h2 id="colin-crain2">Colin Crain</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/colin-crain/perl/ch-2.pl">Colin Crain&rsquo;s solution</a> is an LRU <code>package</code> (class):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> $size <span style="color:#f92672">=</span> shift @ARGV;
<span style="color:#66d9ef">my</span> $cache <span style="color:#f92672">=</span> LRU<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">new</span>($size);

<span style="color:#66d9ef">package</span> LRU;
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">new</span> {
    <span style="color:#66d9ef">my</span> ($class, $size)  <span style="color:#f92672">=</span> @_;
    <span style="color:#66d9ef">my</span> $self    <span style="color:#f92672">=</span> { <span style="color:#e6db74">&#34;list&#34;</span>      <span style="color:#f92672">=&gt;</span> <span style="color:#f92672">[]</span>,
                    <span style="color:#e6db74">&#34;lookup&#34;</span>    <span style="color:#f92672">=&gt;</span> {},
                    <span style="color:#e6db74">&#34;size&#34;</span>     <span style="color:#f92672">=&gt;</span> $size     };
    bless $self, $class;
    <span style="color:#66d9ef">return</span> $self;
}
</code></pre></div><p>The actual list operations are carried out with <code>splice</code>, which are asymptotically slower than the O(1) linked-list operations we&rsquo;ve seen, but Perl&rsquo;s <code>splice</code> is itself quite well optimized, so for small list sizes, it is likely to compare very favourably.</p>
<p>Here is Colin&rsquo;s <code>set</code> routine:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">set</span> {
    <span style="color:#66d9ef">my</span> ($self, $label, $data) <span style="color:#f92672">=</span> @_;
    <span style="color:#75715e">## if it already exists, bump up its timestamp and update the data</span>
    <span style="color:#66d9ef">if</span> (exists $self<span style="color:#f92672">-&gt;</span>{lookup}<span style="color:#f92672">-&gt;</span>{$label} ) {
        $self<span style="color:#f92672">-&gt;</span>{lookup}<span style="color:#f92672">-&gt;</span>{$label} <span style="color:#f92672">=</span> $data;
        <span style="color:#66d9ef">my</span> $idx;
        <span style="color:#66d9ef">for</span> ( <span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>scalar $self<span style="color:#f92672">-&gt;</span>{list}<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span> ) { $idx <span style="color:#f92672">=</span> $_; <span style="color:#66d9ef">last</span> <span style="color:#66d9ef">if</span> $self<span style="color:#f92672">-&gt;</span>{list}<span style="color:#f92672">-&gt;</span>[$idx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">eq</span> $label };
        splice( $self<span style="color:#f92672">-&gt;</span>{list}<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span>, $idx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>);
        push $self<span style="color:#f92672">-&gt;</span>{list}<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span>, $label;
        say <span style="color:#e6db74">&#34;set($label, $data)   cache is now [&#34;</span>, (join <span style="color:#e6db74">&#39;, &#39;</span>,$self<span style="color:#f92672">-&gt;</span>{list}<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span>), <span style="color:#e6db74">&#39;]&#39;</span>;
        <span style="color:#66d9ef">return</span>;
    }
    <span style="color:#75715e">## else create and insert at head</span>
    $self<span style="color:#f92672">-&gt;</span>{lookup}<span style="color:#f92672">-&gt;</span>{$label} <span style="color:#f92672">=</span> $data;
    push $self<span style="color:#f92672">-&gt;</span>{list}<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span>, $label;
    <span style="color:#75715e">## delete if cache is overfilled</span>
    <span style="color:#66d9ef">if</span> (scalar $self<span style="color:#f92672">-&gt;</span>{list}<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span> <span style="color:#960050;background-color:#1e0010">&gt;</span> <span style="color:#960050;background-color:#1e0010">$</span>self<span style="color:#f92672">-&gt;</span>{size}) {
        <span style="color:#66d9ef">my</span> $deleted <span style="color:#f92672">=</span> shift $self<span style="color:#f92672">-&gt;</span>{list}<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>
        delete $self<span style="color:#f92672">-&gt;</span>{lookup}<span style="color:#f92672">-&gt;</span>{$deleted};
    }
    <span style="color:#75715e">## inspection code left in to demonstrate</span>
    say <span style="color:#e6db74">&#34;set($label, $data)   cache is now [&#34;</span>, (join <span style="color:#e6db74">&#39;, &#39;</span>,$self<span style="color:#f92672">-&gt;</span>{list}<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span>), <span style="color:#e6db74">&#39;]&#39;</span>;
}
</code></pre></div><p>When given a <code>$size</code> on the commandline, Colin&rsquo;s library performs as expected.</p>
<h2 id="dave-jacoby2">Dave Jacoby</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/dave-jacoby/perl/ch-2.pl">Dave Jacoby&rsquo;s solution</a> also provides an <code>LRU</code> package:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">package</span> LRU;
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">new</span> ( $class, $capacity = 3 ) {
    $capacity <span style="color:#f92672">=</span> int $capacity;
    croak <span style="color:#e6db74">&#39;Invalid capacity&#39;</span> <span style="color:#66d9ef">if</span> $capacity <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">my</span> $self <span style="color:#f92672">=</span> {};
    $self<span style="color:#f92672">-&gt;</span>{class}    <span style="color:#f92672">=</span> $class;
    $self<span style="color:#f92672">-&gt;</span>{cache}    <span style="color:#f92672">=</span> {};
    $self<span style="color:#f92672">-&gt;</span>{order}    <span style="color:#f92672">=</span> <span style="color:#f92672">[]</span>;
    $self<span style="color:#f92672">-&gt;</span>{capacity} <span style="color:#f92672">=</span> $capacity;
    $self<span style="color:#f92672">-&gt;</span>{max}      <span style="color:#f92672">=</span> $capacity <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">return</span> bless $self;
}
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">set</span> ( $self, $key, $value ) {
    <span style="color:#66d9ef">my</span> @array <span style="color:#f92672">=</span> grep { $_ <span style="color:#f92672">ne</span> $key } $self<span style="color:#f92672">-&gt;</span>{order}<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>
    unshift @array, $key;
    $#array              <span style="color:#f92672">=</span> $self<span style="color:#f92672">-&gt;</span>{max} <span style="color:#66d9ef">if</span> $#array <span style="color:#f92672">&gt;</span> $self<span style="color:#f92672">-&gt;</span>{max};
    $self<span style="color:#f92672">-&gt;</span>{order}<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span>   <span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#960050;background-color:#1e0010">@</span>array;
    $self<span style="color:#f92672">-&gt;</span>{cache}{$key} <span style="color:#f92672">=</span> $value;
    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $k ( keys $self<span style="color:#f92672">-&gt;</span>{cache}<span style="color:#f92672">-&gt;</span>%<span style="color:#960050;background-color:#1e0010">*</span> ) {
        <span style="color:#66d9ef">my</span> $f <span style="color:#f92672">=</span> grep { $_ <span style="color:#f92672">eq</span> $k } $self<span style="color:#f92672">-&gt;</span>{order}<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>
        delete $self<span style="color:#f92672">-&gt;</span>{cache}{$k} <span style="color:#66d9ef">if</span> $f <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> ;
    }
    $self<span style="color:#f92672">-&gt;</span>list();
}
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">get</span> ( $self, $key ) {
    <span style="color:#66d9ef">my</span> $n <span style="color:#f92672">=</span> grep { $_ <span style="color:#f92672">eq</span> $key } $self<span style="color:#f92672">-&gt;</span>{order}<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>
    my $flag <span style="color:#f92672">=</span> $n ? <span style="color:#ae81ff">1</span> : <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#66d9ef">unless</span> $flag;
    <span style="color:#66d9ef">my</span> @array <span style="color:#f92672">=</span> grep { $_ <span style="color:#f92672">ne</span> $key } $self<span style="color:#f92672">-&gt;</span>{order}<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>
    unshift @array, $key;
    $#array <span style="color:#f92672">=</span> $self<span style="color:#f92672">-&gt;</span>{max} <span style="color:#66d9ef">if</span> $#array <span style="color:#f92672">&gt;</span> $self<span style="color:#f92672">-&gt;</span>{max};
    $self<span style="color:#f92672">-&gt;</span>{order}<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span> <span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#960050;background-color:#1e0010">@</span>array;
    $self<span style="color:#f92672">-&gt;</span>list();
    <span style="color:#66d9ef">return</span> $self<span style="color:#f92672">-&gt;</span>{cache}{$key};
}
</code></pre></div><p>Dave&rsquo;s code also uses Perl&rsquo;s list builtins, rather than a linked list. This does help make the code somewhat more concise.</p>
<h2 id="duane-powell2">Duane Powell</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/duane-powell/perl/ch-2.pl">Duane Powell&rsquo;s solution</a> defines an <code>LRU_Cache</code> package, and uses a linked list for the underlying representation of the cache. I&rsquo;ll show the <code>set</code> routine:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">set</span> {
    <span style="color:#66d9ef">my</span> $self <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">my</span> $curr <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">my</span> $data <span style="color:#f92672">=</span> shift;
    <span style="color:#75715e"># Count how many times we&#39;ve been called</span>
    $self<span style="color:#f92672">-&gt;</span>{set}<span style="color:#f92672">++</span>;
    <span style="color:#75715e"># On first call the vars head, current and tail are all the same</span>
    <span style="color:#66d9ef">if</span> ( $self<span style="color:#f92672">-&gt;</span>{set} <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> ) {
        $self<span style="color:#f92672">-&gt;</span>{tail} <span style="color:#f92672">=</span> $curr;
        $self<span style="color:#f92672">-&gt;</span>{head} <span style="color:#f92672">=</span> $curr;
    }
    <span style="color:#75715e"># Try to get data before setting data.</span>
    <span style="color:#75715e"># As written cache values can not be changed, they</span>
    <span style="color:#75715e"># must be evicted and then re-set</span>
    <span style="color:#66d9ef">if</span> ( $self<span style="color:#f92672">-&gt;</span>get($curr, SILENT) <span style="color:#f92672">eq</span> EVICTED) {
        <span style="color:#75715e"># Generate new node, set it as the head.</span>
        <span style="color:#75715e"># Update caches internal pointers.</span>
        <span style="color:#66d9ef">my</span> $node <span style="color:#f92672">=</span> $self<span style="color:#f92672">-&gt;</span>node_generate($data);
        <span style="color:#66d9ef">my</span> $old_head <span style="color:#f92672">=</span> $self<span style="color:#f92672">-&gt;</span>{head};
        <span style="color:#66d9ef">my</span> $new_head <span style="color:#f92672">=</span> $curr;
        $self<span style="color:#f92672">-&gt;</span>{cache}{$old_head}{prev} <span style="color:#f92672">=</span> $new_head;
        $self<span style="color:#f92672">-&gt;</span>{cache}{$new_head} <span style="color:#f92672">=</span> $node;
        $self<span style="color:#f92672">-&gt;</span>{cache}{$new_head}{<span style="color:#66d9ef">next</span>} <span style="color:#f92672">=</span> $old_head;
        $self<span style="color:#f92672">-&gt;</span>{head} <span style="color:#f92672">=</span> $new_head;
        <span style="color:#75715e"># If the cache is full set new tail and evict old tail</span>
        <span style="color:#66d9ef">if</span> ($self<span style="color:#f92672">-&gt;</span>{set} <span style="color:#f92672">&gt;</span> $self<span style="color:#f92672">-&gt;</span>{cap}) {
            <span style="color:#66d9ef">my</span> $old_tail  <span style="color:#f92672">=</span> $self<span style="color:#f92672">-&gt;</span>{tail};
            $self<span style="color:#f92672">-&gt;</span>{tail} <span style="color:#f92672">=</span> $self<span style="color:#f92672">-&gt;</span>{cache}{$old_tail}{prev};
            delete $self<span style="color:#f92672">-&gt;</span>{cache}{$old_tail};
        }
    }
    say <span style="color:#e6db74">&#34;set($curr,$data)&#34;</span> <span style="color:#66d9ef">if</span> ($self<span style="color:#f92672">-&gt;</span>{verb});
    <span style="color:#66d9ef">return</span> $data;
}
</code></pre></div><p>This demonstrates the core logic in Duane&rsquo;s solution pretty well, I think.  This task is almost a study in edge cases, and Duane does a good job in catching them all.</p>
<h2 id="duncan-c-white2">Duncan C. White</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/duncan-c-white/perl/ch-2.pl">Duncan C. White&rsquo;s solution</a> uses Perl&rsquo;s list builtins for a concise solution:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">use</span> Function::Parameters;
fun get( $key ) {
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#66d9ef">unless</span> exists $cache{$key};
    <span style="color:#66d9ef">my</span> $x <span style="color:#f92672">=</span> $cache{$key};
    @keysused <span style="color:#f92672">=</span> grep { $_ <span style="color:#f92672">!=</span> $key } @keysused;
    unshift @keysused, $key;
    say <span style="color:#e6db74">&#34;debug: keysused = &#34;</span>, join(<span style="color:#e6db74">&#39;,&#39;</span>,@keysused);
    <span style="color:#66d9ef">return</span> $x;
}

fun set( $key, $value ) {
    @keysused <span style="color:#f92672">=</span> grep { $_ <span style="color:#f92672">!=</span> $key } @keysused;
    unshift @keysused, $key;
    $cache{$key} <span style="color:#f92672">=</span> $value;
    <span style="color:#66d9ef">if</span>( @keysused <span style="color:#f92672">&gt;</span> $capacity ) {
        <span style="color:#66d9ef">my</span> $leastusedkey <span style="color:#f92672">=</span> pop @keysused;
        delete $cache{$leastusedkey};
    }
    say <span style="color:#e6db74">&#34;debug: keysused = &#34;</span>, join(<span style="color:#e6db74">&#39;,&#39;</span>,@keysused);
}
</code></pre></div><h2 id="e-choroba2">E. Choroba</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/e-choroba/perl/ch-2.pl">E. Choroba&rsquo;s solution</a> is written in his usual concise style, using Perl list builtins:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#75715e">#!/usr/bin/perl</span>
{   <span style="color:#66d9ef">package</span> Cache::LRU;
    <span style="color:#66d9ef">use</span> enum <span style="color:#e6db74">qw( CAPACITY HASH ARRAY )</span>;
    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">new</span> {
        <span style="color:#66d9ef">my</span> ($class, $capacity) <span style="color:#f92672">=</span> @_;
        bless [$capacity, {}, <span style="color:#f92672">[]</span>], $class
    }
    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">capacity</span> { $_[<span style="color:#ae81ff">0</span>][CAPACITY] }
    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">_value</span> { $_[<span style="color:#ae81ff">0</span>][HASH]{ $_[<span style="color:#ae81ff">1</span>] } }
    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">_move_to_start</span> {
        <span style="color:#66d9ef">my</span> ($self, $key) <span style="color:#f92672">=</span> @_;
        @{ $self<span style="color:#f92672">-&gt;</span>[ARRAY] } <span style="color:#f92672">=</span> ($key, grep $_ <span style="color:#f92672">ne</span> $key, @{ $self<span style="color:#f92672">-&gt;</span>[ARRAY] });
    }
    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">get</span> {
        <span style="color:#66d9ef">my</span> ($self, $key) <span style="color:#f92672">=</span> @_;
        <span style="color:#66d9ef">return</span> undef <span style="color:#66d9ef">unless</span> exists $self<span style="color:#f92672">-&gt;</span>[HASH]{$key};
        $self<span style="color:#f92672">-&gt;</span>_move_to_start($key);
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">\</span>$self<span style="color:#f92672">-&gt;</span>_value($key)
    }
    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">set</span> {
        <span style="color:#66d9ef">my</span> ($self, $key, $value) <span style="color:#f92672">=</span> @_;
        $self<span style="color:#f92672">-&gt;</span>[HASH]{$key} <span style="color:#f92672">=</span> $value <span style="color:#66d9ef">if</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">==</span> @_;
        $self<span style="color:#f92672">-&gt;</span>_move_to_start($key);
        delete $self<span style="color:#f92672">-&gt;</span>[HASH]{ pop @{ $self<span style="color:#f92672">-&gt;</span>[ARRAY] } }
            <span style="color:#66d9ef">if</span> @{ $self<span style="color:#f92672">-&gt;</span>[ARRAY] } <span style="color:#f92672">&gt;</span> $self<span style="color:#f92672">-&gt;</span>capacity;
    }
    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">inspect</span> {
        [reverse @{ $_[<span style="color:#ae81ff">0</span>][ARRAY] }]
    }
}
</code></pre></div><p>Factoring out things like <code>_move_to_start</code> is smart; even though it&rsquo;s just a one-line function, it&rsquo;s usually wise to avoid repetition, especially if you can clarify your intent with a good self-documenting name like <code>_move_to_start</code>.</p>
<p><strong>Blog</strong> › <a href="http://blogs.perl.org/users/e_choroba/2020/03/perl-weekly-challenge-048-smallest-multiple-and-lru-cache.html">Perl Weekly Challenge 049: Smallest Multiple and LRU Cache | E. Choroba [blogs.perl.org]</a></p>
<h2 id="ianrifkin2">Ian Rifkin</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/ianrifkin/perl/ch-2.pl">Ian Rifkin&rsquo;s solution</a> takes a much different approach. Ian basically built a REPL loop for his LRU cache using <code>Term::Prompt</code> and one big monolithic <code>while(1) { ... }</code> loop (Ian did mention he had planned to factor out more code into subroutines).</p>
<p>Here is the <code>get</code> operation:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">if</span> ( $action <span style="color:#f92672">eq</span> <span style="color:#e6db74">&#39;get&#39;</span> ) {
        <span style="color:#66d9ef">my</span> $item_key <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>prompt( <span style="color:#e6db74">&#39;x&#39;</span>, <span style="color:#e6db74">&#34;Input item key to get&#34;</span>, <span style="color:#e6db74">&#39;&#39;</span> );
        <span style="color:#66d9ef">if</span> ( defined $lru_map{$item_key} ) {
            say <span style="color:#e6db74">&#34;Data from cache for key $item_key:&#34;</span>;
            say $lru_map{$item_key}{<span style="color:#e6db74">&#39;data&#39;</span>};
            $lru_map{$head}{<span style="color:#e6db74">&#39;prev&#39;</span>} <span style="color:#f92672">=</span>
              $item_key;    <span style="color:#75715e">#set outgoing first item&#39;s prev to new first item</span>
            $lru_map{$item_key}{<span style="color:#e6db74">&#39;next&#39;</span>} <span style="color:#f92672">=</span>
              $head;        <span style="color:#75715e">#set new item&#39;s &#39;next&#39; to outgoing head</span>
            $head <span style="color:#f92672">=</span> $item_key;    <span style="color:#75715e">#Update head to current item key</span>
            $lru_map{$item_key}{<span style="color:#e6db74">&#39;prev&#39;</span>} <span style="color:#f92672">=</span> undef;   <span style="color:#75715e">#no prev since first in cache</span>
            <span style="color:#66d9ef">if</span> ( $tail <span style="color:#f92672">eq</span> $head ) {    <span style="color:#75715e">#if the new head was the old tail</span>
                $tail <span style="color:#f92672">=</span> $lru_map{$tail}{<span style="color:#e6db74">&#39;next&#39;</span>};    <span style="color:#75715e">#set tail to new last item</span>
            }
        }
        <span style="color:#66d9ef">else</span> {
            say <span style="color:#e6db74">&#34;Item $item_key not currently in cache. Maybe you want to set it?&#34;</span>;
        }
    }
</code></pre></div><p>And here is <code>set</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">elsif</span> ( $action <span style="color:#f92672">eq</span> <span style="color:#e6db74">&#39;set&#39;</span> ) {
        <span style="color:#66d9ef">my</span> $item_key <span style="color:#f92672">=</span>
          <span style="color:#f92672">&amp;</span>prompt( <span style="color:#e6db74">&#39;x&#39;</span>, <span style="color:#e6db74">&#34;Input key of new item to add to the cache&#34;</span>, <span style="color:#e6db74">&#39;&#39;</span> );
        <span style="color:#66d9ef">my</span> $item_data <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>prompt( <span style="color:#e6db74">&#39;x&#39;</span>, <span style="color:#e6db74">&#34;Input item to add to cache&#34;</span>, <span style="color:#e6db74">&#39;&#39;</span> );
        $lru_map{$item_key} <span style="color:#f92672">=</span> {};
        <span style="color:#66d9ef">if</span> ($head) {
            $lru_map{$head}{<span style="color:#e6db74">&#39;prev&#39;</span>} <span style="color:#f92672">=</span>
              $item_key;    <span style="color:#75715e">#set outgoing head&#39;s prev to current item</span>
            $lru_map{$item_key}{<span style="color:#e6db74">&#39;next&#39;</span>} <span style="color:#f92672">=</span>
              $head;        <span style="color:#75715e">#set new item&#39;s &#39;next&#39; to outgoing head</span>
        }
        $head <span style="color:#f92672">=</span> $item_key;    <span style="color:#75715e">#set new item as head</span>
        $tail <span style="color:#f92672">=</span> $item_key
          <span style="color:#66d9ef">unless</span> $tail;       <span style="color:#75715e">#set tail if no tail yet AKA 1st in cache</span>
        <span style="color:#66d9ef">my</span> $size <span style="color:#f92672">=</span> keys %lru_map;
        $size<span style="color:#f92672">--</span>;                     <span style="color:#75715e">#don&#39;t count item being currently added</span>
        <span style="color:#66d9ef">if</span> ( $size <span style="color:#f92672">&gt;</span> $max_cap ) {    <span style="color:#75715e">#if this new item can&#39;t fit in cache</span>
            $tail <span style="color:#f92672">=</span> $lru_map{$tail}{<span style="color:#e6db74">&#39;prev&#39;</span>};    <span style="color:#75715e">#set new tail</span>
            delete $lru_map{ $lru_map{$tail}{<span style="color:#e6db74">&#39;next&#39;</span>} }
              ;                                 <span style="color:#75715e">#delete last item in cache</span>
            delete $lru_map{$tail}{<span style="color:#e6db74">&#39;next&#39;</span>}
              ;    <span style="color:#75715e">#delete new last item&#39;s next since it&#39;s now last</span>
        }
        $lru_map{$item_key}{<span style="color:#e6db74">&#39;data&#39;</span>} <span style="color:#f92672">=</span> $item_data;  <span style="color:#75715e">#load actual cache</span>
        $lru_map{$item_key}{<span style="color:#e6db74">&#39;prev&#39;</span>} <span style="color:#f92672">=</span> undef;       <span style="color:#75715e">#no prev since first in cache</span>
        <span style="color:#66d9ef">next</span>;
    }
</code></pre></div><p>Ian&rsquo;s linked list implementation looks fairly solid to me, including maintaining the head and tail elements to avoid the need to scan the list.</p>
<h2 id="javier-luque2">Javier Luque</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/javier-luque/perl/ch-2.pl">Javier Luque&rsquo;s solution</a> uses <a href="https://metacpan.org/pod/Mouse"><code>Mouse</code></a> for OO. I&rsquo;m a huge fan of <code>Mouse</code>, having used it in plenty of real-world code myself.</p>
<p>Javier&rsquo;s design includes a <code>Cache::LRU</code> class that uses <code>LL::Node</code> linked list objects as its elements. Each <code>LL::Node</code> has a <code>key</code> and a <code>value</code>, plus <code>next</code> and <code>prev</code> <code>LL::Node</code> references.</p>
<p>The <code>Cache::LRU</code> <code>get</code> and <code>set</code> subs are as follows:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">set</span> {
    <span style="color:#66d9ef">my</span> ($self, $key, $value) <span style="color:#f92672">=</span> @_;
    <span style="color:#75715e"># New node</span>
    <span style="color:#66d9ef">my</span> $new_node <span style="color:#f92672">=</span> LL::Node<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">new</span>(
        key <span style="color:#f92672">=&gt;</span> $key, value <span style="color:#f92672">=&gt;</span> $value
    );
    <span style="color:#75715e"># Push out 1 if at capacity</span>
    <span style="color:#66d9ef">if</span> ($self<span style="color:#f92672">-&gt;</span>capacity <span style="color:#f92672">&gt;=</span> $self<span style="color:#f92672">-&gt;</span>max_capacity) {
        <span style="color:#66d9ef">my</span> $node_to_kill <span style="color:#f92672">=</span> $self<span style="color:#f92672">-&gt;</span>first;
        $self<span style="color:#f92672">-&gt;</span>first($self<span style="color:#f92672">-&gt;</span>first<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">next</span>);
        delete $self<span style="color:#f92672">-&gt;</span>positions<span style="color:#f92672">-&gt;</span>{$node_to_kill<span style="color:#f92672">-&gt;</span>key};
        $self<span style="color:#f92672">-&gt;</span>capacity($self<span style="color:#f92672">-&gt;</span>capacity <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
    }
    <span style="color:#75715e"># Set the first and last reference to the new node</span>
    <span style="color:#66d9ef">if</span> ( $self<span style="color:#f92672">-&gt;</span>first ) {
        $self<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">last</span><span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">next</span>($new_node);
        $new_node<span style="color:#f92672">-&gt;</span>prev($self<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">last</span>);
    } <span style="color:#66d9ef">else</span> {
        $self<span style="color:#f92672">-&gt;</span>first($new_node);
    }
    $self<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">last</span>($new_node);
    $self<span style="color:#f92672">-&gt;</span>positions<span style="color:#f92672">-&gt;</span>{$key} <span style="color:#f92672">=</span> $new_node;
    $self<span style="color:#f92672">-&gt;</span>capacity($self<span style="color:#f92672">-&gt;</span>capacity <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
    say <span style="color:#e6db74">&#34;Setting: ($key, $value)&#34;</span> <span style="color:#f92672">.</span> $self<span style="color:#f92672">-&gt;</span>show_nodes;
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">get</span> {
    <span style="color:#66d9ef">my</span> ($self, $key) <span style="color:#f92672">=</span> @_;
    <span style="color:#66d9ef">my</span> $node <span style="color:#f92672">=</span> $self<span style="color:#f92672">-&gt;</span>positions<span style="color:#f92672">-&gt;</span>{$key};
    <span style="color:#75715e"># Cache miss</span>
    <span style="color:#66d9ef">unless</span> ($node) {
        say <span style="color:#e6db74">&#34;Getting: ($key) - cache miss&#34;</span> <span style="color:#f92672">.</span>
            $self<span style="color:#f92672">-&gt;</span>show_nodes;
        <span style="color:#75715e"># Return the cache miss -1</span>
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    }
    <span style="color:#75715e"># This might be the first node</span>
    <span style="color:#66d9ef">if</span> ($node<span style="color:#f92672">-&gt;</span>prev) {
        $node<span style="color:#f92672">-&gt;</span>prev<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">next</span>($node<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">next</span>)
    } <span style="color:#66d9ef">else</span> {
        $self<span style="color:#f92672">-&gt;</span>first($node<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">next</span>);
    }
    $node<span style="color:#f92672">-&gt;</span>prev($self<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">last</span>);
    $self<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">last</span><span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">next</span>($node);
    $node<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">next</span>(undef);
    $self<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">last</span>($node);
    <span style="color:#66d9ef">my</span> $value <span style="color:#f92672">=</span> $node<span style="color:#f92672">-&gt;</span>value;
    say <span style="color:#e6db74">&#34;Getting: ($key) Value: $value)&#34;</span> <span style="color:#f92672">.</span> $self<span style="color:#f92672">-&gt;</span>show_nodes;
    <span style="color:#66d9ef">return</span> $node<span style="color:#f92672">-&gt;</span>value;
}
</code></pre></div><p><strong>Blog</strong> › <a href="https://perlchallenges.wordpress.com/2020/02/28/perl-weekly-challenge-049/">049 Perl Weekly Challenge</a></p>
<h2 id="laurent-rosenfeld2">Laurent Rosenfeld</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/laurent-rosenfeld/perl/ch-2.pl">Laurent Rosenfeld&rsquo;s solution</a> is functional. It begins with a call to <code>create_lru</code>, which is a closure around the state (<code>%cache</code> and <code>@order</code>, for a Perl list builtin underlying representation). <code>create_lru</code> returns two subroutine references: the <code>$getter</code> and the <code>$setter</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">create_lru</span> {
    <span style="color:#66d9ef">my</span> $capacity <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">my</span> (%cache, @order);
    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">display</span> { say <span style="color:#e6db74">&#34;Order: @{$_[0]} \n&#34;</span>, <span style="color:#e6db74">&#34;Cache: &#34;</span>, Dumper $_[<span style="color:#ae81ff">1</span>];}
    <span style="color:#66d9ef">my</span> $setter <span style="color:#f92672">=</span> <span style="color:#66d9ef">sub</span> {
        <span style="color:#66d9ef">my</span> ($key, $val) <span style="color:#f92672">=</span> @_;
        $cache{$key} <span style="color:#f92672">=</span> $val;
        push @order, $key;
        <span style="color:#66d9ef">if</span> (@order <span style="color:#f92672">&gt;</span> $capacity) {
            <span style="color:#66d9ef">my</span> $invalid <span style="color:#f92672">=</span> shift @order;
            delete $cache{$invalid};
        }
        display <span style="color:#f92672">\</span>@order, <span style="color:#f92672">\</span>%cache;
    };
    <span style="color:#66d9ef">my</span> $getter <span style="color:#f92672">=</span> <span style="color:#66d9ef">sub</span> {
        <span style="color:#66d9ef">my</span> $key <span style="color:#f92672">=</span> shift;
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#66d9ef">unless</span> exists $cache{$key};
        @order <span style="color:#f92672">=</span> grep { $_ <span style="color:#f92672">!=</span> $key } @order;
        push @order, $key;
        display <span style="color:#f92672">\</span>@order, <span style="color:#f92672">\</span>%cache;
        <span style="color:#66d9ef">return</span> $cache{$key}
    };
    <span style="color:#66d9ef">return</span> $setter, $getter;
}
</code></pre></div><p>These then work like any other sub refs, but both references act on the common state created by the initial call to <code>create_lru</code> (meaning, you could have multiple caches if you wanted, just as with the OO solutions):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> ($set, $get) <span style="color:#f92672">=</span> create_lru(<span style="color:#ae81ff">3</span>);
$set<span style="color:#f92672">-&gt;</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>);
$set<span style="color:#f92672">-&gt;</span>(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">5</span>);
$set<span style="color:#f92672">-&gt;</span>(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">7</span>);
say <span style="color:#e6db74">&#34;should print  5: &#34;</span>, $get<span style="color:#f92672">-&gt;</span>(<span style="color:#ae81ff">2</span>);
say <span style="color:#e6db74">&#34;should print  3: &#34;</span>, $get<span style="color:#f92672">-&gt;</span>(<span style="color:#ae81ff">1</span>);
say <span style="color:#e6db74">&#34;should print -1: &#34;</span>, $get<span style="color:#f92672">-&gt;</span>(<span style="color:#ae81ff">4</span>);
$set<span style="color:#f92672">-&gt;</span>(<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">9</span>);
say <span style="color:#e6db74">&#34;should print -1: &#34;</span>, $get<span style="color:#f92672">-&gt;</span>(<span style="color:#ae81ff">3</span>);
</code></pre></div><p>It&rsquo;s a different and fun way to do it (these were Laurent&rsquo;s stated design motivations, which I wholeheartedly agree with!). If you aren&rsquo;t familiar with functional programming, this is a great example to rip apart to figure out how it works.</p>
<p><strong>Blog</strong> › <a href="http://blogs.perl.org/users/laurent_r/2020/02/perl-weekly-challenge-smallest-multiple-and-lru-cache.html">Smallest Multiple and LRU Cache</a></p>
<h2 id="lubos-kolouch2">Lubos Kolouch</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/lubos-kolouch/perl/ch-2.pl">Lubos Kolouch&rsquo;s solution</a> uses the <a href="https://metacpan.org/pod/Cache::LRU"><code>Cache::LRU</code></a> CPAN package:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">use</span> Cache::LRU;
<span style="color:#66d9ef">my</span> $size <span style="color:#f92672">=</span> $ARGV[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">or</span> die <span style="color:#e6db74">&#39;Usage: script size&#39;</span>;
<span style="color:#66d9ef">my</span> $cache <span style="color:#f92672">=</span> Cache::LRU<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">new</span>(
    size <span style="color:#f92672">=&gt;</span> $size
);
<span style="color:#66d9ef">use</span> Test::More;
$cache<span style="color:#f92672">-&gt;</span>set(<span style="color:#ae81ff">1</span><span style="color:#f92672">=&gt;</span><span style="color:#ae81ff">3</span>);
$cache<span style="color:#f92672">-&gt;</span>set(<span style="color:#ae81ff">2</span><span style="color:#f92672">=&gt;</span><span style="color:#ae81ff">5</span>);
$cache<span style="color:#f92672">-&gt;</span>set(<span style="color:#ae81ff">3</span><span style="color:#f92672">=&gt;</span><span style="color:#ae81ff">7</span>);
is($cache<span style="color:#f92672">-&gt;</span>get(<span style="color:#ae81ff">2</span>),<span style="color:#ae81ff">5</span>);
is($cache<span style="color:#f92672">-&gt;</span>get(<span style="color:#ae81ff">1</span>),<span style="color:#ae81ff">3</span>);
is($cache<span style="color:#f92672">-&gt;</span>get(<span style="color:#ae81ff">4</span>),undef);
$cache<span style="color:#f92672">-&gt;</span>set(<span style="color:#ae81ff">4</span><span style="color:#f92672">=&gt;</span><span style="color:#ae81ff">9</span>);
is($cache<span style="color:#f92672">-&gt;</span>get(<span style="color:#ae81ff">3</span>),undef);
</code></pre></div><h2 id="mohammad-anwar2">Mohammad S Anwar</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/mohammad-anwar/perl/ch-2.pl">Mohammad S Anwar&rsquo;s solution</a> also uses <code>Cache::LRU</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">use</span> Cache::LRU;
<span style="color:#66d9ef">my</span> $cache <span style="color:#f92672">=</span> Cache::LRU<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">new</span>(size <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">3</span>);
$cache<span style="color:#f92672">-&gt;</span>set(<span style="color:#ae81ff">1</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">3</span>);
$cache<span style="color:#f92672">-&gt;</span>set(<span style="color:#ae81ff">2</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">5</span>);
$cache<span style="color:#f92672">-&gt;</span>set(<span style="color:#ae81ff">3</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">7</span>);
<span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;get(2) =&gt; &#34;</span>, $cache<span style="color:#f92672">-&gt;</span>get(<span style="color:#ae81ff">2</span>), <span style="color:#e6db74">&#34;\n&#34;</span>;
<span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;get(1) =&gt; &#34;</span>, $cache<span style="color:#f92672">-&gt;</span>get(<span style="color:#ae81ff">1</span>), <span style="color:#e6db74">&#34;\n&#34;</span>;
<span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;get(4) =&gt; &#34;</span>, $cache<span style="color:#f92672">-&gt;</span>get(<span style="color:#ae81ff">4</span>)<span style="color:#f92672">||-</span><span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;\n&#34;</span>;
$cache<span style="color:#f92672">-&gt;</span>set(<span style="color:#ae81ff">4</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">9</span>);
<span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;get(3) =&gt; &#34;</span>, $cache<span style="color:#f92672">-&gt;</span>get(<span style="color:#ae81ff">3</span>)<span style="color:#f92672">||-</span><span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;\n&#34;</span>;
</code></pre></div><p><strong>Blog</strong> › <a href="https://perlweeklychallenge.org/blog/weekly-challenge-049">BLOG: The Weekly Challenge #049</a></p>
<h2 id="roger-bell-west2">Roger Bell West</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/roger-bell-west/perl/ch-2.pl">Roger Bell West&rsquo;s solution</a> defines a <code>Local::LRU</code> package:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">package</span> Local::LRU;

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">new</span> {
    <span style="color:#66d9ef">my</span> $class <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">my</span> $self  <span style="color:#f92672">=</span> {};
    $self<span style="color:#f92672">-&gt;</span>{size}  <span style="color:#f92672">=</span> shift <span style="color:#f92672">||</span> <span style="color:#ae81ff">3</span>;
    $self<span style="color:#f92672">-&gt;</span>{store} <span style="color:#f92672">=</span> {};
    $self<span style="color:#f92672">-&gt;</span>{lru}   <span style="color:#f92672">=</span> <span style="color:#f92672">[]</span>;
    bless $self, $class;
    <span style="color:#66d9ef">return</span> $self;
}
</code></pre></div><p><code>set</code> and <code>get</code> are nice and short, thanks to using Perl list builtins:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">set</span> {
    <span style="color:#66d9ef">my</span> $self <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">my</span> $k    <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">my</span> $v    <span style="color:#f92672">=</span> shift;
    $self<span style="color:#f92672">-&gt;</span>{store}{$k} <span style="color:#f92672">=</span> $v;
    $self<span style="color:#f92672">-&gt;</span>update_lru($k);
    <span style="color:#66d9ef">if</span> ( scalar @{ $self<span style="color:#f92672">-&gt;</span>{lru} } <span style="color:#f92672">&gt;</span> $self<span style="color:#f92672">-&gt;</span>{size} ) {
        delete $self<span style="color:#f92672">-&gt;</span>{store}{ $self<span style="color:#f92672">-&gt;</span>{lru}[<span style="color:#ae81ff">0</span>] };
        shift @{ $self<span style="color:#f92672">-&gt;</span>{lru} };
    }
}

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">get</span> {
    <span style="color:#66d9ef">my</span> $self <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">my</span> $k    <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">if</span> ( exists $self<span style="color:#f92672">-&gt;</span>{store}{$k} ) {
        $self<span style="color:#f92672">-&gt;</span>update_lru($k);
        <span style="color:#66d9ef">return</span> $self<span style="color:#f92672">-&gt;</span>{store}{$k};
    }
    <span style="color:#66d9ef">else</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    }
}

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">update_lru</span> {
    <span style="color:#66d9ef">my</span> $self <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">my</span> $k    <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">my</span> @l    <span style="color:#f92672">=</span> grep { $_ <span style="color:#f92672">!=</span> $k } @{ $self<span style="color:#f92672">-&gt;</span>{lru} };
    push @l, $k;
    @{ $self<span style="color:#f92672">-&gt;</span>{lru} } <span style="color:#f92672">=</span> @l;
}
</code></pre></div><p>Factoring out <code>update_lru</code> was a good decision.</p>
<h2 id="ruben-westerberg2">Ruben Westerberg</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/ruben-westerberg/perl/ch-2.pl">Ruben Westerberg&rsquo;s solution</a> uses a <code>given</code>..<code>when</code> block to handle the different commands:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">given ($cmd) {
    when ($GET_CMD) {
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;\nRead Cache: &#34;</span>;
        <span style="color:#66d9ef">do</span> {
            given ( $index{$index} ) {
                when (undef) {
                    <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;-Miss\n&#34;</span>;

                    <span style="color:#75715e">#cache miss</span>
                    <span style="color:#66d9ef">my</span> $val <span style="color:#f92672">=</span> largeSlowStore( $GET_CMD, $index );
                    fastSmallCache( $UPDATE_CMD, $index, $val )
                      <span style="color:#66d9ef">if</span> defined $val;
                }
                default {
                    <span style="color:#75715e">#cache hit</span>
                    <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;-Hit\n&#34;</span>;
                    fastSmallCache( $UPDATE_CMD, $index, $_ );
                }
            }
        }
    }
    when ($SET_CMD) {
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;\nWrite cache: \n&#34;</span>;
        fastSmallCache( $UPDATE_CMD, $index, $value );
    }
    when ($UPDATE_CMD) {
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;Updating cache: $index =&gt;  $value\n&#34;</span>;
        <span style="color:#66d9ef">my</span> ($k) <span style="color:#f92672">=</span> grep { $lru[$_] <span style="color:#f92672">==</span> $index } <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> @lru <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">my</span> $tmp;
        $tmp <span style="color:#f92672">=</span> splice @lru, $k, <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">if</span> defined $k;

        <span style="color:#75715e">#print &#34;cached pre key: $tmp\n&#34;;</span>
        <span style="color:#66d9ef">my</span> $del <span style="color:#f92672">=</span> shift @lru <span style="color:#66d9ef">unless</span> @lru <span style="color:#f92672">&lt;</span> $capacity;
        <span style="color:#66d9ef">if</span> ( defined $del ) {
            <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;Cache overflow\n&#34;</span>;
            largeSlowStore( $SET_CMD, $del, $index{$del} );
            delete $index{$del};
        }
        push @lru, $index;
        $index{$index} <span style="color:#f92672">=</span> $value;
    }
}
</code></pre></div><p>Under the hood, Ruben uses Perl list builtins (<code>splice</code>, etc.) to maintain the internal list.</p>
<h2 id="ryan-thompson2">Ryan Thompson</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/ryan-thompson/perl/ch-2.pl">My solution</a> is another linked list OO implementation. My class, <code>Local::LRU</code>, supports <code>get</code>, <code>set</code>, and a few others, like <code>capacity</code>, which allows the capacity to be changed after the cache exists. Here are the <code>get</code> and <code>set</code> operations:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">set</span> {
    <span style="color:#66d9ef">my</span> ($s, $key, $val) <span style="color:#f92672">=</span> @_;
    $s<span style="color:#f92672">-&gt;</span>evict($key) <span style="color:#66d9ef">if</span> $s<span style="color:#f92672">-&gt;</span>exists($key);
    <span style="color:#66d9ef">my</span> $elem <span style="color:#f92672">=</span> { key <span style="color:#f92672">=&gt;</span> $key, val <span style="color:#f92672">=&gt;</span> $val, <span style="color:#66d9ef">next</span> <span style="color:#f92672">=&gt;</span> $s<span style="color:#f92672">-&gt;</span>{_head} };
    $s<span style="color:#f92672">-&gt;</span>{_cache}{$key} <span style="color:#f92672">=</span> $elem;
    $s<span style="color:#f92672">-&gt;</span>{_head} <span style="color:#f92672">and</span> $s<span style="color:#f92672">-&gt;</span>{_head}{prev} <span style="color:#f92672">=</span> $elem;
    $s<span style="color:#f92672">-&gt;</span>{_tail} <span style="color:#e6db74">//</span><span style="color:#f92672">=</span> $elem;
    $s<span style="color:#f92672">-&gt;</span>{_head} <span style="color:#f92672">=</span> $elem;
    $s<span style="color:#f92672">-&gt;</span>{_length}<span style="color:#f92672">++</span>;
    $s<span style="color:#f92672">-&gt;</span>_expire;
    $val;
}

<span style="color:#75715e"># Get an item named $key, or croak</span>
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">get</span> {
    <span style="color:#66d9ef">my</span> ($s, $key) <span style="color:#f92672">=</span> @_;
    croak <span style="color:#e6db74">&#34;$key does not exist&#34;</span> <span style="color:#66d9ef">unless</span> $s<span style="color:#f92672">-&gt;</span>exists($key);
    <span style="color:#66d9ef">my</span> $val <span style="color:#f92672">=</span> $s<span style="color:#f92672">-&gt;</span>{_cache}{$key}{val};
    $s<span style="color:#f92672">-&gt;</span>set($key, $val);
}
</code></pre></div><p>As you can see, a <code>get</code> is basically a <code>set</code>, since the item needs to be promoted to the head of the list regardless, so I just call <code>set</code>.</p>
<p><strong>Blog</strong> › <a href="http://www.ry.ca/2020/03/lru-cache/">LRU Cache</a></p>
<h2 id="saiftynet2">Saif Ahmed</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/saiftynet/perl/ch-2.pl">Saif Ahmed&rsquo;s solution</a> is another REPL &ldquo;shell&rdquo;. Saif sets up a dispatch table to define the allowed operations (the <code>re</code> regexps are there only to extract parameters):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> %dispatch<span style="color:#f92672">=</span>(
  set     <span style="color:#f92672">=&gt;</span>{   <span style="color:#75715e"># set (key,value) or set key,value: sets a key with a value</span>
    re      <span style="color:#f92672">=&gt;</span><span style="color:#e6db74">&#39;\s*\(?\s*\b(.+)\b\s*,\s*\b(.+)\b\s*\)?&#39;</span>,
    action <span style="color:#f92672">=&gt;</span>sub{<span style="color:#66d9ef">my</span> ($p1,$p2)<span style="color:#f92672">=</span>@_;set($p1,$p2)},
  },
  get     <span style="color:#f92672">=&gt;</span>{   <span style="color:#75715e"># get (key) or get key : gets key value</span>
    re      <span style="color:#f92672">=&gt;</span><span style="color:#e6db74">&#39;\s*\(?\s*\b(.+)\b\s*\)?&#39;</span>,
    action  <span style="color:#f92672">=&gt;</span>sub{<span style="color:#66d9ef">my</span> ($p1)<span style="color:#f92672">=</span>@_;<span style="color:#66d9ef">print</span> get($p1),<span style="color:#e6db74">&#34;\n&#34;</span>;},
  },
  cache   <span style="color:#f92672">=&gt;</span>{   <span style="color:#75715e"># cache: prints cache in recency order</span>
    re      <span style="color:#f92672">=&gt;</span><span style="color:#e6db74">&#39;cache&#39;</span>,
    action  <span style="color:#f92672">=&gt;</span>sub{printCache()},
  },
  <span style="color:#f92672">...</span>
);
</code></pre></div><p>Here are the <code>get</code> and <code>set</code> routines, along with a helper, <code>access</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">access</span> {
    <span style="color:#66d9ef">my</span> $key <span style="color:#f92672">=</span> shift;    <span style="color:#75715e"># key being accessed</span>
    push @recency, $key;    <span style="color:#75715e"># put the key into most recently used</span>
         <span style="color:#75715e"># starting from next most recently used slot, search for key</span>
         <span style="color:#75715e"># and remove any other occurence of key;</span>
    <span style="color:#66d9ef">my</span> $index <span style="color:#f92672">=</span> $#recency <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
    $index<span style="color:#f92672">--</span> <span style="color:#66d9ef">while</span> ( ( $index <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> ) <span style="color:#f92672">and</span> ( $recency[$index] <span style="color:#f92672">ne</span> $key ) );
    splice @recency, $index, <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">if</span> ( $index <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> );

    <span style="color:#75715e"># if capacity exceeded then shift lru out and delete from cache</span>
    delete $cache{ shift @recency } <span style="color:#66d9ef">while</span> ( $capacity <span style="color:#f92672">&lt;</span> @recency );
}

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">get</span> {    <span style="color:#75715e"># get value if key exists else -1</span>
    <span style="color:#66d9ef">my</span> $key <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#66d9ef">unless</span> exists $cache{$key};
    access($key);          <span style="color:#75715e"># recency updated</span>
    <span style="color:#66d9ef">return</span> $cache{$key}    <span style="color:#75715e"># return stored value</span>
}

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">set</span> {                  <span style="color:#75715e"># set key value pair</span>
    <span style="color:#66d9ef">my</span> ( $key, $value ) <span style="color:#f92672">=</span> @_;
    $cache{$key} <span style="color:#f92672">=</span> $value;
    access($key);          <span style="color:#75715e"># recency updated</span>
}
</code></pre></div><h2 id="southpawgeek2">Jen Guerra</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/southpawgeek/perl/ch-2.pl">Jen Guerra&rsquo;s solution</a> has a <code>set</code> and a <code>get</code>, and (aside from some initialization code) that&rsquo;s it!</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">set</span> {
    <span style="color:#66d9ef">my</span> ( $key, $val ) <span style="color:#f92672">=</span> @_;

    <span style="color:#75715e"># remove oldest element if we&#39;re full</span>
    <span style="color:#66d9ef">if</span> ( scalar @keys <span style="color:#f92672">&gt;=</span> $cap ) {
        <span style="color:#66d9ef">my</span> $discard <span style="color:#f92672">=</span> shift @keys <span style="color:#66d9ef">if</span> scalar @keys <span style="color:#f92672">&gt;=</span> $cap;
        delete $cache{$discard};
    }

    <span style="color:#75715e"># push returns number of elements, so subtract 1</span>
    <span style="color:#66d9ef">my</span> $index <span style="color:#f92672">=</span> ( push @keys, $key ) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;

    <span style="color:#75715e"># populate the cache</span>
    $cache{$key} <span style="color:#f92672">=</span> { <span style="color:#e6db74">&#39;value&#39;</span> <span style="color:#f92672">=&gt;</span> $val, <span style="color:#e6db74">&#39;index&#39;</span> <span style="color:#f92672">=&gt;</span> $index };
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">get</span> {
    <span style="color:#66d9ef">my</span> $key <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">my</span> $val <span style="color:#f92672">=</span> $cache{$key}<span style="color:#f92672">-&gt;</span>{<span style="color:#e6db74">&#39;value&#39;</span>} <span style="color:#f92672">||</span> undef;
    <span style="color:#66d9ef">my</span> $index <span style="color:#f92672">=</span> $cache{$key}<span style="color:#f92672">-&gt;</span>{<span style="color:#e6db74">&#39;index&#39;</span>};
    <span style="color:#66d9ef">my</span> $removed <span style="color:#f92672">=</span> splice @keys, $index, <span style="color:#ae81ff">1</span>;
    push @keys, $key;

    <span style="color:#75715e"># this will be number of elements - 1 unless something has gone wrong</span>
    $index <span style="color:#f92672">=</span> scalar @keys <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;

    <span style="color:#75715e"># also update the cache index</span>
    $cache{$key}<span style="color:#f92672">-&gt;</span>{<span style="color:#e6db74">&#39;index&#39;</span>} <span style="color:#f92672">=</span> $index;
    <span style="color:#66d9ef">return</span> $val;
}
</code></pre></div><p>There was quite a bit more debug code in the original solution, so if you want to see this one in motion, you&rsquo;ll be greeted with a good look at what is going on inside.</p>
<h2 id="user-person2">User Person</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/user-person/perl/ch-2.pl">User Person&rsquo;s solution</a> is also basically just <code>lruSet</code> and <code>lruGet</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> @cIndex    <span style="color:#f92672">=</span> ();
<span style="color:#66d9ef">my</span> %cache     <span style="color:#f92672">=</span> ();
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">lruSet</span> {
    <span style="color:#66d9ef">my</span> $lruPos <span style="color:#f92672">=</span> $_[<span style="color:#ae81ff">0</span>];
    <span style="color:#66d9ef">my</span> $lruVal <span style="color:#f92672">=</span> $_[<span style="color:#ae81ff">1</span>];
    <span style="color:#66d9ef">if</span> (exists($cache{$lruPos})) {
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;position $lruPos currently occupied in cache\n\n&#34;</span>;
    } <span style="color:#66d9ef">else</span> {
        push @cIndex, $lruPos;
        $cache{$lruPos} <span style="color:#f92672">=</span> $lruVal;
        <span style="color:#66d9ef">if</span> ( scalar @cIndex <span style="color:#f92672">==</span> $CAPACITY ) {
            <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;\nCache at this point:\n&#34;</span>;
            showCache;
        } <span style="color:#66d9ef">elsif</span> ( scalar @cIndex <span style="color:#f92672">&gt;</span> $CAPACITY ) {
            <span style="color:#66d9ef">my</span> $shifted <span style="color:#f92672">=</span> shift @cIndex;
            delete $cache{$shifted};
            <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;Cache is full, so pushes out key = $shifted:\n&#34;</span>;
            showCache;
        }
    }
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">lruGet</span> {
    <span style="color:#66d9ef">my</span> $lruInd <span style="color:#f92672">=</span> $_[<span style="color:#ae81ff">0</span>];
    <span style="color:#66d9ef">my</span> $lruGetRet <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">if</span> (exists($cache{$lruInd})) {
        <span style="color:#66d9ef">my</span> $moveElement;
      FIND:
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">my</span> $j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;$j <span style="color:#f92672">&lt;=</span> $#cIndex; <span style="color:#f92672">++</span>$j) {
            <span style="color:#66d9ef">if</span> ( $cIndex[$j] <span style="color:#f92672">==</span> $lruInd ) {
                $moveElement <span style="color:#f92672">=</span> $j;
                <span style="color:#66d9ef">last</span> FIND;
            }
        }
        <span style="color:#66d9ef">if</span> ($moveElement <span style="color:#f92672">!=</span> $#cIndex) {
            <span style="color:#66d9ef">my</span> $toPush <span style="color:#f92672">=</span> splice @cIndex,$moveElement, <span style="color:#ae81ff">1</span>;
            push @cIndex, $toPush;
        }
        $lruGetRet <span style="color:#f92672">=</span> $cache{$lruInd};
    }
    <span style="color:#66d9ef">return</span> $lruGetRet;
}
</code></pre></div><h2 id="wanderdoc2">Wanderdoc</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/wanderdoc/perl/ch-2.pl">Wanderdoc&rsquo;s solution</a> gives us an <code>LRU</code> class using Perl list builtins to manage the internal list:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#75715e">#!perl</span>
<span style="color:#66d9ef">package</span> LRU {

    <span style="color:#f92672">...</span>

    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">set</span> {
        <span style="color:#66d9ef">my</span> ($self, $key, $value) <span style="color:#f92672">=</span> @_;
        push @{ $DATA{refaddr $self} }, {$key <span style="color:#f92672">=&gt;</span> $value};
        <span style="color:#66d9ef">while</span> ( scalar @{ $DATA{refaddr $self} } <span style="color:#f92672">&gt;</span> $CAPACITY{refaddr $self} ) {
            shift @{ $DATA{refaddr $self} };
        }
        $self<span style="color:#f92672">-&gt;</span>_update_map;
    }

    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">get</span> {
        <span style="color:#66d9ef">my</span> ($self, $key) <span style="color:#f92672">=</span> @_;
        $self<span style="color:#f92672">-&gt;</span>_update_map;
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> exists $MAP{refaddr $self}{$key};
        <span style="color:#66d9ef">my</span> $idx <span style="color:#f92672">=</span> $MAP{refaddr $self}{$key};
        <span style="color:#66d9ef">my</span> $value <span style="color:#f92672">=</span> $DATA{refaddr $self}[$idx]<span style="color:#f92672">-&gt;</span>{$key};
        <span style="color:#66d9ef">my</span> $last <span style="color:#f92672">=</span> splice( @{$DATA{refaddr $self}}, $idx, <span style="color:#ae81ff">1</span>);
        push @{$DATA{refaddr $self}}, $last;
        $self<span style="color:#f92672">-&gt;</span>_update_map;
        <span style="color:#66d9ef">return</span> $value;
     }

     <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">_update_map</span> {
        <span style="color:#66d9ef">my</span> $self <span style="color:#f92672">=</span> shift;
        %{$MAP{refaddr $self}} <span style="color:#f92672">=</span>
            map { <span style="color:#66d9ef">my</span> ($k) <span style="color:#f92672">=</span> keys %{$DATA{refaddr $self}[$_]}; $k <span style="color:#f92672">=&gt;</span> $_;}
            <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $#{ $DATA{refaddr $self} };
     }
<span style="color:#ae81ff">1</span>;
}
</code></pre></div><h2 id="yet-ebreo2">Yet Ebreo</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-049/yet-ebreo/perl/ch-2.pl">Yet Ebreo&rsquo;s solution</a> gives us an OO <code>lru</code> class and a <code>splice</code> based list. Here are <code>set</code> and <code>get</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">set</span> {
    <span style="color:#66d9ef">my</span> ($self, $key, $value) <span style="color:#f92672">=</span> @_;
    <span style="color:#75715e">#Delete LRU from hash and update order if</span>
    <span style="color:#75715e">#cache is FULL (hash size is equal to cache size)</span>
    <span style="color:#66d9ef">if</span> ((<span style="color:#f92672">!</span>exists ($self<span style="color:#f92672">-&gt;</span>{hash}{$key})) <span style="color:#f92672">&amp;&amp;</span> (<span style="color:#f92672">~~</span>keys %{$self<span style="color:#f92672">-&gt;</span>{hash}} <span style="color:#f92672">&gt;=</span> $self<span style="color:#f92672">-&gt;</span>{size})) {
        delete $self<span style="color:#f92672">-&gt;</span>{hash}{$self<span style="color:#f92672">-&gt;</span>{order}[<span style="color:#ae81ff">0</span>]};
        shift @{$self<span style="color:#f92672">-&gt;</span>{order}};
    }
    <span style="color:#75715e">#Update order array</span>
    <span style="color:#75715e">#If the key already exists in cache remove the key from order array then...</span>
    <span style="color:#66d9ef">if</span> (exists ($self<span style="color:#f92672">-&gt;</span>{hash}{$key})) {
        @{$self<span style="color:#f92672">-&gt;</span>{order}} <span style="color:#f92672">=</span> grep  { $_ <span style="color:#f92672">!=</span> $key } @{$self<span style="color:#f92672">-&gt;</span>{order}};
    }
    <span style="color:#75715e">#put it in last/highest index (Considered as MRU)</span>
    push @{$self<span style="color:#f92672">-&gt;</span>{order}}, $key;
    <span style="color:#75715e">#Update hash key-value pair</span>
    $self<span style="color:#f92672">-&gt;</span>{hash}{$key} <span style="color:#f92672">=</span> $value;
}

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">get</span> {
    <span style="color:#66d9ef">my</span> ($self, $key) <span style="color:#f92672">=</span> @_;
    <span style="color:#66d9ef">if</span> (exists $self<span style="color:#f92672">-&gt;</span>{hash}{$key}) {
        <span style="color:#75715e">#Update the order of the array same as the one in Set method</span>
        @{$self<span style="color:#f92672">-&gt;</span>{order}} <span style="color:#f92672">=</span> grep  { $_ <span style="color:#f92672">!=</span> $key } @{$self<span style="color:#f92672">-&gt;</span>{order}};
        <span style="color:#75715e">#put it in last/highest index (Considered as MRU)</span>
        push @{$self<span style="color:#f92672">-&gt;</span>{order}}, $key;
        <span style="color:#75715e">#Return the value of the given key</span>
        <span style="color:#66d9ef">return</span> $self<span style="color:#f92672">-&gt;</span>{hash}{$key}
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    }
}
</code></pre></div><hr>
<hr>
<h2 id="blogs">See Also</h2>
<h3 id="blogs-this-week">Blogs this week:</h3>
<p><strong>E. Choroba</strong> › <a href="http://blogs.perl.org/users/e_choroba/2020/03/perl-weekly-challenge-048-smallest-multiple-and-lru-cache.html">Smallest Multiple and LRU Cache</a></p>
<p><strong>Javier Luque</strong> › <a href="https://perlchallenges.wordpress.com/2020/02/28/perl-weekly-challenge-049/">049</a></p>
<p><strong>Laurent Rosenfeld</strong> › <a href="http://blogs.perl.org/users/laurent_r/2020/02/perl-weekly-challenge-smallest-multiple-and-lru-cache.html">Smallest Multiple and LRU Cache</a></p>
<p><strong>Luca Ferrari</strong> › <a href="https://fluca1978.github.io/2020/02/24/PerlWeeklyChallenge49.html">LRU and Smallest Multiples made by 1 and 0</a></p>
<p><strong>Mohammad S Anwar</strong> › <a href="https://perlweeklychallenge.org/blog/weekly-challenge-049">BLOG: The Weekly Challenge #049</a></p>
<p><strong>Ryan Thompson</strong> › <a href="http://www.ry.ca/2020/03/smallest-multiple/">Smallest multiple containing only 1 and 0</a> | <a href="http://www.ry.ca/2020/03/lru-cache/">LRU Cache</a></p>

                </div>
            </div>
        </div>
    </div>
</section>


<!-- Call To Action Section Start -->
<section id="call-to-action">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2 class="title wow fadeInDown" data-wow-delay=".3s" data-wow-duration="500ms">SO WHAT DO YOU THINK ?</h2>
                    <p class="wow fadeInDown" data-wow-delay=".5s" data-wow-duration="500ms">If you have any suggestions or ideas then please do share with us.</p>
                    <a href="mailto:mohammad.anwar@yahoo.com" class="btn btn-default btn-contact wow fadeInDown" data-wow-delay=".7s" data-wow-duration="500ms">Contact with me</a>
                </div>
            </div>

        </div>
    </div>
</section>
<!-- Call To Action Section End -->



<!-- Footer Section Start -->
<footer id="footer">
    <div class="container">
        <div class="row content-justify-between">
            <div class="col-md-8 col-12 text-center text-lg-left text-md-left">
                <p class="copyright">Copyright:
                    <span>
                        2019 - 2025
                    </span> The Weekly Challenge. Theme Design and Developed by
                    <a href="http://www.Themefisher.com" rel="noreferrer" rel="noreferrer" target="_blank">Themefisher</a>.
                </p>
            </div>
            <div class="col-md-4 col-12">
                <!-- Social Media -->
                <ul class="social text-center text-md-right text-lg-right">
                    <li>
                        <a href="https://twitter.com/PerlWChallenge" class="twitter" rel="noreferrer" target="_blank" title="Follow us">
                            <i class="ion-social-twitter"></i>
                        </a>
                    </li>
                    <li>
                        <a href="/rss.xml" class="rss" target="_blank" title="RSS Feed">
                            <i class="ion-social-rss"></i>
                        </a>
                    </li>
                </ul>
            </div>
        </div>
    </div>
</footer>
<!-- footer section end -->

<!-- jquery -->
<script src="https://theweeklychallenge.org/plugins/jquery/jquery.min.js"></script>
<!-- Form Validation -->
<script src="https://theweeklychallenge.org/plugins/form-validation/jquery.form.min.js"></script>
<script src="https://theweeklychallenge.org/plugins/form-validation/jquery.validate.min.js"></script>
<!-- slick slider -->
<script src="https://theweeklychallenge.org/plugins/slick/slick.min.js"></script>
<!-- bootstrap js -->
<script src="https://theweeklychallenge.org/plugins/bootstrap/bootstrap.min.js"></script>
<!-- chart js -->
<script src="https://theweeklychallenge.org/plugins/chart/highstock.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/drilldown.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/data.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/chart.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/pwc-challenge.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/gc-challenge.js"></script>
<!-- wow js -->
<script src="https://theweeklychallenge.org/plugins/wow-js/wow.min.js"></script>
<!-- slider js -->
<script src="https://theweeklychallenge.org/plugins/slider/slider.js"></script>
<!-- Fancybox -->
<script src="https://theweeklychallenge.org/plugins/facncybox/jquery.fancybox.js"></script>
<!-- template main js -->

<script src="https://theweeklychallenge.org/js/script.min.js"></script>
<!-- google analitycs -->

<script async src="https://www.googletagmanager.com/gtag/js?id=G-CJTPYM9SB8"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-CJTPYM9SB8');
</script>
</body>

</html>

