<!DOCTYPE html>
<html class="no-js" lang="en-us">
<head>
    <!-- Basic Page Needs -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:title"       content="The Weekly Challenge - Perl & Raku"/>
    <meta property="og:type"        content="website"/>
    <meta property="og:url"         content="https://theweeklychallenge.org/"/>
    <meta property="og:image"       content="https://theweeklychallenge.org/images/about/about.jpg"/>
    <meta property="og:description" content="You do not have to be an expert."/>
    <meta name="twitter:card"       content="summary" />
    <meta name="twitter:image"      content="https://theweeklychallenge.org/images/about/about.jpg"/>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <meta name="description" content="Laurent Rosenfeld Weekly Review: Challenge - #057.">
    <meta name="author" content="The Weekly Challenge Team">
    <meta name="generator" content="Hugo 0.67.0-DEV" />

    <link rel="me" href="https://fosstodon.org/@manwar">

    <!-- Mobile Specific Metas -->
    <meta name="format-detection" content="telephone=no">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Laurent Rosenfeld Weekly Review: Challenge - 057</title>
    <link rel="icon" href="https://theweeklychallenge.org/images/favicon.ico">

    
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css"/>

    <!-- Twitter Bootstrs CSS -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/bootstrap/bootstrap.min.css">
    <!-- Ionicons Fonts Css -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/ionicons/ionicons.min.css">
    <!-- animate css -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/animate-css/animate.css">
    <!-- Hero area slider css-->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/slider/slider.css">
    <!-- slick slider -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/slick/slick.css">
    <!-- Fancybox -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/facncybox/jquery.fancybox.css">
    <!-- hover -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/hover/hover-min.css">
    <!-- Google fonts -->
    <link href='https://fonts.googleapis.com/css?family=Source Code Pro' rel='stylesheet'>
    <!-- template main css file -->
    
    <link rel="stylesheet" href="https://theweeklychallenge.org/css/style.min.css" integrity="" media="screen">
    <link rel="stylesheet" href="https://theweeklychallenge.org/css/main.css">

    <style>
        #goTopButton {
            display: none;          
            position: fixed;        
            bottom: 20px;           
            right: 30px;            
            z-index: 99;            
            border: none;           
            outline: none;          
            background-color: red;  
            color: white;           
            cursor: pointer;        
            padding: 15px;          
            border-radius: 10px;    
            font-size: 18px;        
        }

        #goTopButton:hover {
              background-color: #555;
        }
    </style>


</head>

<body>

<button onclick="goTop()" id="goTopButton" title="Go to top">Top</button>

<script>

    topButton = document.getElementById("goTopButton");

    
    window.onscroll = function() { scrollFunction() };

    function scrollFunction() {
        if (document.body.scrollTop > 40 || document.documentElement.scrollTop > 40) {
            topButton.style.display = "block";
        } else {
            topButton.style.display = "none";
        }
    }

    
    function goTop() {
        document.body.scrollTop = 0; 
        document.documentElement.scrollTop = 0; 
    }

</script>

<section class="top-bar animated-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-12">
                <nav class="navbar navbar-expand-lg navbar-light bg-light">
                    <a class="navbar-brand" href="https://theweeklychallenge.org/">
                        <img src="https://theweeklychallenge.org/images/logo.svg" alt="logo">
                    </a>
                    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navgation" aria-controls="navigation"
                        aria-expanded="false" aria-label="Toggle navigation">
                        <span class="navbar-toggler-icon"></span>
                    </button>

                    <div class="collapse navbar-collapse" id="navigation">
                        <ul class="navbar-nav ml-auto">
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/">Home</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/about">About</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/chart">Chart</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/champions">Champions</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/team">Team</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/challenges">Challenges</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/p5-reviews">Perl/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/p6-reviews">Raku/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/recaps">Recaps</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/blogs">Blogs</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/faq">FAQ</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/contact">Contact</a>
                            </li>
                            
                        </ul>
                    </div>
                </nav>
            </div>
        </div>
    </div>
</section>


<section class="global-page-header">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2>Laurent Rosenfeld Weekly Review: Challenge - 057</h2>
                    <div class="portfolio-meta">
                        <span>Thursday, May 7, 2020</span>|
                        <span> Tags:
                            Raku
                        </span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

<section class="single-post">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                
                <div style="text-align: center" class="post-img">
                    <img class="img-fluid" alt="" src="https://theweeklychallenge.org/images/blog/p6-review-challenge-057.jpg">
                </div>
                
                <div style="text-align: justify" class="post-content">
                    <hr>
<h1 id="raku-solutions-weekly-review">Raku Solutions Weekly Review</h1>
<hr>
<h1 id="tree-inversion">Tree Inversion</h1>
<p>This is derived in part from my <a href="http://blogs.perl.org/users/laurent_r/2020/04/perl-weekly-challenge-57-tree-inversion-and-shortest-unique-prefix.html">blog post</a> made in answer to the <a href="https://perlweeklychallenge.org/blog/perl-weekly-challenge-057/">Week 57 of the Perl Weekly Challenge</a> organized by  <a href="http://blogs.perl.org/users/mohammad_s_anwar/">Mohammad S. Anwar</a> as well as answers made by others to the same challenge.</p>
<p>The challenge reads as follows:</p>
<p><em>You are given a full binary tree of any height, similar to the one below:</em></p>
<pre><code>    1
   /  \
  2    3
 / \  / \
4   5 6  7
</code></pre>
<p><em>Write a script to invert the tree, by mirroring the children of every node, from left to right. The expected output from the tree above would be:</em></p>
<pre><code>    1
   /  \
  3    2
 / \  / \
7   6 5  4
</code></pre>
<p><em>The input can be any sensible machine-readable binary tree format of your choosing, and the output should be the same format.</em></p>
<p><em>Bonus: In addition to the above, you may wish to pretty-print your binary tree in a human readable text-based format as above.</em></p>
<p>I&rsquo;ll definitely take the bonus, because making auxiliary subroutines to represent graphically the trees is the best way to check that inversion subroutine works correctly (or to easily detect the errors, if any). But I will not represent the tree edges (the <code>/</code> and <code>\</code> connecting vertically the letters), because it becomes a bit difficult with 4 levels and more or less unmanageable (and quite ugly) when there are more that 4 levels (well, Colin Crain found a nice solution presented below).  For example, I chose to represent a 5-level binary tree as follows:</p>
<pre><code>                1
        2               3
    4       5       6       7
  8   9   a   b   c   d   e   f
 g h i j k l m n o p q r s t u v
</code></pre>
<p>I decided to implement two different subroutines for the display: one <code>bft</code> (breadth-first traversal) subroutine to construct an intermediate array of arrays in which each level of the tree is contained in one sub-array:</p>
<pre><code>[[1] [2 3] [4 5 6 7] [8 9 a b c d e f] [g h i j k l m n o p q r s t u v]]
</code></pre>
<p>and one <code>display</code> subroutine to produce the graphical ASCII representation. The main reason for doing that is that the <code>display</code> subroutine can thus be reused, independently of the internal tree representation.</p>
<h2 id="using-an-array-of-arrays">Using an Array of Arrays</h2>
<p>I have discussed in a <a href="http://blogs.perl.org/users/laurent_r/2020/04/perl-weekly-challenge-56-diff-k-and-path-sum.html">recent blog post</a> 3 different ways to represent a binary tree: hash of hashes, array of arrays and a simple flat array.</p>
<p>I have shown in that post and also <a href="https://github.com/LaurentRosenfeld/Perl-6-Miscellaneous/blob/master/Challenges-in-Perl6/Path-sums-in-binary-trees.md">there</a> how to represent a binary tree with a nested array of arrays.</p>
<p>As an alternative, we might implement an array of arrays in which each of the sub-arrays contain one level of the tree, i.e. a breadth-first representation of the tree. The tree of the task description might look like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl">    [ [<span style="color:#ae81ff">1</span>], [<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>], [<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>] ]
</code></pre></div><p>With such an implementation, inverting the tree can be done in a simple one-liner:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl">$ perl6 <span style="color:#f92672">-</span>e <span style="color:#e6db74">&#39;([1], [2, 3], [4, 5, 6, 7]).map({[ .reverse ]}).say;&#39;</span>
([<span style="color:#ae81ff">1</span>] [<span style="color:#ae81ff">3</span> <span style="color:#ae81ff">2</span>] [<span style="color:#ae81ff">7</span> <span style="color:#ae81ff">6</span> <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">4</span>])
</code></pre></div><p>or possibly even:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl">$ perl6 <span style="color:#f92672">-</span>e <span style="color:#e6db74">&#39;( (1), (2, 3), (4, 5, 6, 7) )&gt;&gt;.reverse.say;&#39;</span>
((<span style="color:#ae81ff">1</span>) (<span style="color:#ae81ff">3</span> <span style="color:#ae81ff">2</span>) (<span style="color:#ae81ff">7</span> <span style="color:#ae81ff">6</span> <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">4</span>))
</code></pre></div><p>Note that this representation of a tree makes it possible to use directly the <code>display</code> subroutine briefly described above, since it already has the breadth-first format otherwise produced by the <code>bft</code> subroutine.</p>
<p>However, we will detail here the two other solutions, using a flat array or a hash of hashes.</p>
<h2 id="using-a-flat-array">Using a Flat Array</h2>
<p>We&rsquo;ll start with a flat array. Binary trees can be stored in breadth-first order as an array with an implicit data structure. This is similar to what is commonly done for <em>binary heaps</em> (i.e. a binary tree that keeps a partial order). Here, we&rsquo;re not interested with partial order, but the idea is to use an array with the following properties. The item with subscript 0 is the value of the root node. The index of an element is used to compute the index of its parent and the indices of its children. The basic idea is that, for any node, the index of its parent is about half the index of the current node, and, conversely, the indices of the children are about twice the index of the current node. More precisely, for a tree starting at index 0, the exact formulas for a node with index <code>$n</code> are commonly as follows:</p>
<ul>
<li>parent: <code>int( ($n-1)/2 )</code></li>
<li>left child: <code>2*$n + 1</code></li>
<li>right child: <code>2*$n + 2</code></li>
</ul>
<p>The root node is at index 0, and its children are at positions 1 and 2. The children of item with index 1 are at positions 3 and 4 and the children of 2 are at positions 5 and 6.</p>
<p>These rules may seem a bit complicated (and it is a bit tedious to compute these things manually), but they&rsquo;re in fact quite easy to implement in a program:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">children</span> (Int $i) { <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>$i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>$i<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span> }
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">parent</span> (Int $i) { ($i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>; }
</code></pre></div><p>The <code>parent</code> subroutine is provided here for the purpose of completeness, it will not be needed in our program.</p>
<p>Note that it is very easy to populate the binary-heap-like array from a graphical representation: you just need to perform a breadth-first traversal, and provide empty slots (undefined values) for missing nodes, but that&rsquo;s not necessary here, since we are told that we are only dealing with full binary trees. For example, this binary tree:</p>
<pre><code>    1
   /  \
  2    3
 / \  / \
4   5 6  7
</code></pre>
<p>can be encoded as:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#66d9ef">my</span> $tree <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>];
</code></pre></div><p>or even:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#66d9ef">my</span> $tree <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> <span style="color:#ae81ff">7</span>];
</code></pre></div><p>With this flat array representation, the <code>invert</code> subroutine can be very simple (and needs not be recursive, since the data structure is not nested): we just use the <code>bft</code> subroutine to get an array of arrays by level, reverse the components and flatten the overall structure:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">invert</span> ($tree) {
    <span style="color:#66d9ef">return</span> [ map { <span style="color:#f92672">|</span> reverse @$_ }, bft($tree) ];
}
</code></pre></div><p>This is the complete code for this program:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">use</span> v6;

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">children</span> (Int $i) { <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>$i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>$i<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span> }
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">parent</span> (Int $i) { ($i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>; }  <span style="color:#75715e"># not needed here</span>

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">display</span> ($tree) {
    <span style="color:#66d9ef">my</span> @bft_tree <span style="color:#f92672">=</span> bft($tree);
    <span style="color:#66d9ef">my</span> $start <span style="color:#f92672">=</span> (@bft_tree[<span style="color:#f92672">*-</span><span style="color:#ae81ff">1</span>])<span style="color:#f92672">.</span>elems;
    <span style="color:#66d9ef">my</span> $sep_val <span style="color:#f92672">=</span> (<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> $start) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">for</span> @bft_tree <span style="color:#f92672">-&gt;</span> @line {
        <span style="color:#66d9ef">my</span> $sep <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34; &#34;</span> x $sep_val;
        say <span style="color:#e6db74">&#34; &#34;</span> x $start, join $sep, @line;
        $start <span style="color:#f92672">/=</span> <span style="color:#ae81ff">2</span>;
        $sep_val <span style="color:#f92672">=</span> ($sep_val <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
    }
}
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">bft</span> ($tree) {               <span style="color:#75715e"># Breadth First Traversal</span>
    <span style="color:#66d9ef">my</span> ($index, $level) <span style="color:#f92672">=</span> (<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>);
    <span style="color:#66d9ef">my</span> @bft_tree;
    <span style="color:#66d9ef">while</span> ($index <span style="color:#f92672">&lt;=</span> $tree<span style="color:#f92672">.</span>end) {
        <span style="color:#66d9ef">my</span> $new_index <span style="color:#f92672">=</span> $index <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">**</span> $level <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
        (@bft_tree[$level<span style="color:#f92672">++</span>])<span style="color:#f92672">.</span>append($tree[$index <span style="color:#f92672">..</span> $new_index]);
        $index <span style="color:#f92672">=</span> $new_index <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
    }
    <span style="color:#66d9ef">return</span> @bft_tree;
}
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">invert</span> ($tree) {
    <span style="color:#66d9ef">return</span> [ map { <span style="color:#f92672">|</span> reverse @$_ }, bft($tree) ];
}

<span style="color:#66d9ef">my</span> $tree <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span><span style="color:#ae81ff">9</span>, <span style="color:#e6db74">&#39;a&#39;</span><span style="color:#f92672">..</span><span style="color:#e6db74">&#39;v&#39;</span>)<span style="color:#f92672">.</span>flat;
say $tree;
say <span style="color:#e6db74">&#34;\nTree before inversion&#34;</span>;
display $tree;
<span style="color:#66d9ef">my</span> $inverted_tree <span style="color:#f92672">=</span> invert($tree);
say <span style="color:#e6db74">&#34;\nInverted tree&#34;</span>;
say <span style="color:#e6db74">&#34;$inverted_tree\n&#34;</span>;
display $inverted_tree;
</code></pre></div><p>Running the program displays the following output:</p>
<pre><code>$ perl6 invert_tree2.p6
(1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v)

Tree before inversion:
                1
        2               3
    4       5       6       7
  8   9   a   b   c   d   e   f
 g h i j k l m n o p q r s t u v

Inverted tree:
1 3 2 7 6 5 4 f e d c b a 9 8 v u t s r q p o n m l k j i h g

                1
        3               2
    7       6       5       4
  f   e   d   c   b   a   9   8
 v u t s r q p o n m l k j i h g
</code></pre>
<h3 id="using-a-hash-of-hashes">Using a Hash of Hashes</h3>
<p>A hash of hashes is probably the most explicit and clearest implementation of a binary tree. But it tends to be quite verbose.</p>
<p>A node is a hash consisting in three elements: its value (an integer), its left child and its right child. The children may be undefined when we are at the lowest level of the tree (i.e. when the node is a &ldquo;leaf&rdquo;). So a node could be implemented as a hash with three keys, <code>v</code> (value), <code>l</code> (left child) and <code>r</code> (right child). The children, when they are defined, are themselves nodes, so the structure is nested and can be explored recursively. For example, the following binary tree:</p>
<pre><code>    1
   /  \
  2    3
 / \  / \
4   5 6  7
</code></pre>
<p>can be encoded as:</p>
<pre><code>my %tree =  v =&gt; 1,
            l =&gt; { v =&gt; 2, l =&gt; {v =&gt; 4}, r =&gt; {v =&gt; 5} },
            r =&gt; { v =&gt; 3, l =&gt; {v =&gt; 6}, r =&gt; {v =&gt; 7} },
            ;
</code></pre>
<p>In this quick and simple implementation, we use global variables for the tree and for the breadth-first array, to avoid the pain of carrying them around back and forth in the successive recursive subroutine calls. In a real-life application, it would be more proper to pass them as arguments and return values of subroutines, or to use dynamic variables.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">use</span> v6;

<span style="color:#66d9ef">my</span> %tree <span style="color:#f92672">=</span>  v <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">1</span>,
            l <span style="color:#f92672">=&gt;</span> { v <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">2</span>, l <span style="color:#f92672">=&gt;</span> {v <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">4</span>}, r <span style="color:#f92672">=&gt;</span> {v <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">5</span>} },
            r <span style="color:#f92672">=&gt;</span> { v <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">3</span>, l <span style="color:#f92672">=&gt;</span> {v <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">6</span>}, r <span style="color:#f92672">=&gt;</span> {v <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">7</span>} },
            ;
<span style="color:#66d9ef">my</span> @bft<span style="color:#f92672">-</span>tree;

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">display</span> ($tree) {
    <span style="color:#66d9ef">my</span> $start <span style="color:#f92672">=</span> (@bft<span style="color:#f92672">-</span>tree[<span style="color:#f92672">*-</span><span style="color:#ae81ff">1</span>])<span style="color:#f92672">.</span>elems;
    <span style="color:#66d9ef">my</span> $sep_val <span style="color:#f92672">=</span> (<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> $start) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">for</span> @bft<span style="color:#f92672">-</span>tree <span style="color:#f92672">-&gt;</span> @line {
        <span style="color:#66d9ef">my</span> $sep <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34; &#34;</span> x $sep_val;
        say <span style="color:#e6db74">&#34; &#34;</span> x $start, join $sep, @line;
        $start <span style="color:#f92672">/=</span> <span style="color:#ae81ff">2</span>;
        $sep_val <span style="color:#f92672">=</span> ($sep_val <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
    }
}
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">bft</span> (%node, $level) {
    push @bft<span style="color:#f92672">-</span>tree[$level], %node<span style="color:#e6db74">&lt;v&gt;</span>;
    bft(%node<span style="color:#e6db74">&lt;l&gt;</span>, $level <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">if</span> defined %node<span style="color:#e6db74">&lt;l&gt;</span>;
    bft(%node<span style="color:#e6db74">&lt;r&gt;</span>, $level <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">if</span> defined %node<span style="color:#e6db74">&lt;r&gt;</span>;
}
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">invert</span> (%node) {
    invert(%node<span style="color:#e6db74">&lt;l&gt;</span>) <span style="color:#66d9ef">if</span> defined %node<span style="color:#e6db74">&lt;l&gt;</span>;
    invert(%node<span style="color:#e6db74">&lt;r&gt;</span>) <span style="color:#66d9ef">if</span> defined %node<span style="color:#e6db74">&lt;r&gt;</span>;
    (%node<span style="color:#e6db74">&lt;l&gt;</span>, %node<span style="color:#e6db74">&lt;r&gt;</span>) <span style="color:#f92672">=</span> %node<span style="color:#e6db74">&lt;r&gt;</span>, %node<span style="color:#e6db74">&lt;l&gt;</span>
        <span style="color:#66d9ef">if</span> defined %node<span style="color:#e6db74">&lt;l&gt;</span> <span style="color:#f92672">and</span> defined %node<span style="color:#e6db74">&lt;r&gt;</span>;
}
bft %tree, <span style="color:#ae81ff">0</span>;
say <span style="color:#e6db74">&#34;Tree before inversion:&#34;</span>;
display(@bft<span style="color:#f92672">-</span>tree);
invert(%tree);
@bft<span style="color:#f92672">-</span>tree <span style="color:#f92672">=</span> ();
bft %tree, <span style="color:#ae81ff">0</span>;
say <span style="color:#e6db74">&#34;\nTree after inversion&#34;</span>;
display(@bft<span style="color:#f92672">-</span>tree);
</code></pre></div><p>This program produces the following output:</p>
<pre><code>$ ./perl6 invert_tree3.p6
Tree before inversion:
    1
  2   3
 4 5 6 7

Tree after inversion
    1
  3   2
 7 6 5 4
</code></pre>
<h2 id="alternative-solutions">Alternative Solutions</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-057/arne-sommer/raku/ch-1.p6">Arne Sommer</a> created a <code>BinaryNode</code> class to store the tree node data structure, along with a <code>swap</code> method to invert left and right children:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl">class BinaryNode
{
  has Int        $<span style="color:#960050;background-color:#1e0010">.</span>value;
  has BinaryNode $<span style="color:#960050;background-color:#1e0010">.</span>left   is rw;
  has BinaryNode $<span style="color:#960050;background-color:#1e0010">.</span>right  is rw;

  method swap
  {
    (self<span style="color:#f92672">.</span>left, self<span style="color:#f92672">.</span>right) <span style="color:#f92672">=</span> (self<span style="color:#f92672">.</span>right, self<span style="color:#f92672">.</span>left);
  }
}
</code></pre></div><p>His recursive <code>traverse</code> subroutine is fairly simple:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">traverse</span> ($current)
{
  $current<span style="color:#f92672">.</span>swap;

  traverse($current<span style="color:#f92672">.</span>left)  <span style="color:#66d9ef">if</span> $current<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>defined;
  traverse($current<span style="color:#f92672">.</span>right) <span style="color:#66d9ef">if</span> $current<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>defined;
}
</code></pre></div><p>The following subroutine (with its lexical recursive <code>do-it</code> subroutine) is used to prepare the tree display:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">tree2string</span> ($tree)
{
  <span style="color:#66d9ef">my</span> @level;
  <span style="color:#66d9ef">my</span> $level <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

  <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">do</span>-it($current, $level)
  {
    say <span style="color:#e6db74">&#34;:: &#34;</span> <span style="color:#f92672">~</span> $current<span style="color:#f92672">.</span>value <span style="color:#66d9ef">if</span> $verbose;
    @level[$level]<span style="color:#f92672">.</span>push($current<span style="color:#f92672">.</span>value);
    <span style="color:#66d9ef">do</span><span style="color:#f92672">-</span>it($current<span style="color:#f92672">.</span>left,  $level <span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">if</span> $current<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>defined;
    <span style="color:#66d9ef">do</span><span style="color:#f92672">-</span>it($current<span style="color:#f92672">.</span>right, $level <span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">if</span> $current<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>defined;
  }

  <span style="color:#66d9ef">do</span><span style="color:#f92672">-</span>it($tree, $level);

  <span style="color:#66d9ef">return</span> @level<span style="color:#f92672">.</span>join(<span style="color:#e6db74">&#34; | &#34;</span>)<span style="color:#f92672">.</span>join(<span style="color:#e6db74">&#34; &#34;</span>);
}
</code></pre></div><p>Arne also wrote another version with just one actual code line:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl">unit <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">MAIN</span> <span style="color:#960050;background-color:#1e0010">($</span><span style="color:#a6e22e">tree</span> <span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#960050;background-color:#1e0010">&#34;1</span> <span style="color:#960050;background-color:#1e0010">|</span> <span style="color:#960050;background-color:#1e0010">2</span> <span style="color:#960050;background-color:#1e0010">3</span> <span style="color:#960050;background-color:#1e0010">|</span> <span style="color:#960050;background-color:#1e0010">4</span> <span style="color:#960050;background-color:#1e0010">5</span> <span style="color:#960050;background-color:#1e0010">6</span> <span style="color:#960050;background-color:#1e0010">7&#34;)</span>;
say $tree<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#34; | &#34;</span>)<span style="color:#f92672">&gt;&gt;.</span>words<span style="color:#f92672">&gt;&gt;.</span>reverse<span style="color:#f92672">&gt;&gt;.</span>join(<span style="color:#e6db74">&#34; &#34;</span>)<span style="color:#f92672">.</span>join(<span style="color:#e6db74">&#34; | &#34;</span>);
</code></pre></div><p>which produces the following output:</p>
<pre><code>$ raku invert-tree-oneliner &quot;5 | 4 8 | 11 * 13 9 | 7 2 * * * 1&quot;
5 | 8 4 | 9 13 * 11 | 1 * * * 2 7
</code></pre>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-057/kevin-colyer/raku/ch-1.p6">Kevin Colyer</a> used a <code>node</code> class to represent a tree node, with three methods:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl">class node {
    has Int $<span style="color:#960050;background-color:#1e0010">.</span>value;
    has node $<span style="color:#960050;background-color:#1e0010">.</span>left;
    has node $<span style="color:#960050;background-color:#1e0010">.</span>right;
    has method has<span style="color:#f92672">-</span>left  { <span style="color:#66d9ef">return</span> $<span style="color:#960050;background-color:#1e0010">!</span>left<span style="color:#f92672">.</span>defined  };
    has method has<span style="color:#f92672">-</span>right { <span style="color:#66d9ef">return</span> $<span style="color:#960050;background-color:#1e0010">!</span>right<span style="color:#f92672">.</span>defined };
    has method is<span style="color:#f92672">-</span>leaf { <span style="color:#66d9ef">return</span> <span style="color:#f92672">not</span> ( $<span style="color:#960050;background-color:#1e0010">!</span>left<span style="color:#f92672">.</span>defined <span style="color:#f92672">or</span> $<span style="color:#960050;background-color:#1e0010">!</span>right<span style="color:#f92672">.</span>defined ) };
}
</code></pre></div><p>I wonder why Kevin uses the <code>has</code> keyword to define his methods, but it seems to work fine.</p>
<p>The tree construction is a bit tedious:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">my</span> $root <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(value <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">1</span>,
    left <span style="color:#f92672">=&gt;</span> node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(value <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">2</span>, left <span style="color:#f92672">=&gt;</span> node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(value <span style="color:#f92672">=&gt;</span><span style="color:#ae81ff">4</span>),right <span style="color:#f92672">=&gt;</span> node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(value <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">5</span>,left <span style="color:#f92672">=&gt;</span> node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(value <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">10</span>, left <span style="color:#f92672">=&gt;</span> node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(value<span style="color:#f92672">=&gt;</span><span style="color:#ae81ff">11</span>) ))),
    right <span style="color:#f92672">=&gt;</span> node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(value<span style="color:#f92672">=&gt;</span><span style="color:#ae81ff">3</span>,left<span style="color:#f92672">=&gt;</span>node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(value<span style="color:#f92672">=&gt;</span><span style="color:#ae81ff">6</span>),right<span style="color:#f92672">=&gt;</span> node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(value<span style="color:#f92672">=&gt;</span><span style="color:#ae81ff">7</span>,left<span style="color:#f92672">=&gt;</span>node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(value <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">8</span>),right<span style="color:#f92672">=&gt;</span>node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(value <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">9</span>,right<span style="color:#f92672">=&gt;</span>node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(value<span style="color:#f92672">=&gt;</span><span style="color:#ae81ff">12</span>)) ) )
    );
</code></pre></div><p>Tree inversion, on the other hand is quite simple:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">invert</span>-tree($node) {
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> $node<span style="color:#f92672">.</span>defined;
    <span style="color:#66d9ef">return</span> node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(value <span style="color:#f92672">=&gt;</span> $node<span style="color:#f92672">.</span>value, left<span style="color:#f92672">=&gt;</span>invert<span style="color:#f92672">-</span>tree($node<span style="color:#f92672">.</span>right),right <span style="color:#f92672">=&gt;</span> invert<span style="color:#f92672">-</span>tree($node<span style="color:#f92672">.</span>left));
}
</code></pre></div><p>For preparing the pretty-printing, Kevin&rsquo;s program converts the tree to an array:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">tree</span>-to-array($tree,@array,$parent=0,$depth=0) {
    state $maxdepth;
    <span style="color:#75715e"># reset maxdepth on call to root node</span>
    $maxdepth<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span> <span style="color:#66d9ef">if</span> $parent<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>;

    @array[$parent]<span style="color:#f92672">=</span>$tree<span style="color:#f92672">.</span>value;

    <span style="color:#66d9ef">my</span> $d<span style="color:#f92672">=</span>$depth;
    <span style="color:#66d9ef">if</span> $tree<span style="color:#f92672">.</span>has<span style="color:#f92672">-</span>left {
       $d<span style="color:#f92672">=</span> tree<span style="color:#f92672">-</span>to<span style="color:#f92672">-</span>array($tree<span style="color:#f92672">.</span>left,@array,$parent<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,$depth<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
    }
    <span style="color:#66d9ef">if</span> $tree<span style="color:#f92672">.</span>has<span style="color:#f92672">-</span>right {
        $d<span style="color:#f92672">=</span>tree<span style="color:#f92672">-</span>to<span style="color:#f92672">-</span>array($tree<span style="color:#f92672">.</span>right,@array,$parent<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span><span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>,$depth<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
    }

    $maxdepth<span style="color:#f92672">=</span>max($d,$maxdepth);
    <span style="color:#66d9ef">return</span> $maxdepth;
}
</code></pre></div><p>But I won&rsquo;t quote here Kevin&rsquo;s <code>pretty-print-tree</code> subroutine, as it is about 70-line long. Please follow the link if you want to see it.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-057/luca-ferrari/raku/ch-1.p6">Luca Ferrari</a> implemented a simple <code>Node</code> class:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl">class Node {
    has Int  $<span style="color:#960050;background-color:#1e0010">.</span>value;
    has Node $<span style="color:#960050;background-color:#1e0010">.</span>left  is rw;
    has Node $<span style="color:#960050;background-color:#1e0010">.</span>right is rw;
}
</code></pre></div><p>The tree inversion is done in the following <code>switch</code> recursive subroutine:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">switch</span>( Node $current-node is rw ) {
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span> $current<span style="color:#f92672">-</span>node
        <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span> $current<span style="color:#f92672">-</span>node<span style="color:#f92672">.</span>left
        <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span> $current<span style="color:#f92672">-</span>node<span style="color:#f92672">.</span>right;

    <span style="color:#66d9ef">my</span> ( $left, $right ) <span style="color:#f92672">=</span> ( $current<span style="color:#f92672">-</span>node<span style="color:#f92672">.</span>left, $current<span style="color:#f92672">-</span>node<span style="color:#f92672">.</span>right );
    $current<span style="color:#f92672">-</span>node<span style="color:#f92672">.</span>left  <span style="color:#f92672">=</span> $right;
    $current<span style="color:#f92672">-</span>node<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> $left;

    switch( $current<span style="color:#f92672">-</span>node<span style="color:#f92672">.</span>left )  <span style="color:#66d9ef">if</span> $current<span style="color:#f92672">-</span>node<span style="color:#f92672">.</span>left;
    switch( $current<span style="color:#f92672">-</span>node<span style="color:#f92672">.</span>right ) <span style="color:#66d9ef">if</span> $current<span style="color:#f92672">-</span>node<span style="color:#f92672">.</span>right;
}
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-057/simon-proctor/raku/ch-1.p6">Simon Proctor</a> wrote a full-fledged object-oriented program, with three classes, one role and even one grammar. the <code>BTree</code> defines most of the method used in the program:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl">role BTree[<span style="color:#f92672">::</span>T] {
    has T $<span style="color:#960050;background-color:#1e0010">.</span>value is required;
    has BTree @<span style="color:#960050;background-color:#1e0010">!</span>nodes[<span style="color:#ae81ff">2</span>];

    method Str( ) {
        ( $<span style="color:#960050;background-color:#1e0010">!</span>value , <span style="color:#f92672">|</span>@<span style="color:#960050;background-color:#1e0010">.</span>nodes<span style="color:#f92672">.</span>map( { <span style="color:#e6db74">&#34;({$_})&#34;</span> } ) )<span style="color:#f92672">.</span>join(<span style="color:#e6db74">&#34;&#34;</span>);
    }

    method nodes() {
        @<span style="color:#960050;background-color:#1e0010">!</span>nodes<span style="color:#f92672">.</span>grep({defined $_});
    }

    method children() {
        @<span style="color:#960050;background-color:#1e0010">.</span>nodes<span style="color:#f92672">.</span>elems;
    }

    method gist() {
        BTreeRep<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>( tree<span style="color:#f92672">=&gt;</span>self )<span style="color:#f92672">.</span>gist();
    }

    method traverse() {
        gather {
            <span style="color:#66d9ef">if</span> ( self<span style="color:#f92672">.</span>children ) {
                <span style="color:#66d9ef">for</span> @<span style="color:#960050;background-color:#1e0010">.</span>nodes <span style="color:#f92672">-&gt;</span> $n {
                    <span style="color:#66d9ef">for</span> $n<span style="color:#f92672">.</span>traverse <span style="color:#f92672">-&gt;</span> @t {
                        take ($<span style="color:#960050;background-color:#1e0010">!</span>value, <span style="color:#f92672">|</span>@t);
                    }
                }
            } <span style="color:#66d9ef">else</span> {
                take ( $<span style="color:#960050;background-color:#1e0010">!</span>value, );
            }
        }
    }

    multi method reverse( <span style="color:#f92672">::</span>?CLASS:D: ) {
        self<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(
            value <span style="color:#f92672">=&gt;</span> $<span style="color:#960050;background-color:#1e0010">!</span>value,
            nodes <span style="color:#f92672">=&gt;</span> @<span style="color:#960050;background-color:#1e0010">.</span>nodes<span style="color:#f92672">.</span>reverse<span style="color:#f92672">.</span>map( <span style="color:#f92672">*.</span>reverse )
        )
    }

    multi method from<span style="color:#f92672">-</span>Str(<span style="color:#e6db74">&#39;&#39;</span>) { BTree }

    multi method from<span style="color:#f92672">-</span>Str( <span style="color:#f92672">::</span>?CLASS:U: Str $in ) {
        <span style="color:#66d9ef">my</span> $match <span style="color:#f92672">=</span> BTreeGrammar<span style="color:#f92672">.</span>parse( $in );
        <span style="color:#66d9ef">if</span> ( $match ) {
            self<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(
                value <span style="color:#f92672">=&gt;</span> $match<span style="color:#e6db74">&lt;tree&gt;&lt;value&gt;</span><span style="color:#f92672">.</span>Str,
                nodes <span style="color:#f92672">=&gt;</span> [
                          self<span style="color:#f92672">.</span>from<span style="color:#f92672">-</span>Str( $match<span style="color:#e6db74">&lt;tree&gt;&lt;left&gt;</span> ?? $match<span style="color:#e6db74">&lt;tree&gt;&lt;left&gt;</span><span style="color:#f92672">.</span>Str <span style="color:#f92672">!!</span> <span style="color:#e6db74">&#39;&#39;</span> ),
                          self<span style="color:#f92672">.</span>from<span style="color:#f92672">-</span>Str( $match<span style="color:#e6db74">&lt;tree&gt;&lt;right&gt;</span> ?? $match<span style="color:#e6db74">&lt;tree&gt;&lt;right&gt;</span><span style="color:#f92672">.</span>Str <span style="color:#f92672">!!</span> <span style="color:#e6db74">&#39;&#39;</span> )
                      ]
            );
        } <span style="color:#66d9ef">else</span> {
            die <span style="color:#e6db74">&#34;Unable to Parse $in&#34;</span>;
        }

    }
}
</code></pre></div><p>The recursive <code>reverse</code> method shown above does the main work.</p>
<p>This role is applied to the <code>UBTree</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl">class UBTree does BTree[UInt] {
    submethod BUILD ( UInt() :$value, :@nodes ) {
        $<span style="color:#960050;background-color:#1e0010">!</span>value <span style="color:#f92672">=</span> $value;
        @<span style="color:#960050;background-color:#1e0010">!</span>nodes <span style="color:#f92672">=</span> @nodes;
    }
}
</code></pre></div><p>For those who don&rsquo;t know, the default <code>BUILD</code> submethod is automatically called by the new constructor method. Here, it is necessary to redefine the BUILD submethod to properly initialize the class&rsquo;s private attributes.</p>
<p>Note that the <code>from-Str</code> method of the <code>BTree</code> role uses a grammar, <code>BTreeGrammar</code>, to parse the input string representing the input binary tree:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#75715e"># Example tree 5(4(11(7)(2)))(8(13)(9(1)))</span>
grammar BTreeGrammar {
    token TOP { <span style="color:#e6db74">&lt;tree&gt;</span> };
    token tree { <span style="color:#e6db74">&lt;value&gt;</span> [<span style="color:#e6db74">&#34;(&#34;</span> $<span style="color:#960050;background-color:#1e0010">&lt;</span>left<span style="color:#f92672">&gt;=</span><span style="color:#e6db74">&lt;tree&gt;</span> <span style="color:#e6db74">&#34;)&#34;</span>]? [<span style="color:#e6db74">&#34;(&#34;</span> $<span style="color:#960050;background-color:#1e0010">&lt;</span>right<span style="color:#f92672">&gt;=</span><span style="color:#e6db74">&lt;tree&gt;</span> <span style="color:#e6db74">&#34;)&#34;</span>]? };
    regex value { <span style="color:#e6db74">&lt;-[()]&gt;</span><span style="color:#f92672">+</span> }
}
</code></pre></div><p>Simon&rsquo;s ASCII-art tree representation is quite nice, as shown in this sample output:</p>
<pre><code>Tree :
     5
   ┌─┴──┐
   4    8
 ┌─┘   ┌┴─┐
11    13  9
┌┴┐      ┌┘
7 2      1

Reversed :
      5
   ┌──┴───┐
   8      4
 ┌─┴─┐  ┌─┘
 9  13 11
┌┘     ┌┴┐
1      2 7
</code></pre>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-057/shahed-nooshmand/raku/ch-1.sh">Shahed Nooshmand</a> used a hash of hashes and managed to write the tree inversion program in the form of a Raku one-liner:</p>
<pre><code>raku -e 'say (sub ($_) { .isa(Pair) ?? (.key =&gt; .value.reverse.map: { samewith $^a }) !! $_ })(1 =&gt; (2 =&gt; (4, 5), 3 =&gt; (6, 7)))'
1 =&gt; (3 =&gt; (7 6) 2 =&gt; (5 4))
</code></pre>
<p>Quite impressive!</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-057/colin-crain/raku/ch-1.p6">Colin Crain</a>&lsquo;s submission starts again (as often) with a long comment explaining with quite a bit of details the various things he considered for solving the task. Please follow the link, it is really an interesting reading. I would really wish that Colin will stop putting these very useful comments in his code and thus let it somewhat buried in GitHub, and will start a blog having more visibility. Anyway, like with the sum path task of last week, Colin decided to use a data structure reducing a binary tree to a specific fixed-size array, with indices allocated along a level-first traversal of the tree for each possible node at every level. Essentially, Colin is using what I have called a flat array with an implicit data structure (or binary-heap-like array) in the description of my solution.</p>
<p>Inverting a tree in this format is reduced to selecting out the various levels within the array, reversing them and reconstituting the structure.  This is accomplished in the following <code>invert_tree</code> subroutine:</p>
<pre><code>sub invert_tree (@tree) {
## symmetrically mirrors a binary tree on the right/left axis
## I wouldn't use the word &quot;invert&quot; here
    my $max_level = get_level( @tree.end );
    my @output;

    for 0..$max_level -&gt; $level {
        my $level_size = 2 ** $level;
        my @level =  @tree.splice( 0, $level_size );
        @output.append: @level.reverse;
    }

    @tree = @output;
}
</code></pre><p>Colin made a very nice job to pretty print the tree, even with relatively deep trees, but I won&rsquo;t quote here the 70+ lines of hairy code needed. Please follow the link if you want to to see it. Suffice it to show here how the array <code>(5, 4, 8, 1, Int, 3, 9, 7, 2, Int, Int, Int, Int, Int, 1)</code> is displayed in Colin&rsquo;s program:</p>
<pre><code>        ______5______
       /             \
    __4             __8__
   /               /     \
  1               3       9
 / \                       \
7   2                       1
</code></pre>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-057/javier-luque/raku/ch-1.p6">Javier Luque</a> wrote a full-fledged object-oriented program, with a <code>BTree</code> class that has a <code>Node</code> class composed into it and a number of methods, including the  <code>print-tree</code> and recursive <code>invert-tree</code> multi methods to do the work:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6">class BTree {

    <span style="color:#66d9ef">my</span> class Node {
        has Int $<span style="color:#960050;background-color:#1e0010">.</span>value is rw;
        has Node $<span style="color:#960050;background-color:#1e0010">.</span>left is rw;
        has Node $<span style="color:#960050;background-color:#1e0010">.</span>right is rw;
    };

    has Node $<span style="color:#960050;background-color:#1e0010">.</span>root is rw;

    <span style="color:#75715e"># Create the binary trees</span>
    multi method create<span style="color:#f92672">-</span>btree($data) {
        self<span style="color:#f92672">.</span>root <span style="color:#f92672">=</span> Node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>;
        self<span style="color:#f92672">.</span>create<span style="color:#f92672">-</span>btree($data, self<span style="color:#f92672">.</span>root)
    }

    multi method create<span style="color:#f92672">-</span>btree($data, Node $node) {
        $node<span style="color:#f92672">.</span>value <span style="color:#f92672">=</span> $data<span style="color:#f92672">.</span>[<span style="color:#ae81ff">0</span>];

        <span style="color:#75715e"># Left branch</span>
        <span style="color:#66d9ef">if</span> ($data<span style="color:#f92672">.</span>[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>[<span style="color:#ae81ff">0</span>]) {
        	$node<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>();
        	self<span style="color:#f92672">.</span>create<span style="color:#f92672">-</span>btree($data<span style="color:#f92672">.</span>[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>[<span style="color:#ae81ff">0</span>], $node<span style="color:#f92672">.</span>left);
        }

        <span style="color:#75715e"># Right branch</span>
        <span style="color:#66d9ef">if</span> ($data<span style="color:#f92672">.</span>[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>[<span style="color:#ae81ff">1</span>]) {
        	$node<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>();
        	self<span style="color:#f92672">.</span>create<span style="color:#f92672">-</span>btree($data<span style="color:#f92672">.</span>[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>[<span style="color:#ae81ff">1</span>], $node<span style="color:#f92672">.</span>right);
        }
    }

    <span style="color:#75715e"># Print the tree</span>
    multi method <span style="color:#66d9ef">print</span><span style="color:#f92672">-</span>tree() {
        self<span style="color:#f92672">.</span><span style="color:#66d9ef">print</span><span style="color:#f92672">-</span>tree(self<span style="color:#f92672">.</span>root);
    }

    multi method <span style="color:#66d9ef">print</span><span style="color:#f92672">-</span>tree(Node $node) {
        <span style="color:#66d9ef">my</span> $left <span style="color:#f92672">=</span> ($node<span style="color:#f92672">.</span>left) ??
        	self<span style="color:#f92672">.</span><span style="color:#66d9ef">print</span><span style="color:#f92672">-</span>tree($node<span style="color:#f92672">.</span>left) <span style="color:#f92672">!!</span>
        	Nil;

        <span style="color:#66d9ef">my</span> $right <span style="color:#f92672">=</span> ($node<span style="color:#f92672">.</span>right) ??
        	self<span style="color:#f92672">.</span><span style="color:#66d9ef">print</span><span style="color:#f92672">-</span>tree($node<span style="color:#f92672">.</span>right) <span style="color:#f92672">!!</span>
        	Nil;

        <span style="color:#66d9ef">my</span> $lists <span style="color:#f92672">=</span> ($left <span style="color:#f92672">||</span> $right) ??
                    <span style="color:#e6db74">&#39; =&gt; &#39;</span> <span style="color:#f92672">~</span> <span style="color:#e6db74">&#34;[ $left, $right ]&#34;</span> <span style="color:#f92672">!!</span>
                    <span style="color:#e6db74">&#39;&#39;</span>;

        <span style="color:#66d9ef">return</span> $node<span style="color:#f92672">.</span>value <span style="color:#f92672">~</span> $lists;
    }

    <span style="color:#75715e"># Invert the tree</span>
    multi method invert<span style="color:#f92672">-</span>tree() {
        self<span style="color:#f92672">.</span>invert<span style="color:#f92672">-</span>tree(self<span style="color:#f92672">.</span>root);
    }

    multi method invert<span style="color:#f92672">-</span>tree(Node $node) {
        <span style="color:#75715e"># Branch left</span>
        self<span style="color:#f92672">.</span>invert<span style="color:#f92672">-</span>tree( $node<span style="color:#f92672">.</span>left )
        	<span style="color:#66d9ef">if</span> ($node<span style="color:#f92672">.</span>left);

        <span style="color:#75715e"># Branch right</span>
        self<span style="color:#f92672">.</span>invert<span style="color:#f92672">-</span>tree( $node<span style="color:#f92672">.</span>right )
        	<span style="color:#66d9ef">if</span> ($node<span style="color:#f92672">.</span>right);

        <span style="color:#75715e"># Invert</span>
        <span style="color:#66d9ef">my</span> $temp <span style="color:#f92672">=</span> $node<span style="color:#f92672">.</span>left;
        $node<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> $node<span style="color:#f92672">.</span>right;
        $node<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> $temp;
    }
}
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-057/mohammad-anwar/raku/ch-1.p6">Mohammad S. Anwar</a> used a hash of arrays of arrays to represent the binary tree and the <code>mirror</code> recursive subroutine to perform the tree inversion:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">my</span> $tree <span style="color:#f92672">=</span> {
     <span style="color:#ae81ff">1</span> <span style="color:#f92672">=&gt;</span> [ [ <span style="color:#ae81ff">2</span>,
              [ [ <span style="color:#ae81ff">4</span> ],
                [ <span style="color:#ae81ff">5</span> ],
              ],
            ],
            [ <span style="color:#ae81ff">3</span>,
              [ [ <span style="color:#ae81ff">6</span> ],
                [ <span style="color:#ae81ff">7</span> ],
              ],
            ],
          ],
};

say sprintf(<span style="color:#e6db74">&#34;Before: %s&#34;</span>, $tree<span style="color:#f92672">.</span>raku);
mirror($tree<span style="color:#f92672">.</span>{<span style="color:#ae81ff">1</span>});
say sprintf(<span style="color:#e6db74">&#34;After : %s&#34;</span>, $tree<span style="color:#f92672">.</span>raku);

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">mirror</span>($branch) {

    ($branch<span style="color:#f92672">.</span>[<span style="color:#ae81ff">0</span>], $branch<span style="color:#f92672">.</span>[<span style="color:#ae81ff">1</span>]) <span style="color:#f92672">=</span> ($branch<span style="color:#f92672">.</span>[<span style="color:#ae81ff">1</span>], $branch<span style="color:#f92672">.</span>[<span style="color:#ae81ff">0</span>]);
    mirror($branch<span style="color:#f92672">.</span>[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">1</span>]) <span style="color:#66d9ef">if</span> defined $branch<span style="color:#f92672">.</span>[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">1</span>];
    mirror($branch<span style="color:#f92672">.</span>[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>]) <span style="color:#66d9ef">if</span> defined $branch<span style="color:#f92672">.</span>[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>];

    <span style="color:#66d9ef">return</span> $branch;
}
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-057/ruben-westerberg/raku/ch-1.p6">Ruben Westerberg</a> used a hash of hashes to represent the binary tree:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">my</span> $tree<span style="color:#f92672">=</span>{
    v<span style="color:#f92672">=&gt;</span><span style="color:#ae81ff">1</span>,
    l<span style="color:#f92672">=&gt;</span>{
    	v<span style="color:#f92672">=&gt;</span><span style="color:#ae81ff">2</span>,
    	l<span style="color:#f92672">=&gt;</span>{
    		v<span style="color:#f92672">=&gt;</span><span style="color:#ae81ff">4</span>
    	},
    	r<span style="color:#f92672">=&gt;</span>{
    		v<span style="color:#f92672">=&gt;</span><span style="color:#ae81ff">5</span>
    	}
    },
    r<span style="color:#f92672">=&gt;</span>{
    	v<span style="color:#f92672">=&gt;</span><span style="color:#ae81ff">3</span>,
    	l<span style="color:#f92672">=&gt;</span>{
    		v<span style="color:#f92672">=&gt;</span><span style="color:#ae81ff">6</span>
    	},
    	r<span style="color:#f92672">=&gt;</span>{
    		v<span style="color:#f92672">=&gt;</span><span style="color:#ae81ff">7</span>
    	}
    }
};
</code></pre></div><p>Rather than using a recursive subroutine, Ruben used a stack to walk through the tree depth-first:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">my</span> @stack<span style="color:#f92672">=</span>($tree);

<span style="color:#66d9ef">while</span> @stack {
    given (@stack<span style="color:#f92672">.</span>shift) {
    	<span style="color:#66d9ef">if</span> all <span style="color:#f92672">.</span>{<span style="color:#f92672">&lt;</span>l r<span style="color:#f92672">&gt;</span>}:exists {
    		<span style="color:#66d9ef">my</span> $t<span style="color:#f92672">=.</span><span style="color:#e6db74">&lt;l&gt;</span>;
    		<span style="color:#f92672">.</span><span style="color:#e6db74">&lt;l&gt;</span><span style="color:#f92672">=.</span><span style="color:#e6db74">&lt;r&gt;</span>;
    		<span style="color:#f92672">.</span><span style="color:#e6db74">&lt;r&gt;</span><span style="color:#f92672">=</span>$t;
    		@stack<span style="color:#f92672">.</span>push: <span style="color:#f92672">.</span><span style="color:#e6db74">&lt;l&gt;</span>;
    		@stack<span style="color:#f92672">.</span>push: <span style="color:#f92672">.</span><span style="color:#e6db74">&lt;r&gt;</span>;
    		say  $_;
    	}
    }
}
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-057/ulrich-rieke/raku/ch-1.p6">Ulrich Rieke</a> used what I called a flat array (or binary-heap-like data structure) to represent and create the binary tree:</p>
<p>sub createTree( Int $depth ) {
return (1..(2 ** $depth) - 1 ).Array ;
}</p>
<p>With the choice of this data structure, the <code>inverTree</code> subroutine doesn&rsquo;t need recursion and can use simple <code>for</code> loops:</p>
<pre><code>sub invertTree( @array ) {
  my @inverted ;
  my $depth = log( @array.elems + 1 , 2 ) ;
  for ( 0..$depth - 1 ) -&gt; $i {
      my @partialarray ;
      my $howmany = 2 ** $i ;
      if ( $howmany == 1 ) {
    @partialarray.push( @array.shift ) ;
      }
      else {
    for (1..$howmany) {
        @partialarray.push( @array.shift ) ;
    }
      }
      @partialarray .= reverse ;
      @inverted.push( @partialarray ) ;
  }
  return @inverted.flat ;
}

sub MAIN( Int $depth ) {
  say invertTree( createTree( $depth ) ) ;
}
</code></pre><p>I admit that this is sort of nitpicking, but the structure of the inverted tree is not the same as the structure of the input array.</p>
<p>For example, with a depth of 4, the input array is represented as this flat array:</p>
<pre><code>[1 2 3 4 5 6 7 8 9 10 11 12 13 14 15]
</code></pre>
<p>But the output array is an array of arrays like so:</p>
<pre><code>([1] [3 2] [7 6 5 4] [15 14 13 12 11 10 9 8])
</code></pre>
<p>Flattening this should not be very difficult.</p>
<hr>
<h2 id="see-also">SEE ALSO</h2>
<p>Five blog posts on the subject:</p>
<ul>
<li>
<p>Arne Sommer: <a href="https://raku-musings.com/inverted-prefix.html;">https://raku-musings.com/inverted-prefix.html;</a></p>
</li>
<li>
<p>Luca Ferrari: <a href="https://fluca1978.github.io/2020/04/20/PerlWeeklyChallenge57.html;">https://fluca1978.github.io/2020/04/20/PerlWeeklyChallenge57.html;</a></p>
</li>
<li>
<p>Shahed Nooshmand: <a href="https://rafraichisso.ir/2020/04/22/pwc-57;">https://rafraichisso.ir/2020/04/22/pwc-57;</a></p>
</li>
<li>
<p>Javie Luque: <a href="https://perlchallenges.wordpress.com/2020/04/20/perl-weekly-challenge-057/;">https://perlchallenges.wordpress.com/2020/04/20/perl-weekly-challenge-057/;</a></p>
</li>
<li>
<p>Mohammad S. Anwar: <a href="https://perlweeklychallenge.org/blog/weekly-challenge-057">https://perlweeklychallenge.org/blog/weekly-challenge-057</a>.</p>
</li>
</ul>
<h2 id="wrapping-up">Wrapping up</h2>
<p>Please let me know if I forgot any of the challengers or if you think my explanation of your code misses something important (send me an e-mail or just raise an issue against this GitHub page).</p>
<p>If you want to participate to the Perl Weekly Challenge, please connect to <a href="https://perlweeklychallenge.org/">this site</a>.</p>

                </div>
            </div>
        </div>
    </div>
</section>


<!-- Call To Action Section Start -->
<section id="call-to-action">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2 class="title wow fadeInDown" data-wow-delay=".3s" data-wow-duration="500ms">SO WHAT DO YOU THINK ?</h2>
                    <p class="wow fadeInDown" data-wow-delay=".5s" data-wow-duration="500ms">If you have any suggestions or ideas then please do share with us.</p>
                    <a href="/contact" class="btn btn-default btn-contact wow fadeInDown" data-wow-delay=".7s" data-wow-duration="500ms">Contact with me</a>
                </div>
            </div>

        </div>
    </div>
</section>
<!-- Call To Action Section End -->



<!-- Footer Section Start -->
<footer id="footer">
    <div class="container">
        <div class="row content-justify-between">
            <div class="col-md-8 col-12 text-center text-lg-left text-md-left">
                <p class="copyright">Copyright:
                    <span>
                        2019 - 2024
                    </span> The Weekly Challenge. Theme Design and Developed by
                    <a href="http://www.Themefisher.com" rel="noreferrer" rel="noreferrer" target="_blank">Themefisher</a>.
                </p>
            </div>
            <div class="col-md-4 col-12">
                <!-- Social Media -->
                <ul class="social text-center text-md-right text-lg-right">
                    <li>
                        <a href="https://twitter.com/PerlWChallenge" class="twitter" rel="noreferrer" target="_blank" title="Follow us">
                            <i class="ion-social-twitter"></i>
                        </a>
                    </li>
                    <li>
                        <a href="/rss.xml" class="rss" target="_blank" title="RSS Feed">
                            <i class="ion-social-rss"></i>
                        </a>
                    </li>
                </ul>
            </div>
        </div>
    </div>
</footer>
<!-- footer section end -->

<!-- jquery -->
<script src="https://theweeklychallenge.org/plugins/jquery/jquery.min.js"></script>
<!-- Form Validation -->
<script src="https://theweeklychallenge.org/plugins/form-validation/jquery.form.min.js"></script>
<script src="https://theweeklychallenge.org/plugins/form-validation/jquery.validate.min.js"></script>
<!-- slick slider -->
<script src="https://theweeklychallenge.org/plugins/slick/slick.min.js"></script>
<!-- bootstrap js -->
<script src="https://theweeklychallenge.org/plugins/bootstrap/bootstrap.min.js"></script>
<!-- chart js -->
<script src="https://theweeklychallenge.org/plugins/chart/highstock.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/drilldown.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/data.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/chart.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/pwc-challenge.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/gc-challenge.js"></script>
<!-- wow js -->
<script src="https://theweeklychallenge.org/plugins/wow-js/wow.min.js"></script>
<!-- slider js -->
<script src="https://theweeklychallenge.org/plugins/slider/slider.js"></script>
<!-- Fancybox -->
<script src="https://theweeklychallenge.org/plugins/facncybox/jquery.fancybox.js"></script>
<!-- template main js -->

<script src="https://theweeklychallenge.org/js/script.min.js"></script>
<!-- google analitycs -->

<script async src="https://www.googletagmanager.com/gtag/js?id=G-CJTPYM9SB8"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-CJTPYM9SB8');
</script>
</body>

</html>

