<!DOCTYPE html>
<html class="no-js" lang="en-us">
<head>
    <!-- Basic Page Needs -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:title"       content="Colin Crain › Perl Weekly Review #115"/>
    <meta property="og:type"        content="website"/>
    <meta property="og:url"         content="https://theweeklychallenge.org/blog/review-challenge-115/"/>
    <meta property="og:image"       content="https://theweeklychallenge.org/images/about/about.jpg"/>
    <meta property="og:description" content="Colin Crain › Perl Weekly Review #115"/>
    <meta name="twitter:card"       content="summary" />
    <meta name="twitter:image"      content="https://theweeklychallenge.org/images/about/about.jpg"/>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <meta name="description" content="Colin Crain › Perl Weekly Review #115">
    <meta name="author" content="The Weekly Challenge Team">
    <meta name="generator" content="Hugo 0.67.0-DEV" />

    <link rel="me" href="https://fosstodon.org/@manwar">
    <link rel="canonical" href="https://theweeklychallenge.org/blog/review-challenge-115/" />

    <!-- Mobile Specific Metas -->
    <meta name="format-detection" content="telephone=no">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Colin Crain › Perl Weekly Review #115</title>
    <link rel="icon" href="https://theweeklychallenge.org/images/favicon.ico">

    
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css"/>

    <!-- Twitter Bootstrs CSS -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/bootstrap/bootstrap.min.css">
    <!-- Ionicons Fonts Css -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/ionicons/ionicons.min.css">
    <!-- animate css -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/animate-css/animate.css">
    <!-- Hero area slider css-->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/slider/slider.css">
    <!-- slick slider -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/slick/slick.css">
    <!-- Fancybox -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/facncybox/jquery.fancybox.css">
    <!-- hover -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/hover/hover-min.css">
    <!-- Google fonts -->
    <link href='https://fonts.googleapis.com/css?family=Source Code Pro' rel='stylesheet'>
    <!-- template main css file -->
    
    <link rel="stylesheet" href="https://theweeklychallenge.org/css/style.min.css" integrity="" media="screen">
    <link rel="stylesheet" href="https://theweeklychallenge.org/css/main.css">

    <style>
        #goTopButton {
            display: none;          
            position: fixed;        
            bottom: 20px;           
            right: 30px;            
            z-index: 99;            
            border: none;           
            outline: none;          
            background-color: red;  
            color: white;           
            cursor: pointer;        
            padding: 15px;          
            border-radius: 10px;    
            font-size: 18px;        
        }

        #goTopButton:hover {
              background-color: #555;
        }

        
        .toggle-links {
            margin: 15px 0;
            padding-left: 15px;
        }
        .toggle-links a {
            display: inline-flex;
            align-items: center;
            padding: 8px 16px;
            border-radius: 20px;
            background-color: #4285f4;
            color: white !important;
            text-decoration: none;
            font-weight: 500;
            transition: background-color 0.2s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .toggle-links a:hover {
            background-color: #3367d6;
        }
        .arrow-icon {
            margin-left: 8px;
            font-size: 1.1em;
        }

    </style>


</head>

<body>

<button onclick="goTop()" id="goTopButton" title="Go to top">Top</button>

<script>

    topButton = document.getElementById("goTopButton");

    
    window.onscroll = function() { scrollFunction() };

    function scrollFunction() {
        if (document.body.scrollTop > 40 || document.documentElement.scrollTop > 40) {
            topButton.style.display = "block";
        } else {
            topButton.style.display = "none";
        }
    }

    
    function goTop() {
        document.body.scrollTop = 0; 
        document.documentElement.scrollTop = 0; 
    }

    
    document.addEventListener('DOMContentLoaded', function() {
        
        const showMoreLinkGC = document.querySelector('.show-more-gc');
        const showLessLinkGC = document.querySelector('.show-less-gc');
        const hiddenLinksGC = document.querySelectorAll('.hidden-link-gc');

        if (showMoreLinkGC) {
            showMoreLinkGC.addEventListener('click', function(e) {
                e.preventDefault();
                hiddenLinksGC.forEach(link  => {
                    link.style.display = 'list-item';
                });
                showMoreLinkGC.style.display = 'none';
                showLessLinkGC.style.display = 'inline-flex';
            });
        }

        if (showLessLinkGC) {
            showLessLinkGC.addEventListener('click', function(e) {
                e.preventDefault();
                hiddenLinksGC.forEach(link  => {
                    link.style.display = 'none';
                });
                showLessLinkGC.style.display = 'none';
                showMoreLinkGC.style.display = 'inline-flex';
            });
        }

        
        const showMoreLinkPWC = document.querySelector('.show-more-pwc');
        const showLessLinkPWC = document.querySelector('.show-less-pwc');
        const hiddenLinksPWC = document.querySelectorAll('.hidden-link-pwc');

        if (showMoreLinkPWC) {
            showMoreLinkPWC.addEventListener('click', function(e) {
                e.preventDefault();
                hiddenLinksPWC.forEach(link  => {
                    link.style.display = 'list-item';
                });
                showMoreLinkPWC.style.display = 'none';
                showLessLinkPWC.style.display = 'inline-flex';
            });
        }

        if (showLessLinkPWC) {
            showLessLinkPWC.addEventListener('click', function(e) {
                e.preventDefault();
                hiddenLinksPWC.forEach(link  => {
                    link.style.display = 'none';
                });
                showLessLinkPWC.style.display = 'none';
                showMoreLinkPWC.style.display = 'inline-flex';
            });
        }
    });

</script>

<section class="top-bar animated-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-12">
                <nav class="navbar navbar-expand-lg navbar-light bg-light">
                    <a class="navbar-brand" href="https://theweeklychallenge.org/">
                        <img src="https://theweeklychallenge.org/images/logo.svg" alt="logo">
                    </a>

                    <button class="navbar-toggler d-lg-none"
                            type="button"
                            data-toggle="collapse"
                            data-target="#navigation"
                            aria-controls="navigation"
                            aria-expanded="false"
                            aria-label="Toggle navigation">
                        <span class="navbar-toggler-icon"></span>
                    </button>

                    <div class="navbar-collapse" id="navigation">
                        <ul class="navbar-nav ml-auto">
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/">Home</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/about">About</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/chart">Chart</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/champions">Champions</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/team">Team</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/challenges">Challenges</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/p5-reviews">Perl/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/p6-reviews">Raku/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/recaps">Recaps</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/blogs">Blogs</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/faq">FAQ</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/contact">Contact</a>
                            </li>
                            
                        </ul>
                    </div>
                </nav>
            </div>
        </div>
    </div>
</section>


<section class="global-page-header">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2>Colin Crain › Perl Weekly Review #115</h2>
                    <div class="portfolio-meta">
                        <span>Friday, Jun 25, 2021</span>|
                        <span> Tags:
                            perl
                        </span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

<section class="single-post">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                
                <div style="text-align: center" class="post-img">
                    <img class="img-fluid" alt="" src="https://theweeklychallenge.org/images/blog/p5-review-challenge-115.jpg">
                </div>
                
                <div style="text-align: justify" class="post-content">
                    <p>( <em>&hellip;continues from <a href="/blog/review-challenge-114/">previous week</a>.</em> )</p>
<p>Welcome to the Perl review for <strong>Week 115</strong> of the Weekly Challenge! Here we will take the time to discuss the  submissions offered by the team, factor out the common methodologies that came up in those solutions, and highlight some of the unique approaches and unusual code created.</p>
<hr>
<h3 id="why-do-we-do-these-challenges">Why do we do these challenges?</h3>
<p>I suppose any answers to that would be as wide ranging and varied as the people who choose to join the team. One thing is clear: it&rsquo;s not a competition, and there are no judges, even if there is a &ldquo;prize&rdquo; of sorts. About that &ndash; I think of it more as an honorarium periodically awarded to acknowledge the efforts we make towards this strange goal. So there&rsquo;s no determination to find the <em>fastest</em>, or the <em>shortest</em>, or even, in some abstract way, the <em>best</em> way to go about things, although I&rsquo;m certain the individuals have their own aspirations and personal drives. As Perl is such a wonderfully expressive language, this provides quite a bit of fodder to the core idea of TMTOWTDI, producing a gamut of wonderfully varied techniques and solutions.</p>
<p>Even the tasks themselves are often open to a certain amount of discretionary interpretation. What we end up with is a situation where each participant is producing something in the manner they find the most interesting or satisfying. Some team members focus on carefully crafted complete applications that thoroughly vet input data and handle every use case they can think up. Others chose to apply themselves to the logic of the underlying puzzle and making it work in the most elegant way they can. Some eschew modules they would ordinarily reach for, others embrace them, bringing to light wheels perhaps invented years ago that happen to exactly solve the problem in front of them today.</p>
<p>I&rsquo;ve been considering this question for some time and have found one binding commonality between all of us solving these challenges each week, in that however we normally live our lives, the task in front of us more than likely has nothing to do with any of that . And I think this has great value. We all do what we do, out in the real world, and hopefully we do it well. The Weekly Challenge provides a opportunity to do something germane to that life yet distinctly different; if we only do the things we already know how to do we only do the same things over and over. This is where the &ldquo;challenge&rdquo; aspect comes into play.</p>
<p>So we can consider the Weekly Challenge as providing a problem space outside of our comfort zone, as far out from comfort as we wish to take things. From those reaches we can gather and learn things and bring what we want back into our lives. Personally, I think that&rsquo;s its greatest value of all.</p>
<hr>
<p>Every week there is an enormous global collective effort made by the team, analyzing and creatively coding the submissions, and that effort deserves credit due. And that&rsquo;s why I&rsquo;m here, to try and figure out how to do that.</p>
<p>Let&rsquo;s have a look and see what we can find.</p>
<hr>
<p><strong><big>For context</big></strong>  before we begin, you may wish to revisit either of the pages for the <a href="/blog/perl-weekly-challenge-115/"><strong>original tasks</strong></a> or the summary <a href="/blog/recap-challenge-115/"><strong>recap</strong></a> of the challenge. But don&rsquo;t worry, the challenges themselves will be briefly summarized, presented below as we progress from task by task. Oh, and one more thing before we get started:</p>
<h3 id="getting-in-touch-with-us">Getting in Touch with Us</h3>
<p><a href="mailto:pwc.perfectwave@gmail.com"><img src="/images/blog/Email.svg" height="50" width="50"> Email</a> › Please email me (Colin) with any feedback, notes, clarifications or whatnot about this review.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge"><img src="/images/blog/Github.svg" height="50" width="50"> GitHub</a> › Submit a pull request to us for any issues you may find with this page.</p>
<p><a href="https://twitter.com/perlwchallenge"><img src="/images/blog/Twitter.svg" height="50" width="50"> Twitter</a> › Join the discussion on Twitter!</p>
<p>I&rsquo;m always curious as to what the people think of these efforts. Everyone here at the PWC would like to hear any feedback you&rsquo;d like to give.</p>
<p><strong>So finally, without further ado&hellip;</strong></p>
<hr>
<h2 id="---nbsp--nbsp--nbsp---task-1pwc115task1-------nbsp--nbsp--nbsp------nbsp--nbsp--nbsp---task-2pwc115task2---nbsp--nbsp--nbsp------nbsp--nbsp--nbsp---blogspwc115blogs----nbsp--nbsp--nbsp---">•             <a href="#PWC115TASK1">Task 1</a>                 •             <a href="#PWC115TASK2">Task 2</a>             	•             <a href="#PWC115BLOGS">BLOGS</a>              	•</h2>
<hr>
<h1 id="PWC115TASK1">TASK 1</h1>
<h1 id="string-chain">String Chain</h1>
<p><em>Submitted by: Mohammad S Anwar</em><br>
You are given an array of strings.</p>
<p>Write a script to find out if the given strings can be chained to form a circle. Print 1 if found otherwise 0.</p>
<p>A string $S can be put before another string $T in circle if the last character of $S is same as first character of $T.</p>
<p><strong>Examples:</strong></p>
<pre><code>    Input: @S = (&quot;abc&quot;, &quot;dea&quot;, &quot;cd&quot;)
    Output: 1 as we can form circle e.g. &quot;abc&quot;, &quot;cd&quot;, &quot;dea&quot;.

    Input: @S = (&quot;ade&quot;, &quot;cbd&quot;, &quot;fgh&quot;)
    Output: 0 as we can't form circle.
</code></pre><h2 id="about-the-solutions">about the solutions</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/abigail/perl/ch-1.pl"><strong>Abigail</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/adam-russell/perl/ch-1.pl"><strong>Adam Russell</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/arne-sommer/perl/ch-1.pl"><strong>Arne Sommer</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/brtastic/perl/ch-1.pl"><strong>Bartosz Jarzyna</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/cheok-yin-fung/perl/ch-1.pl"><strong>Cheok-Yin Fung</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/colin-crain/perl/ch-1.pl"><strong>Colin Crain</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/dave-jacoby/perl/ch-1.pl"><strong>Dave Jacoby</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/duncan-c-white/perl/ch-1.pl"><strong>Duncan C. White</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/e-choroba/perl/ch-1.pl"><strong>E. Choroba</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/polettix/perl/ch-1.pl"><strong>Flavio Poletti</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/james-smith/perl/ch-1.pl"><strong>James Smith</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/jo-37/perl/ch-1.pl"><strong>Jorg Sommrey</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/laurent-rosenfeld/perl/ch-1.pl"><strong>Laurent Rosenfeld</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/perlboy1967/perl/ch-1.pl"><strong>Niels van Dijke</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/pete-houston/perl/ch-1.pl"><strong>Pete Houston</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/roger-bell-west/perl/ch-1.pl"><strong>Roger Bell_West</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/sgreen/perl/ch-1.pl"><strong>Simon Green</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/stuart-little/perl/ch-1.pl"><strong>Stuart Little</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/wlmb/perl/ch-1.pl"><strong>W. Luis Mochan</strong></a></p>
<p>There were 19 working submissions for the first task this past week. At least I think there were. Something like that, at least.</p>
<p>To explain:</p>
<p>The definition of this challenge proved to be a bit trickier and more confusing than it first appeared, with a few undefined loose ends arising that needed to be clarified before attempting a solution. For instance, although there was a large degree of consensus that every string needed to be used in a chain, this is not actually clearly stated, and so this wasn&rsquo;t true for all submissions. Although on the whole I like variation in both the methods and the questions, in the end I do need to spend a cetain amount of extra time figuring out exactly what question is being answered. With my guiding rule being that the solution successfully solves the interpretation of the task, this understanding is pretty essential, and unfortunately not always obvious.</p>
<p>So what did we see? It turns out a lot of different types of chainings can arise. We can, of course, have one complete chain that uses all of the elements and links back to the beginning of the first link. Then again we can also have the case where the links may cycle, but form two or more independant loops, and we need to watch for this. Take these six strings, for example, that all get used in the following configuration:</p>
<p><strong>ab</strong> → <strong>bc</strong> → <strong>ca</strong>  <br>
<strong>xy</strong> → <strong>yz</strong> → <strong>za</strong></p>
<p>We end up with two cycles and ne&rsquo;er the twain shall meet.</p>
<p>Or here&rsquo;s a tricky one — a chain that crosses over itself in the middle so it <em>appears</em> to be a two independant chains, but still can be configured as one single linkage:</p>
<p><strong>ab</strong> → <strong>bc</strong> → <strong>ca</strong>  ( → ) <br>
<strong>ax</strong> → <strong>xy</strong> → <strong>ya</strong></p>
<p>This extra interconnectedness had the potential to cause some confusion, and needed to be accommodated with some of the techniques we saw. At the end we&rsquo;ll touch on an algorithm specifically designed to address this circumstance.</p>
<p>Or what about duplicate strings? Again the case is undefined.</p>
<p><strong>aaa</strong> → <strong>aaa</strong> → <strong>aaa</strong> → <strong>aaa</strong> → <strong>aaa</strong> → <strong>aaa</strong></p>
<p>This degenerate case obviously will cycle, but if we just remove &ldquo;aaa&rdquo; from the running after using it, well, that&rsquo;s not going to work. Again we did see this complication out in the wild.</p>
<p>I ended up thinking about failure modes <em>way</em> too much, and ended mostly throwing my hands in the air and moving forward as best I could. So, as I said, I <em>think</em> they work. Thinking up new ways to break stuff, despite appearances, does not give me pleasure and I&rsquo;d much rather move on. Caveat emptor.</p>
<p>There was one situation that stood out, however, which was simply testing for matching numbers of starting and ending instances for characters amongst the set of strings. Although if this is <em>not</em> true a single chain can never be formed, if this <em>is</em> true we cannot know that a connective through-line will trace a single loop without further testing. As this algorithm wants to use every string but cannot say whether a single chain can be formed I concluded in this case this technique on its own was not up to to the task. Sorry. For ways around this have a look to the final graph theory section.</p>
<h2 id="start-tracing-connections">start TRACING CONNECTIONS</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/colin-crain/perl/ch-1.pl"><strong>Colin Crain</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/duncan-c-white/perl/ch-1.pl"><strong>Duncan C. White</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/e-choroba/perl/ch-1.pl"><strong>E. Choroba</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/james-smith/perl/ch-1.pl"><strong>James Smith</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/pete-houston/perl/ch-1.pl"><strong>Pete Houston</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/roger-bell-west/perl/ch-1.pl"><strong>Roger Bell_West</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/sgreen/perl/ch-1.pl"><strong>Simon Green</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/stuart-little/perl/ch-1.pl"><strong>Stuart Little</strong></a></p>
<p>By keeping track of lists of strings that start with a certain letter, limiting options as strings are used in a chain attempt, we can start tracing partial pathways until we find one that finishes. Although recursion is well suited to the task its not a necessary technique, and we saw this done with various loop constructs as well.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/sgreen/perl/ch-1.pl"><strong>Simon Green</strong></a></p>
<p>Simon starts the ball rolling with a nice demonstration of a recursive search. We&rsquo;re passed in a partial chain as an array with an accompanying list of remaining strings. Inside, we filter the remaining list for those that start with the last letter in our partial chain and then for each word found we try adding it to the partial, removing the first instance of the word from the remaining list and going through again.</p>
<p>The base cases are running out of possibilities when we still have strings remaining, a no go, and successfully running out of remaining words. Should this happen we still need to check to see whether we can loop back to the start, but if we can we return 1.</p>
<p>If a 1 is ever returned it is immediately passed through as the recursion collapses.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">_reduce_list</span> {
        <span style="color:#66d9ef">my</span> ( $used, $list ) <span style="color:#f92672">=</span> @_;

        <span style="color:#66d9ef">if</span> (@$list) {
            <span style="color:#75715e"># We have words to use. Choose the words that begin with the last</span>
            <span style="color:#75715e">#  letter of the last word</span>
            <span style="color:#66d9ef">my</span> @can_use <span style="color:#f92672">=</span> grep { substr( $_, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span> ) <span style="color:#f92672">eq</span> substr( $used<span style="color:#f92672">-&gt;</span>[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> ) } @$list;

            <span style="color:#75715e"># Recursive call this function with each of these words</span>
            <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $word (@can_use) {
                <span style="color:#75715e"># Return &#39;1&#39; if we have a result</span>
                <span style="color:#66d9ef">my</span> $result <span style="color:#f92672">=</span> _reduce_list( [ @$used, $word ], _remove_word( $word, $list ) );
                <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">if</span> $result;
            }

            <span style="color:#75715e"># There is no solution that exist</span>
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
        }

        <span style="color:#75715e"># We have use all the words. We need to check we can complete the</span>
        <span style="color:#75715e">#  circle by checking if the first letter of the first word is the</span>
        <span style="color:#75715e">#  same as the last letter of the last word</span>
        <span style="color:#66d9ef">return</span> substr( $used<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>], <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span> ) <span style="color:#f92672">eq</span> substr( $used<span style="color:#f92672">-&gt;</span>[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> ) ? <span style="color:#ae81ff">1</span> : <span style="color:#ae81ff">0</span>;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/colin-crain/perl/ch-1.pl"><strong>My Own Solution</strong></a></p>
<p><strong>additional languages:</strong>
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/colin-crain/raku/ch-1.raku">Raku</a></p>
<p>For my own version of recursion I mixed it up a little, as I find simple 1/0 results a little&hellip; boring if you must know. I prefer to witness the glorious product of my data-processing, so instead of returning 1 in a positive result I return a joined-up string from the solution array instead. Practically, the base cases remain the same, with the control flow slightly reordered.</p>
<p>If an string is returned we present it or say &ldquo;no chain&rdquo;.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">chain</span> ($strings, $chain = []) {
        $chain<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> shift $strings<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span> if <span style="color:#f92672">not</span> defined $chain<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>];

        <span style="color:#75715e">## base: if no more in pool check last loop link</span>
        <span style="color:#66d9ef">if</span> (scalar $strings<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span> <span style="color:#960050;background-color:#1e0010">==</span> 0) {
            <span style="color:#66d9ef">return</span> join <span style="color:#e6db74">&#39; &#39;</span>, $chain<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span>
                if substr($chain<span style="color:#f92672">-&gt;</span>[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">eq</span> substr($chain<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>], <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>);
            <span style="color:#66d9ef">return</span> undef;
        }

        <span style="color:#66d9ef">my</span> @next <span style="color:#f92672">=</span> grep { substr($chain<span style="color:#f92672">-&gt;</span>[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">eq</span> substr($_, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>) } $strings<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>

        <span style="color:#960050;background-color:#1e0010">##</span> base: <span style="color:#66d9ef">no</span> next link <span style="color:#f92672">and</span> still more in pool fails
        <span style="color:#66d9ef">return</span> undef <span style="color:#66d9ef">if</span> @next <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> $strings<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span> <span style="color:#960050;background-color:#1e0010">&gt;</span> 0;

        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $link (@next) {
            <span style="color:#66d9ef">my</span> @possible <span style="color:#f92672">=</span> $strings<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>
            my $idx <span style="color:#f92672">=</span> first { $possible[$_] <span style="color:#f92672">eq</span> $link } (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$#possible);
            splice @possible, $idx, <span style="color:#ae81ff">1</span>;

            <span style="color:#66d9ef">my</span> $result <span style="color:#f92672">=</span> chain( <span style="color:#f92672">\</span>@possible, [ $chain<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span>, $link ] );

            <span style="color:#66d9ef">return</span> $result <span style="color:#66d9ef">if</span> defined $result;
        }
        <span style="color:#66d9ef">return</span> undef;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/e-choroba/perl/ch-1.pl"><strong>E. Choroba</strong></a></p>
<p>Choroba presents us with two ways to proceed: a depth-first recursive solution and a breadth-first version that loops while there are still paths to check. The <code>can_chain()</code> routine verifies whether the end character in the first argument matches the first character in the second. I like the way an array slice is used to perform the final check. Slices are just such a terrific way to select out portions or rearrange the elements in an array.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">string_chain_bf</span> {
        <span style="color:#66d9ef">my</span> ($start, @strings) <span style="color:#f92672">=</span> @_;
        <span style="color:#66d9ef">my</span> @paths <span style="color:#f92672">=</span> ([$start, <span style="color:#f92672">\</span>@strings]);
        <span style="color:#66d9ef">while</span> (@paths) {
            <span style="color:#66d9ef">my</span> @next;
            <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $path (@paths) {
                <span style="color:#66d9ef">my</span> ($so_far, $remain) <span style="color:#f92672">=</span> @$path;
                <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span> @$remain <span style="color:#f92672">&amp;&amp;</span> can_chain(@$so_far[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>]);

                <span style="color:#66d9ef">my</span> %tried;
                <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i (<span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $#$remain) {
                    <span style="color:#66d9ef">next</span> <span style="color:#66d9ef">if</span> $tried{ substr($remain<span style="color:#f92672">-&gt;</span>[$i], <span style="color:#ae81ff">0</span> , <span style="color:#ae81ff">1</span>)
                                    <span style="color:#f92672">.</span> substr $remain<span style="color:#f92672">-&gt;</span>[$i], <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> }<span style="color:#f92672">++</span>;

                    <span style="color:#66d9ef">next</span> <span style="color:#66d9ef">unless</span> can_chain($so_far<span style="color:#f92672">-&gt;</span>[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], $remain<span style="color:#f92672">-&gt;</span>[$i]);

                    push @next, [[@$so_far, $remain<span style="color:#f92672">-&gt;</span>[$i]],
                                 [@$remain[<span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, $i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> $#$remain]]];
                }
            }
            @paths <span style="color:#f92672">=</span> @next;
        }
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/james-smith/perl/ch-1.pl"><strong>James Smith</strong></a></p>
<p>James gives us a slightly simpler version of his usual comparative analysis, presenting to us today a recursive against an iterative case. He states that once the input list becomes long enough the iterative strongly takes the lead. Of note are the two lines near the top that quickly filter the frequency counts of the letters going in versus the letters exiting the strings. As we said earlier we can&rsquo;t prove the existence of a single path if these correspondances do line up, but if they don&rsquo;t there&rsquo;s no point in continuing.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    ( $F{ substr $_, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span> }<span style="color:#f92672">++</span>, $F{    substr $_, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>   }<span style="color:#f92672">--</span> ) <span style="color:#66d9ef">foreach</span> @_;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">if</span> grep {$_} values %F;
</code></pre></div><p>Here is the iterative version:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">circ_single_connected</span> {
      <span style="color:#66d9ef">my</span>(%F,%ends);

      <span style="color:#75715e">## %F    contains the number of starts - number of ends...</span>
      <span style="color:#75715e">## %ends contains a hash of hashes - first key is the first letter of the world,</span>
      <span style="color:#75715e">##                                   2nd level end of the world.</span>

      ( $F{ substr $_, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span> }<span style="color:#f92672">++</span>, $F{    substr $_, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>   }<span style="color:#f92672">--</span> ) <span style="color:#66d9ef">foreach</span> @_;
      <span style="color:#75715e">## Rule out those that cannot be connected in loop....</span>
      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">if</span> grep {$_} values %F; <span style="color:#75715e">## This quickly filters out those cases in which we</span>
                                       <span style="color:#75715e">## can&#39;t join end on end... now there is a harder</span>
                                       <span style="color:#75715e">## problem coming up which is to work out if there</span>
                                       <span style="color:#75715e">## is a multi-loop option</span>

      <span style="color:#75715e">## Now we have to see if we have connectivity...</span>
      <span style="color:#75715e">## Take any (the first) element...</span>

      $ends{ substr $_, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span> }{ substr $_, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> }<span style="color:#f92672">++</span> <span style="color:#66d9ef">foreach</span> @_;
      <span style="color:#66d9ef">my</span> @seeds <span style="color:#f92672">=</span> [keys %ends]<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>];

      <span style="color:#66d9ef">while</span>(@seeds) { <span style="color:#75715e">## If we have any seeds then we</span>
        <span style="color:#75715e">## Remove the information about ends from the list for each</span>
        <span style="color:#75715e">## letter in the seed list.. (start words)</span>
        <span style="color:#75715e">## For each of these we collect the end letters (using a hash</span>
        <span style="color:#75715e">## to uniqueify them)</span>
        <span style="color:#66d9ef">my</span> %x  <span style="color:#f92672">=</span> map { $_ <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">1</span> }
                 map { keys %{ delete $ends{$_} } }
                 @seeds;
        <span style="color:#75715e">## We then remove any letters which we have already processed</span>
        <span style="color:#75715e">## {i.e. those that have already been removed from %ends}</span>
        @seeds <span style="color:#f92672">=</span> grep { exists $ends{$_} } keys %x;
      }
      <span style="color:#75715e">## If we have stuff left it ends there will be 2 or more connected loops.</span>
      <span style="color:#66d9ef">return</span> keys %ends ? <span style="color:#ae81ff">0</span> : <span style="color:#ae81ff">1</span>;
      <span style="color:#75715e">## Now we start at any point and get the first circle....</span>
    }
</code></pre></div><h2 id="find-any-cycle">find ANY CYCLE</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/abigail/perl/ch-1.pl"><strong>Abigail</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/laurent-rosenfeld/perl/ch-1.pl"><strong>Laurent Rosenfeld</strong></a></p>
<p>A few readings of the description decided that any cyclic grouping would satisfy the conditions, even if not all of the strings were utilised. This is arguably a <em>more</em> exhaustive search as every string must be considered to possibly be part of a loop before deciding there are no cycles to be found. On the other hand, any circuit, no matter how small, can be said to satisfy the conditions, so we&rsquo;re more likely to find one quickly and stop futher search.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/laurent-rosenfeld/perl/ch-1.pl"><strong>Laurent Rosenfeld</strong></a></p>
<p><strong>additional languages:</strong>
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/laurent-rosenfeld/raku/ch-1.raku">Raku</a></p>
<p>Laurent states he saw a request for any possible chain amongst the input strings, so that is the solution he brings to us today. Although this was an uncommon reading, I think the wording is sufficiently imprecise to warrant either interpretation. The code is shorter but not necessarily simpler. It&rsquo;s just&hellip; different.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">find_circle</span> {
        <span style="color:#75715e"># remove useless strings starting and ending with the same letter</span>
        <span style="color:#66d9ef">my</span> @s <span style="color:#f92672">=</span> grep { <span style="color:#f92672">not</span> <span style="color:#e6db74">/^(\w)\w+$0$/</span>} @_;
        <span style="color:#66d9ef">my</span> %first <span style="color:#f92672">=</span> map { (substr $_, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">1</span> } @s;
        <span style="color:#66d9ef">my</span> %last  <span style="color:#f92672">=</span> map { (substr $_, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">1</span> } grep { exists $first{substr $_, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span> }}  @s;
        <span style="color:#66d9ef">return</span> scalar keys %last <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span> ? <span style="color:#ae81ff">1</span> : <span style="color:#ae81ff">0</span>;
    }
    say find_circle @s;
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/abigail/perl/ch-1.pl"><strong>Abigail</strong></a></p>
<p><strong>additional languages:</strong>
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/abigail/awk/ch-1.awk">Awk</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/abigail/bash/ch-1.sh">Bash</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/abigail/c/ch-1.c">C</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/abigail/lua/ch-1.lua">Lua</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/abigail/node/ch-1.js">Node</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/abigail/python/ch-1.py">Python</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/abigail/ruby/ch-1.rb">Ruby</a></p>
<p>&hellip;And while we&rsquo;re on the subject of different, Abigail brings us a truly unique offering; sharing, however Laurent&rsquo;s interpretation of the chaining requirements.</p>
<p>The process uses a what is known as a <a href="https://en.wikipedia.org/wiki/Transitive_closure#In_graph_theory">transitive closure</a>, which is generated using an algorithm in a module they themselves wrote and uploaded to cpan, <a href="https://metacpan.org/pod/Algorithm::Graphs::TransitiveClosure"><code>Algorithm::Graphs::TransitiveClosure</code></a>.</p>
<p>The explanation is rather technical, but gone over quite well in <a href="https://abigail.github.io/HTML/Perl-Weekly-Challenge/week-115-1.html">their extensive writeup</a>. Of special note here are the guest language submissions, which require the Floyd-Warshall algorithm to be re-implemented,</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">use</span> Algorithm::Graphs::TransitiveClosure <span style="color:#e6db74">qw [floyd_warshall];
</span><span style="color:#e6db74">
</span><span style="color:#e6db74"> </span>   <span style="color:#66d9ef">while</span> (<span style="color:#f92672">&lt;&gt;</span>) {
        <span style="color:#75715e">#</span>
        <span style="color:#75715e"># Read in the words, store them bucketed by first letter,</span>
        <span style="color:#75715e"># and in a list. We&#39;re assuming each set is on a separate</span>
        <span style="color:#75715e"># line separated by white space.</span>
        <span style="color:#75715e">#</span>
        <span style="color:#75715e"># We will create a (directed) graph from the strings in a</span>
        <span style="color:#75715e"># set; each string gives us an edge from the first letter</span>
        <span style="color:#75715e"># of the string to the last letter. (Hence, the nodes in</span>
        <span style="color:#75715e"># this graph are the first and last letters of the strings).</span>
        <span style="color:#75715e">#</span>
        <span style="color:#66d9ef">my</span> $graph;
        <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $node (split) {
            $$graph {substr $node, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>} {substr $node, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>} <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        }

        <span style="color:#75715e">#</span>
        <span style="color:#75715e"># Calculate the transitive closure.</span>
        <span style="color:#75715e">#</span>
        floyd_warshall $graph;

        <span style="color:#75715e">#</span>
        <span style="color:#75715e"># We do have a loop iff we have a node which can reach itself.</span>
        <span style="color:#75715e">#</span>
        say grep ({$$graph {$_} {$_}} keys %$graph) ? <span style="color:#ae81ff">1</span> : <span style="color:#ae81ff">0</span>;
    }
</code></pre></div><h2 id="find-all-the-cycles">find ALL THE CYCLES</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/arne-sommer/perl/ch-1.pl"><strong>Arne Sommer</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/brtastic/perl/ch-1.pl"><strong>Bartosz Jarzyna</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/dave-jacoby/perl/ch-1.pl"><strong>Dave Jacoby</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/perlboy1967/perl/ch-1.pl"><strong>Niels van Dijke</strong></a></p>
<p>Several solutions used permutations to search through all possible ways to connect the strings, validating each arrangement to find the first one to satisfy the criteria. Although potentially very complex, should any complete cycle be found further seaching is unnecessary. So good luck out there.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/dave-jacoby/perl/ch-1.pl"><strong>Dave Jacoby</strong></a></p>
<p>Dave uses <code>Algorithm::Permute</code> to construct every arrangement of the input strings. From there he can iterate through each to see whether the letters align correctly. If a circle is found the strings are output in the new ordering, which is a nice touch.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">use</span> Algorithm::Permute;

    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">is_chain</span> ( @links ) {
        <span style="color:#66d9ef">my</span> $p <span style="color:#f92672">=</span> Algorithm::Permute<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">new</span>( [@links] );
        <span style="color:#66d9ef">while</span> ( <span style="color:#66d9ef">my</span> @res <span style="color:#f92672">=</span> $p<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">next</span> ) {
            <span style="color:#66d9ef">my</span> $i <span style="color:#f92672">=</span> join <span style="color:#e6db74">&#39;-&#39;</span>, @res;
            <span style="color:#66d9ef">my</span> $c <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
            <span style="color:#66d9ef">if</span> ( f_char( $res[<span style="color:#ae81ff">0</span>] ) <span style="color:#f92672">eq</span> l_char( $res[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] ) ) {
                <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i ( <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> scalar @res ) {
                    $c<span style="color:#f92672">++</span> <span style="color:#66d9ef">if</span> l_char( $res[ $i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> ] ) <span style="color:#f92672">eq</span> f_char( $res[$i] );
                }
                <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">if</span> $c <span style="color:#f92672">==</span> scalar @links;
            }
        }

        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
    }

    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">f_char</span>( $str ) {
        <span style="color:#66d9ef">return</span> substr( $str, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span> );
    }

    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">l_char</span>( $str ) {
        <span style="color:#66d9ef">return</span> substr( $str, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> length $str, <span style="color:#ae81ff">1</span> );
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/perlboy1967/perl/ch-1.pl"><strong>Niels van Dijke</strong></a></p>
<p>Niels has gone above and beyond, creating a regular expression solution for us. First he uses one expression to reduce the input strings to just the first and last characters, simplifying the subsequent alignment task. A further regex is then generated according to the number of input strings, to internally match the correspondence within a joined-up version of the input. It&rsquo;s wild, to say the least.</p>
<p>Here&rsquo;s an example of the generated regex for a list of four strings:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    (?<span style="color:#f92672">^</span>u:<span style="color:#f92672">^</span>(<span style="color:#f92672">.</span>))(<span style="color:#f92672">.</span>)<span style="color:#f92672">\</span><span style="color:#ae81ff">2</span>(<span style="color:#f92672">.</span>)<span style="color:#f92672">\</span><span style="color:#ae81ff">3</span>(<span style="color:#f92672">.</span>)<span style="color:#f92672">\</span><span style="color:#ae81ff">4</span><span style="color:#f92672">\</span><span style="color:#ae81ff">1</span>$
</code></pre></div><p>I&rsquo;m impressed. The regex is then applied to every permutation of the input list to see if any of them match up.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">use</span> Algorithm::Combinatorics <span style="color:#e6db74">qw(permutations)</span>;

    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">isStringChain</span> {
      <span style="color:#66d9ef">my</span> (@l) <span style="color:#f92672">=</span> @_;

      <span style="color:#75715e"># We only need the first and last char</span>
      map { <span style="color:#e6db74">s/^(.).*?(.)$/$1$2/</span> } @l;

      <span style="color:#75715e"># Build regexp</span>
      <span style="color:#66d9ef">my</span> $re <span style="color:#f92672">=</span> <span style="color:#e6db74">qr &#39;^(.)&#39;.join(&#39;&#39;,map </span>{<span style="color:#e6db74">&#34;(.)\\$_&#34;</span>} (<span style="color:#ae81ff">2</span> <span style="color:#f92672">..</span> scalar @l))<span style="color:#f92672">.</span><span style="color:#e6db74">&#39;\\1$&#39;</span>;

      <span style="color:#66d9ef">my</span> $iter <span style="color:#f92672">=</span> permutations(<span style="color:#f92672">\</span>@l);
      <span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">my</span> $ar <span style="color:#f92672">=</span> $iter<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">next</span>()) {
        <span style="color:#66d9ef">if</span> (join(<span style="color:#e6db74">&#39;&#39;</span>,@$ar) <span style="color:#f92672">=~</span> m<span style="color:#75715e">#$re#) {</span>
          <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
        }
      }

      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/arne-sommer/perl/ch-1.pl"><strong>Arne Sommer</strong></a></p>
<p><strong>additional languages:</strong>
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/arne-sommer/raku/ch-1.raku">Raku</a></p>
<p>Arne provides us with an <a href="https://raku-musings.com/hamilton-unchained.html">excellent writeup on the challenge</a>, going into quite a bit of detail on directed graphs and Hamiltonian Circuits, which in turn makes a nice segue into our next section. His solution uses <code>Algorithm::Combinatorics</code> to provide a list of permutation possibilities to examine.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $list (permutations(<span style="color:#f92672">\</span>@ARGV))
    {
      <span style="color:#66d9ef">my</span> @perm <span style="color:#f92672">=</span> @$list;

      say <span style="color:#e6db74">&#34;: perm: &#34;</span> <span style="color:#f92672">.</span> join(<span style="color:#e6db74">&#34;, &#34;</span>, @perm) <span style="color:#66d9ef">if</span> $verbose;

      <span style="color:#66d9ef">if</span> (is_circle(@perm))
      {
        say <span style="color:#ae81ff">1</span>;
        exit;
      }
    }

    say <span style="color:#ae81ff">0</span>;

    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">is_circle</span> (@list)
    {
      <span style="color:#66d9ef">my</span> $first       <span style="color:#f92672">=</span> shift(@list);
      <span style="color:#66d9ef">my</span> $first_start <span style="color:#f92672">=</span> substr($first, <span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>);
      <span style="color:#66d9ef">my</span> $second;

      <span style="color:#66d9ef">while</span> (@list)
      {
        $second <span style="color:#f92672">=</span> shift(@list);
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">if</span> substr($first,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>) <span style="color:#f92672">ne</span> substr($second,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>);
        $first  <span style="color:#f92672">=</span> $second;
      }

      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">if</span> $first_start <span style="color:#f92672">eq</span> substr($second,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>);
      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
    }
</code></pre></div><h2 id="some-graph-theory">some GRAPH THEORY</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/adam-russell/perl/ch-1.pl"><strong>Adam Russell</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/cheok-yin-fung/perl/ch-1.pl"><strong>Cheok-Yin Fung</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/jo-37/perl/ch-1.pl"><strong>Jorg Sommrey</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/wlmb/perl/ch-1.pl"><strong>W. Luis Mochan</strong></a></p>
<p>Several submissions approached a solution to some degree mathematically, using graph theory. There are two basic ways to approach this, if you&rsquo;re comfortable with gross simplifications. The first way considers the strings to be the edges of a graph, connecting vertices comprised of characters, in turn defined by those string beginnings and ends. The edges have an explicit direction, going from a leading character to a trailing, so what we end up with is a form of what is known as a directed graph. Our goal, then, is to trace a line traversing every edge of this graph and ending up where we started. This path is known as an <a href="https://en.wikipedia.org/wiki/Eulerian_path">Eulerian Circuit</a>.</p>
<p>Alternately, we can consider the <em>vertices</em> of a graph to be the strings, and try and trace a path through them all that fits a rule — that the directed edge arriving matches the first letter, and the edge departing matches the last. A path connecting every vertex in a graph, ending at the vertex where it began, is known as a <a href="https://en.wikipedia.org/wiki/Hamiltonian_path">Hamiltonian Cycle</a>.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/adam-russell/perl/ch-1.pl"><strong>Adam Russell</strong></a></p>
<p>Adam has previously made mention of his interest in solving certain problems using the <code>Graph</code> module, and this task seems made to fit. The idea is to construct a directed graph from the data, then, once formed, determine whether the graph overview of connected parts is comprised of a single entity or a collection of smaller segments. This will tell us whether all the vertices can be connected to form a single path. The function used here is <code>weakly_connected_components()</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">use</span> Graph;
    <span style="color:#66d9ef">use</span> Graph::Easy::Parser;

    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">build_graph</span>{
        <span style="color:#66d9ef">my</span> @words;
        <span style="color:#66d9ef">my</span> %first_letter_name;
        <span style="color:#66d9ef">my</span> $graph <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Graph();
        <span style="color:#66d9ef">while</span>(<span style="color:#66d9ef">my</span> $s <span style="color:#f92672">=</span> <span style="color:#e6db74">&lt;DATA&gt;</span>){
            chomp($s);
            <span style="color:#66d9ef">my</span> $first_letter <span style="color:#f92672">=</span> substr($s, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>);
            <span style="color:#66d9ef">if</span>($first_letter_name{$first_letter}){
                push @{$first_letter_name{$first_letter}}, $s;
            }
            <span style="color:#66d9ef">else</span>{
                $first_letter_name{$first_letter} <span style="color:#f92672">=</span> [$s];
            }
            push @words, $s;
        }
        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $word (@words){
            $graph<span style="color:#f92672">-&gt;</span>add_vertex($word) <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>$graph<span style="color:#f92672">-&gt;</span>has_vertex($word);
            <span style="color:#66d9ef">my</span> $child_nodes <span style="color:#f92672">=</span> $first_letter_name{substr($word, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)};
            <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $n (@{$child_nodes}){
                $graph<span style="color:#f92672">-&gt;</span>add_vertex($n) <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>$graph<span style="color:#f92672">-&gt;</span>has_vertex($n);
                $graph<span style="color:#f92672">-&gt;</span>add_weighted_edge($word, $n, (<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">*</span> length($n))) <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>$graph<span style="color:#f92672">-&gt;</span>has_edge($word, $n);
                $graph<span style="color:#f92672">-&gt;</span>delete_edge($word, $n) <span style="color:#66d9ef">if</span> $graph<span style="color:#f92672">-&gt;</span>has_a_cycle();
            }
        }
        <span style="color:#66d9ef">return</span> $graph;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/wlmb/perl/ch-1b.pl"><strong>W. Luis Mochan</strong></a></p>
<p>I suppose you could consider Luis&rsquo; trio of submissions, although notably different from each other, continuous refinements toward a more perfect solution.</p>
<p>The <a href="(https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/wlmb/perl/ch-1.pl)">first method</a> involved constructing a connectivity matrix from the input data and performing some linear algebra on it using the PDL. This is a novel approach and worthy of study, but he mentions it is imperfect because certain crossed path groups can confuse it.</p>
<p>The <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/wlmb/perl/ch-1a.pl">second approach</a> comes from a very different direction. This keeps track of the actual strings instead of data representations of them, so an actual chain, if found, can be output. The algorithm produced looks a lot like one of the iterative pathfinding solutions we saw earlier. It, however, can also be confused, this time by duplicate strings.</p>
<p>The third time is the charm. Returning to the PDL, he now relates the graph to the <a href="https://en.wikipedia.org/wiki/Seven_Bridges_of_K%C3%B6nigsberg">Königsberg bridges</a> problem. In his own words:</p>
<blockquote>
<p>A mathematician (my son) suggested that the problem could be mapped to that of the Königsberg (directed) bridges if I make a graph where the land areas (the nodes) correspond to the the first and last letters, and the bridges (the edges) correspond to the words that connect the first letter to the last. Then the circle could be found if, for each node, the number of incoming and outgoing edges coincide, and if the graph is not disjoint.</p>
</blockquote>
<p>The <a href="https://wlmb.github.io/2021/06/01/PWC115/">writeup Luis provides as accompaniment</a> walks us through all three methods in great detail, even, quite respectably, including the errors he found along the way. I found it quite informative and encourage you to have a look for yourself.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">use</span> Exporter::Renaming; <span style="color:#75715e"># prevent name clashes</span>
    <span style="color:#66d9ef">use</span> List::Util Renaming<span style="color:#f92672">=&gt;</span>[uniq<span style="color:#f92672">=&gt;</span><span style="color:#e6db74">&#39;lu_uniq&#39;</span>, reduce<span style="color:#f92672">=&gt;</span><span style="color:#e6db74">&#39;lu_reduce&#39;</span>, reductions<span style="color:#f92672">=&gt;</span>undef];
    <span style="color:#66d9ef">use</span> PDL;
    <span style="color:#66d9ef">use</span> PDL::NiceSlice;

    <span style="color:#66d9ef">my</span> @strings <span style="color:#f92672">=</span> @ARGV;
    die <span style="color:#e6db74">&#34;Usage ./ch - 1.pl string1 [string2...]&#34;</span> <span style="color:#66d9ef">unless</span> @strings;
    <span style="color:#66d9ef">my</span> @letters <span style="color:#f92672">=</span> lu_uniq map{ ( substr( $_, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span> ), substr( $_, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span> ) ) } @strings;
    <span style="color:#66d9ef">my</span> %index;
    @index{ @letters } <span style="color:#f92672">=</span> ( <span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>@letters <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> );
    <span style="color:#66d9ef">my</span> $C <span style="color:#f92672">=</span> zeroes( scalar( @letters ), scalar( @letters ) ); <span style="color:#75715e">#connectivity matrix</span>
    $C<span style="color:#f92672">-&gt;</span>( $_<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>], $_<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>] ) <span style="color:#f92672">.=</span> $C<span style="color:#f92672">-&gt;</span>( $_<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>], $_<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>] )<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">foreach</span> map {  [$index{ substr( $_, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span> ) }, $index{ substr( $_, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span> ) }]  } @strings;
    <span style="color:#66d9ef">my</span> $balanced <span style="color:#f92672">=</span> all( $C<span style="color:#f92672">-&gt;</span>sumover <span style="color:#f92672">==</span> $C<span style="color:#f92672">-&gt;</span>transpose<span style="color:#f92672">-&gt;</span>sumover );
    <span style="color:#66d9ef">my</span> $final <span style="color:#f92672">=</span> lu_reduce { $a<span style="color:#f92672">|</span>$b } (
        reductions { $a x $b } ( identity( scalar @letters ), ( $C ) x ( @letters <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> ) ) );
    <span style="color:#66d9ef">my</span> $reachable <span style="color:#f92672">=</span> all( $final <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> );
    say <span style="color:#e6db74">&#34;Input: &#34;</span>, join <span style="color:#e6db74">&#34; &#34;</span>, @strings;
    say <span style="color:#e6db74">&#34;Output: &#34;</span>, $balanced <span style="color:#f92672">&amp;&amp;</span>$reachable? <span style="color:#ae81ff">1</span>:<span style="color:#ae81ff">0</span>;
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/cheok-yin-fung/perl/ch-1.pl"><strong>Cheok-Yin Fung</strong></a></p>
<p>The difference between simply counting up the instances of a character as a vertex, the &ldquo;degree&rdquo; as it is known; making sure that the number is even, for one in and one out each; and proving that we have a proper Eulerian Circuit is whether the resulting graph creates a <em>single connected component</em>.</p>
<p>CY breaks her determination of a Eulerian Circuit into two parts: counting degrees and determining whether the result is all connected. Here is the second phase of her algorithm, determining the single connectivity. She references this method <a href="https://e7-87-83.github.io/coding/challenge_115.html">in her writeup</a> as <a href="https://en.wikipedia.org/wiki/Eulerian_path#Hierholzer's_algorithm">Hierholzer&rsquo;s algorithm</a>. Essentially it addresses the issue of being able to construct multiple closed loops within as set of even-numbered vertices, where the loops touch and can be recombined to form a complete tour of the vertices.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">is_connected</span> {
        <span style="color:#66d9ef">my</span> @edges <span style="color:#f92672">=</span> @_;
        <span style="color:#66d9ef">my</span> %collected;
        <span style="color:#66d9ef">my</span> %vertex_neigh;
        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $str (@edges) {
            <span style="color:#66d9ef">my</span> $head <span style="color:#f92672">=</span> substr $str, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>;
            <span style="color:#66d9ef">my</span> $tail <span style="color:#f92672">=</span> substr $str, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>;
            $collected{$head} <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
            $collected{$tail} <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
            push $vertex_neigh{$head}<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span>, $tail;
            push $vertex_neigh{$tail}<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span>, $head;
        }
        <span style="color:#75715e"># depth-first search</span>
        <span style="color:#66d9ef">my</span> @stack <span style="color:#f92672">=</span> substr($edges[<span style="color:#ae81ff">0</span>], <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>);
        <span style="color:#66d9ef">while</span> (scalar @stack <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
            <span style="color:#66d9ef">my</span> $cur <span style="color:#f92672">=</span> pop @stack;
            <span style="color:#66d9ef">if</span> ($collected{$cur} <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
                <span style="color:#66d9ef">next</span>;
            }
            <span style="color:#66d9ef">else</span> {
                <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $neigh ($vertex_neigh{$cur}<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span>) {
                    push @stack, $neigh <span style="color:#66d9ef">if</span> $collected{$neigh} <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
                }
                $collected{$cur} <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
            }
        }
        <span style="color:#75715e">#check connectedness</span>
        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $letter (keys %collected) {
            <span style="color:#66d9ef">if</span> ($collected{$letter} <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
                <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
            }
        }
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
    }

</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/jo-37/perl/ch-1.pl"><strong>Jorg Sommrey</strong></a></p>
<p>We&rsquo;ve touched on quite a few different ways to approach the string challenge today. Here to close things down is Jorg, who, like CY before him, implements Hierholzer&rsquo;s algorithm to construct a Eulerian cycle. To start, we have the setup, with nice commenting interspersed:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">has_string_circle</span> {
        <span style="color:#75715e"># Create a multidigraph from the strings.</span>
        <span style="color:#66d9ef">my</span> $g <span style="color:#f92672">=</span> Graph<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">new</span>(multiedged <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">1</span>);
        <span style="color:#66d9ef">for</span> (@_) {
            <span style="color:#75715e"># The core of a multidigraph: Map each edge to its source and</span>
            <span style="color:#75715e"># target vertices.  This construction ensures that there are no</span>
            <span style="color:#75715e"># isolated vertices.</span>
            <span style="color:#75715e"># Get the string&#39;s first and last character, even if there&#39;s</span>
            <span style="color:#75715e"># only one.  Convert to lowercase normalized form allowing</span>
            <span style="color:#75715e"># case-insensitive chaining of extended grapheme clusters as</span>
            <span style="color:#75715e"># first and last &#34;characters&#34;.</span>
            <span style="color:#66d9ef">my</span> @e <span style="color:#f92672">=</span> map NFD(lc), <span style="color:#e6db74">/^(\X)/</span>, <span style="color:#e6db74">/(\X)$/</span>;
            <span style="color:#66d9ef">my</span> $id <span style="color:#f92672">=</span> $g<span style="color:#f92672">-&gt;</span>add_edge_get_id(@e);
            <span style="color:#75715e"># Assign the string as an edge attribute if an actual string</span>
            <span style="color:#75715e"># circle is requested.</span>
            $g<span style="color:#f92672">-&gt;</span>set_edge_attribute_by_id(@e, $id, str <span style="color:#f92672">=&gt;</span> $_) <span style="color:#66d9ef">if</span> $verbose;
        }

        <span style="color:#75715e"># The &#34;Graph&#34; package&#39;s method &#34;is_strongly_connected&#34; dies if</span>
        <span style="color:#75715e"># applied to a multigraph.  The corollary below offers a</span>
        <span style="color:#75715e"># simple workaround: Checking the weak connectivity suffices and</span>
        <span style="color:#75715e"># &#34;is_weakly_connected&#34; appears to work for multigraphs.</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">unless</span> $g<span style="color:#f92672">-&gt;</span>is_weakly_connected;

        <span style="color:#75715e"># Check the degree of all vertices.</span>
        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $v ($g<span style="color:#f92672">-&gt;</span>vertices) {
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">if</span> $g<span style="color:#f92672">-&gt;</span>vertex_degree($v);
        }

        <span style="color:#75715e"># Here the graph is Eulerian.</span>

        <span style="color:#75715e"># Construct and display a string circle if requested.</span>
        build_circle($g) <span style="color:#66d9ef">if</span> $verbose;

        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
    }
</code></pre></div><p>Then comes the cycle using Hierholzer&rsquo;s algorithm, to construct a cycle and expand it to accommodate unused vertex connections if necessary. So here it is in its entirely, because some things are best left intact. Enjoy.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#75715e"># Implementation of Hierholzer&#39;s algorithm (see below for a</span>
    <span style="color:#75715e"># justification):</span>
    <span style="color:#75715e"># - Start with a random vertex v.</span>
    <span style="color:#75715e"># - Build a cycle c starting from and ending in v.</span>
    <span style="color:#75715e"># - Repeat:</span>
    <span style="color:#75715e">#   * Find a new vertex v1 in c that has an outgoing edge excluded</span>
    <span style="color:#75715e">#     from c.</span>
    <span style="color:#75715e">#   * If there is no such vertex, the cycle c is Eulerian. Stop.</span>
    <span style="color:#75715e">#   * Find a cycle c1 starting from and ending in v1, omitting all edges</span>
    <span style="color:#75715e">#     in c.</span>
    <span style="color:#75715e">#   * Join the cycle c1 with the existing cycle c.</span>
    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">build_circle</span> ($g) {
        <span style="color:#66d9ef">my</span> @circle;
        <span style="color:#75715e"># Pick a random start vertex.  Loop while there is a vertex with an</span>
        <span style="color:#75715e"># unselected outgoing edge.</span>
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">my</span> $v <span style="color:#f92672">=</span> ($g<span style="color:#f92672">-&gt;</span>vertices)[<span style="color:#ae81ff">0</span>];
                defined $v;
                $v <span style="color:#f92672">=</span> first {$g<span style="color:#f92672">-&gt;</span>out_degree($_)} map $_<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>], @circle) {
            <span style="color:#75715e"># Find the vertex position in the (non-)existing circle.</span>
            <span style="color:#66d9ef">my</span> $vpos <span style="color:#f92672">=</span> @circle ? firstidx {$_<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">eq</span> $v} @circle : <span style="color:#ae81ff">0</span>;
            <span style="color:#75715e"># Find a cycle through $v and join it with the circle.</span>
            splice @circle, $vpos, <span style="color:#ae81ff">0</span>, @{extract_cycle($g, $v)};
        }

        <span style="color:#66d9ef">do</span> {local $, <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;, &#39;</span>; say map <span style="color:#e6db74">qq{&#34;$_-&gt;[1]&#34;}</span>, @circle};
    }

    <span style="color:#75715e"># Find a cycle starting from and ending in $vertex and remove the</span>
    <span style="color:#75715e"># selected edges on the way.</span>
    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">extract_cycle</span> ($g, $vertex) {
        <span style="color:#66d9ef">my</span> $v <span style="color:#f92672">=</span> $vertex;
        <span style="color:#66d9ef">my</span> @cycle;
        <span style="color:#66d9ef">do</span> {
            <span style="color:#75715e"># Select a random outgoing multi-edge.</span>
            <span style="color:#66d9ef">my</span> @e <span style="color:#f92672">=</span> ($g<span style="color:#f92672">-&gt;</span>edges_from($v))[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>
            <span style="color:#960050;background-color:#1e0010">#</span> Select a random edge from the multi<span style="color:#f92672">-</span>edge<span style="color:#f92672">.</span>
            <span style="color:#66d9ef">my</span> $id <span style="color:#f92672">=</span> ($g<span style="color:#f92672">-&gt;</span>get_multiedge_ids(@e))[<span style="color:#ae81ff">0</span>];
            <span style="color:#75715e"># Collect the edge&#39;s source vertex and the string.</span>
            push @cycle, [$e[<span style="color:#ae81ff">0</span>], $g<span style="color:#f92672">-&gt;</span>get_edge_attribute_by_id(@e, $id, <span style="color:#e6db74">&#39;str&#39;</span>)];
            <span style="color:#75715e"># Remove the selected edge from the graph.</span>
            $g<span style="color:#f92672">-&gt;</span>delete_edge_by_id(@e, $id);
            <span style="color:#75715e"># Advance to the target vertex.</span>
            $v <span style="color:#f92672">=</span> $e[<span style="color:#ae81ff">1</span>];
        } <span style="color:#66d9ef">until</span> ($v <span style="color:#f92672">eq</span> $vertex);

        <span style="color:#f92672">\</span>@cycle;
    }

</code></pre></div><h2 id="additional-submissions-in-guest-languages">Additional Submissions in Guest Languages</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/polettix/perl/ch-1.pl"><strong>Flavio Poletti</strong></a></p>
<p><strong>additional languages:</strong>
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/polettix/raku/ch-1.raku">Raku</a></p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/roger-bell-west/perl/ch-1.pl"><strong>Roger Bell_West</strong></a></p>
<p><strong>additional languages:</strong>
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/roger-bell-west/python/ch-1.py">Python</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/roger-bell-west/raku/ch-1.p6">Raku</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/roger-bell-west/ruby/ch-1.rb">Ruby</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/roger-bell-west/rust/ch-1.rs">Rust</a></p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/stuart-little/perl/ch-1.pl"><strong>Stuart Little</strong></a></p>
<p><strong>additional languages:</strong>
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/stuart-little/haskell/ch-1.hs">Haskell</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/stuart-little/node/ch-1.js">Node</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/stuart-little/python/ch-1.py">Python</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/stuart-little/raku/ch-1.p6">Raku</a></p>
<hr>
<h1 id="PWC115TASK2">TASK 2</h1>
<h1 id="largest-multiple">Largest Multiple</h1>
<p><em>Submitted by: Mohammad S Anwar</em><br>
You are given a list of positive integers (0-9), single digit.</p>
<p>Write a script to find the largest multiple of 2 that can be formed from the list.</p>
<p><strong>Examples</strong></p>
<pre><code>    Input: @N = (1, 0, 2, 6)
    Output: 6210

    Input: @N = (1, 4, 2, 8)
    Output: 8412

    Input: @N = (4, 1, 7, 6)
    Output: 7614
</code></pre><h2 id="about-the-solutions-1">about the solutions</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/abigail/perl/ch-2.pl"><strong>Abigail</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/arne-sommer/perl/ch-2.pl"><strong>Arne Sommer</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/athanasius/perl/ch-2.pl"><strong>Athanasius</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/brtastic/perl/ch-2.pl"><strong>Bartosz Jarzyna</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/cheok-yin-fung/perl/ch-2.pl"><strong>Cheok-Yin Fung</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/colin-crain/perl/ch-2.pl"><strong>Colin Crain</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/dave-cross/perl/ch-2.pl"><strong>Dave Cross</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/dave-jacoby/perl/ch-2.pl"><strong>Dave Jacoby</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/duncan-c-white/perl/ch-2.pl"><strong>Duncan C. White</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/e-choroba/perl/ch-2.pl"><strong>E. Choroba</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/polettix/perl/ch-2.pl"><strong>Flavio Poletti</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/james-smith/perl/ch-2.pl"><strong>James Smith</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/jo-37/perl/ch-2.pl"><strong>Jorg Sommrey</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/pete-houston/perl/ch-2.pl"><strong>Pete Houston</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/roger-bell-west/perl/ch-2.pl"><strong>Roger Bell_West</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/sgreen/perl/ch-2.pl"><strong>Simon Green</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/stuart-little/perl/ch-2.pl"><strong>Stuart Little</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/ulrich-rieke/perl/ch-2.pl"><strong>Ulrich Rieke</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/wlmb/perl/ch-2.pl"><strong>W. Luis Mochan</strong></a></p>
<p>There were only 19 working submissions for the second task this past week. A few fell by the wayside, and we&rsquo;ll attend to those later.</p>
<p>But for now, the task involves two related parts: constructing the largest number from a sequence of digits, and constructing a number that&rsquo;s a multiple of two.</p>
<p>The first part, constructing the largest number given a pool of digits, is a task of using the digit values available to maximum efficiency — using the largest values as multipliers for the largest values of 10 in the final representation. Generally this was done with a method of sorting and joining, but there were a fair number of brute force approaches of trying all permutations and keeping the largest in a running tally.</p>
<p>To make a number a multiple of 2, we need to make sure the number has a multiple of two in the one&rsquo;s place, as I explain next. Combining the ideas of efficiently using digits and placing a multiple of 2 in the one&rsquo;s place — the least valuable to the number&rsquo;s final representation — means we need to find the smallest digit that&rsquo;s a multiple of 2 to make the number even, and make sure the number ends with it.</p>
<h3 id="the-odd-things-about-being-even">the ODD THINGS about BEING EVEN</h3>
<p>When we say a number is even, this is a bit of shorthand for saying it is divisible by 2 without any remainder. In order for this to be true, it can be shown that the number must end in a digit divisible by 2 in its least significant digit, the one&rsquo;s place. Quickly stated, we can break down a multi-positional number representation into a sum of digits times powers of 10: 123, &ldquo;one hundred and twenty three&rdquo; can be written</p>
<p>1 × 10<sup>2</sup> + 2 × 10<sup>1</sup> + 3 × 10<sup>0</sup></p>
<p>Every power of 10 greater than 0 contains at least one 10, which itself is divisible by 2 as 5 × 2. A special case applies for the digit 0 but it all works out. Thus the components for all of the other digits in any number are divisible by 2 and the the test for evenness falls on the one&rsquo;s place alone.</p>
<p>This means that any number that is a multiple of, and hence divisible by, 2 must end in a number divisible by 2, or one of 2, 4, 6, 8 or 0. If none of the digit options supplied match up, then the task cannot be accomplished.</p>
<p>It&rsquo;s not made clear as to what we should do then. Some solutions simple sidestepped the issue and demanded valid input. Others came up with some sort of null response, such as printing &ldquo;none&rdquo;, &ldquo;NULL&rdquo; or &ldquo;no solution&rdquo;. Still others output 0, which brings with it certain questions, but sure, why not? Another valid choice we saw would be to fail gracefully and output absolutely nothing at all.</p>
<h3 id="what-went-wrong">&hellip;what went wrong</h3>
<p>A number of solutions, on identifying the smallest even digit, <em>swapped</em> this value with the last sorted element, rather than <em>moving</em> it to the end of the list. This takes the ordered last element and places it, unordered, into an arbitrary position in the list. If the even element is small, this is likely to work out by luck, but if the smallest even element is 8 it is more likely to fail, replacing a digit sorted high with a low value out-of-order.</p>
<h2 id="sort-and-reorder">SORT and REORDER</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/cheok-yin-fung/perl/ch-2.pl"><strong>Cheok-Yin Fung</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/dave-cross/perl/ch-2.pl"><strong>Dave Cross</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/e-choroba/perl/ch-2.pl"><strong>E. Choroba</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/james-smith/perl/ch-2.pl"><strong>James Smith</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/jo-37/perl/ch-2.pl"><strong>Jorg Sommrey</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/sgreen/perl/ch-2.pl"><strong>Simon Green</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/ulrich-rieke/perl/ch-2.pl"><strong>Ulrich Rieke</strong></a></p>
<p>The archetypical solution involved sorting the list of digits and isolating the smallest even digit, then recombining these ordered values to construct the final result. We saw the reconstruction accomplished in a variety of ways. For example, <code>splice()</code> was a common tool to pluck out the even digit, which was then added back to the end of the array. We also saw array slices employed to great effect, and even concatenation in the output stage, as here demonstrated in the opening example from Dave Cross:</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/dave-cross/perl/ch-2.pl"><strong>Dave Cross</strong></a></p>
<p>Dave keeps his processes discreet, plucking out his selected even digit before sorting the remaining array in descending order. He lets <code>print</code> do his concatenation with the default undef value of <code>$,</code>, the Output Field Separator, between array elements. He then continues to <code>say</code> the plucked multiple of 2, completing the number with a linefeed affixed.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span> ($min_even, $min_even_idx);
    $min_even <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;

    <span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">my</span> ($i, $v) <span style="color:#f92672">=</span> each @ints) {
      <span style="color:#66d9ef">if</span> ($v <span style="color:#f92672">&lt;</span> $min_even <span style="color:#f92672">and</span> <span style="color:#f92672">!</span> ($v % 2)) {
        $min_even     <span style="color:#f92672">=</span> $v;
        $min_even_idx <span style="color:#f92672">=</span> $i;
      }
    }

    splice @ints, $min_even_idx, <span style="color:#ae81ff">1</span>;

    <span style="color:#66d9ef">print</span> sort { $b <span style="color:#e6db74">&lt;=&gt;</span> $a } @ints;
    say $min_even;
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/james-smith/perl/ch-2.pl"><strong>James Smith</strong></a></p>
<p>James sorts his list descending for the first step, then iterates across it back to front to find the first even digit. After that a little careful rearranging with an array slice is done, we apply <code>join</code> and return our new number.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">biggest_even</span> {
      <span style="color:#66d9ef">my</span> $ptr <span style="color:#f92672">=</span> <span style="color:#66d9ef">my</span> @digits <span style="color:#f92672">=</span> reverse sort @{$_[<span style="color:#ae81ff">0</span>]};

      <span style="color:#75715e">## Firstly grab the digits in reverse numerical order</span>
      <span style="color:#75715e">## Keep looping backwards through the array until we</span>
      <span style="color:#75715e">## find a digit which is even - if this is the case</span>
      <span style="color:#75715e">## we move it to the back and return the list.</span>

      <span style="color:#66d9ef">while</span>( $ptr<span style="color:#f92672">--</span> ) {
        <span style="color:#66d9ef">next</span> <span style="color:#66d9ef">if</span> $digits[$ptr] <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">## Skip if odd...</span>
        <span style="color:#66d9ef">return</span> join <span style="color:#e6db74">&#39;&#39;</span>,
          @digits[ <span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$ptr<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, $ptr<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$#digits, $ptr ];
      }

      <span style="color:#75715e">## If we get to the start return 0 as there are no even digits!</span>
      <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#39;&#39;</span>;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/jo-37/perl/ch-2.pl"><strong>Jorg Sommrey</strong></a></p>
<p>Jorg also uses an array slice to rearrange his list elements, after importing <code>lastidx</code> from <code>List::MoreUtils</code> to search his array from the tail end forward instead of an explicit decrementing index iterator.</p>
<p>I like this method of using an array slice to piece apart and recombine the elements.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">largest_even</span> {
        <span style="color:#75715e"># Sort digits descending.</span>
        <span style="color:#66d9ef">my</span> @d <span style="color:#f92672">=</span> sort {$b <span style="color:#e6db74">&lt;=&gt;</span> $a} @_;

        <span style="color:#75715e"># Some zeros don&#39;t make a number.</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">if</span> $#d <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>$d[<span style="color:#ae81ff">0</span>];

        <span style="color:#75715e"># Get the index of the smallest even digit.</span>
        <span style="color:#66d9ef">my</span> $sei <span style="color:#f92672">=</span> lastidx {<span style="color:#f92672">!</span>($_ % 2)} @d;

        <span style="color:#75715e"># Give up if none found.</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">if</span> $sei <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>;

        <span style="color:#75715e"># Reorder the digits to form the largest even number.</span>
        join <span style="color:#e6db74">&#39;&#39;</span>, @d[<span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $sei <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, $sei <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> $#d, $sei];
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/ulrich-rieke/perl/ch-2.pl"><strong>Ulrich Rieke</strong></a></p>
<p><strong>additional languages:</strong>
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/ulrich-rieke/cpp/ch-2.cpp">C++</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/ulrich-rieke/haskell/ch-2.hs">Haskell</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/ulrich-rieke/raku/ch-2.raku">Raku</a></p>
<p>Ulrich used a very straightforward technique, extracting the even digit with <code>splice</code> and then then using <code>push</code> to append it back to the array. It&rsquo;s very direct and to the point.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span> @sorted <span style="color:#f92672">=</span> sort { $b <span style="color:#e6db74">&lt;=&gt;</span> $a } @numbers ;
    <span style="color:#66d9ef">if</span> ( scalar @sorted <span style="color:#f92672">==</span> scalar ( grep { $_ % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> } @sorted ) ) {
        say <span style="color:#e6db74">&#34;An even number can&#39;t be formed!&#34;</span> ;
        exit( <span style="color:#ae81ff">1</span> ) ;
    }
    <span style="color:#66d9ef">my</span> $len <span style="color:#f92672">=</span> scalar @sorted ;
    <span style="color:#66d9ef">my</span> $i <span style="color:#f92672">=</span> $len ;
    <span style="color:#66d9ef">do</span> {
        <span style="color:#f92672">--</span>$i ;
    } <span style="color:#66d9ef">while</span> ( <span style="color:#f92672">not</span> ( $sorted[ $i ] % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> ) ) ;

    <span style="color:#66d9ef">my</span> $smallestEven <span style="color:#f92672">=</span> $sorted[ $i ] ;
    splice( @sorted , $i , <span style="color:#ae81ff">1</span> ) ;
    push( @sorted , $smallestEven ) ;
    say join( <span style="color:#e6db74">&#39;&#39;</span> , @sorted ) ;
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/cheok-yin-fung/perl/ch-2.pl"><strong>Cheok-Yin Fung</strong></a></p>
<p>CY states the process quite succinctly:</p>
<blockquote>
<p>&quot;Sort the digits from largest to smallest, pick up the smallest even digit to be the last digit, then output the number.&rdquo;</p>
</blockquote>
<p>Iterating through a reversed list of indices in the array, she finds the first regex match against a character class of even digits. If she finds a match, she then uses that index to grab out and save the value using <code>splice</code> before reattaching it using <code>push</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    @digits <span style="color:#f92672">=</span> sort {$b <span style="color:#e6db74">&lt;=&gt;</span> $a} @digits;

    <span style="color:#66d9ef">my</span> $least_sig_fig <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">for</span> (reverse <span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$#digits) {
        <span style="color:#66d9ef">if</span> ($digits[$_] <span style="color:#f92672">=~</span><span style="color:#e6db74"> /[02468]/</span> ) {
            $least_sig_fig <span style="color:#f92672">=</span> splice(@digits, $_, <span style="color:#ae81ff">1</span>);
            push @digits, $least_sig_fig;
            <span style="color:#66d9ef">last</span>;
        }
    }
    <span style="color:#66d9ef">if</span> ($least_sig_fig <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;NULL&#34;</span>, <span style="color:#e6db74">&#34;\n&#34;</span>;
    }
    <span style="color:#66d9ef">else</span> {
        <span style="color:#66d9ef">print</span> join <span style="color:#e6db74">&#34;&#34;</span>, @digits;
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;\n&#34;</span>;
    }
</code></pre></div><h3 id="to-reverse-or-not-to-reverse">to REVERSE or not to REVERSE?</h3>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/brtastic/perl/ch-2.pl"><strong>Bartosz Jarzyna</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/colin-crain/perl/ch-2.pl"><strong>Colin Crain</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/polettix/perl/ch-2.pl"><strong>Flavio Poletti</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/pete-houston/perl/ch-2.pl"><strong>Pete Houston</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/roger-bell-west/perl/ch-2.pl"><strong>Roger Bell_West</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/wlmb/perl/ch-2.pl"><strong>W. Luis Mochan</strong></a></p>
<p>If we sort the digits from low to high, it&rsquo;s arguably a bit easier to move out our smallest multiple of two, by iterating across the list and grabbing the first instance. On the other hand, we do need to reverse the order again when we assemble the number, so any gain becomes a bit of a tradeoff, and in the end it largely fell to personal preference.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/pete-houston/perl/ch-2.pl"><strong>Pete Houston</strong></a></p>
<p>It&rsquo;s a quite subjective call to make, and I&rsquo;m hardly unbiased, but I feel this approach yields more compact solutions, as we can move through the sorted digits forward and only need to <code>unshift</code> the even value we&rsquo;ve spliced back into the array. Here Pete demonstrates the economy:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#75715e"># Sort ascending</span>
    <span style="color:#66d9ef">my</span> @n <span style="color:#f92672">=</span> sort @ARGV;

    <span style="color:#75715e"># Find the lowest even digit</span>
    <span style="color:#66d9ef">my</span> ($i) <span style="color:#f92672">=</span> grep { <span style="color:#ae81ff">0</span> <span style="color:#f92672">==</span> $n[$_] % 2 } <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $#n;

    <span style="color:#75715e"># If no even digits the task is impossible</span>
    die <span style="color:#e6db74">&#34;No multiple of 2 possible with (@ARGV)\n&#34;</span> <span style="color:#66d9ef">unless</span> defined $i;

    <span style="color:#75715e"># Print digits descending but with lowest even digit at the end</span>
    unshift @n, splice (@n, $i, <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">if</span> $i;
    say reverse @n;
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/colin-crain/perl/ch-2.pl"><strong>My Own Solution</strong></a></p>
<p><strong>additional languages:</strong>
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/colin-crain/raku/ch-2.raku">Raku</a></p>
<p>As stated I&rsquo;m not unbiased as I chose to reverse at the end myself. It does seem a nice and clean way to go about it.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">largest_two</span> ($arr, $i = 0) {
        @arr <span style="color:#f92672">=</span> sort {$a<span style="color:#f92672">-</span>$b} @$arr;
        <span style="color:#66d9ef">for</span> (@arr) {
            <span style="color:#66d9ef">if</span> ($arr[$i] % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
                unshift @arr, splice @arr, $i, <span style="color:#ae81ff">1</span>;
                <span style="color:#66d9ef">last</span>;
            }
            $i<span style="color:#f92672">++</span>;
        }

        <span style="color:#66d9ef">return</span> $i <span style="color:#f92672">&lt;</span> @arr ?  join <span style="color:#e6db74">&#39;&#39;</span>, reverse @arr
                         :  <span style="color:#e6db74">&#34;none&#34;</span> ;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/polettix/perl/ch-2.pl"><strong>Flavio Poletti</strong></a></p>
<p><strong>additional languages:</strong>
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/polettix/raku/ch-2.raku">Raku</a></p>
<p>Another compact interpretation from Flavio:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">largest_multiple</span> (@N) {
       @N <span style="color:#f92672">=</span> sort { $a <span style="color:#e6db74">&lt;=&gt;</span> $b } @N;
       <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i (<span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $#N) {
          <span style="color:#66d9ef">if</span> ($N[$i] % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
             <span style="color:#66d9ef">my</span> ($last) <span style="color:#f92672">=</span> splice @N, $i, <span style="color:#ae81ff">1</span>;
             <span style="color:#66d9ef">return</span> join <span style="color:#e6db74">&#39;&#39;</span>, reverse(@N), $last;
          }
       }
       <span style="color:#66d9ef">return</span>;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/brtastic/perl/ch-2.pl"><strong>Bartosz Jarzyna</strong></a></p>
<p>By importing <code>first</code>, from the core module <code>List:Util</code>, to the <code>keys</code> — or index list — of the sorted array, Bartosz tightens the algorithm up even further.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">largest_multiple</span>
    {
        <span style="color:#66d9ef">my</span> @digits <span style="color:#f92672">=</span> @_;

        <span style="color:#66d9ef">my</span> @sorted_asc <span style="color:#f92672">=</span> sort { $a <span style="color:#e6db74">&lt;=&gt;</span> $b } @digits;
        <span style="color:#66d9ef">my</span> $smallest_index <span style="color:#f92672">=</span> first { $sorted_asc[$_] % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> } keys @sorted_asc;

        die <span style="color:#e6db74">&#39;no result divisible by 2 can be achieved&#39;</span>
        	<span style="color:#66d9ef">unless</span> defined $smallest_index;

        <span style="color:#66d9ef">my</span> $smallest <span style="color:#f92672">=</span> splice @sorted_asc, $smallest_index, <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">return</span> join <span style="color:#e6db74">&#39;&#39;</span>, reverse(@sorted_asc), $smallest;

    }
</code></pre></div><h2 id="permute-permute">PERMUTE, PERMUTE!</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/arne-sommer/perl/ch-2.pl"><strong>Arne Sommer</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/dave-jacoby/perl/ch-2.pl"><strong>Dave Jacoby</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/duncan-c-white/perl/ch-2.pl"><strong>Duncan C. White</strong></a></p>
<p>Looking at all numbers we can make and then filtering them to find that largest is always an option. It may end up taking a long time, but it will work, at least until something catches fire.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/dave-jacoby/perl/ch-2.pl"><strong>Dave Jacoby</strong></a></p>
<p>Dave brings in <code>Algorithm::Permute</code> to do his heavy lifting. This module produces an iterator function that mutates the input array in-place, returning the next permutation, working through the possibilities without the memory requirements of precomputing all solutions. All permutations are computed and joined; odd numbers are short-circuited out early and the remaining are compared against a running maximum.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">largest_even_number</span>( @digits ) {
        <span style="color:#66d9ef">my</span> $max <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">my</span> $p <span style="color:#f92672">=</span> Algorithm::Permute<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">new</span>( [@digits] );
        <span style="color:#66d9ef">while</span> ( <span style="color:#66d9ef">my</span> @res <span style="color:#f92672">=</span> $p<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">next</span> ) {
            <span style="color:#66d9ef">my</span> $i <span style="color:#f92672">=</span> join <span style="color:#e6db74">&#39;&#39;</span>, @res;
            $i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">0</span>;
            <span style="color:#66d9ef">next</span> <span style="color:#66d9ef">unless</span> $i % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>;
            $max <span style="color:#f92672">=</span> $i <span style="color:#66d9ef">if</span> $i <span style="color:#f92672">&gt;</span> $max;
        }
        <span style="color:#66d9ef">return</span> $max;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/duncan-c-white/perl/ch-2.pl"><strong>Duncan C. White</strong></a></p>
<p>Duncan whips up his own generator to create new permutations on the fly, which is cool. Remember he uses <code>Function::Parameters</code> to supply his subroutine signatures, here using the module-supplied keyword <code>fun</code>. I was going to summarize it but decided that didn&rsquo;t do it justice, so here&rsquo;s nearly all of his solution:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#75715e"># try_all_perms( $callback, @digits );</span>
    <span style="color:#75715e">#    Permutation generator: Invoke $callback-&gt;( permutation )</span>
    <span style="color:#75715e">#    once for every permutation of @digits.</span>
    <span style="color:#75715e">#</span>
    fun try_all_perms( $callback, @digits )
    {
        rec_allperm( $callback, <span style="color:#f92672">[]</span>, @digits );
    }

    <span style="color:#75715e"># rec_allperm( $callback, $prefix, @rest );</span>
    <span style="color:#75715e">#    Recursive all permutations generator.  Given a &#34;permutation prefix&#34; of @$prefix,</span>
    <span style="color:#75715e">#    and a collection of unused digits @rest, for all permutations of @$prefix + @rest,</span>
    <span style="color:#75715e">#    calling $callback-&gt;( permutation ) for each complete permutation found.</span>
    <span style="color:#75715e">#</span>
    fun rec_allperm( $callback, $prefix, @rest )
    {
        <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $pos (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$#rest)
        {
        	<span style="color:#66d9ef">my</span> $x <span style="color:#f92672">=</span> $rest[$pos];
        	<span style="color:#75715e"># try with $x first (after @$prefix)</span>
        	<span style="color:#66d9ef">my</span> @pre <span style="color:#f92672">=</span> @$prefix;
        	push @pre, $x;

        	<span style="color:#75715e"># delete pos $pos from copy of @rest</span>
        	<span style="color:#66d9ef">my</span> @r <span style="color:#f92672">=</span> @rest;
        	splice( @r, $pos, <span style="color:#ae81ff">1</span> );

        	<span style="color:#66d9ef">if</span>( @r <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> )
        	{
        		$callback<span style="color:#f92672">-&gt;</span>( @pre );
        	} <span style="color:#66d9ef">else</span>
        	{
        		rec_allperm( $callback, <span style="color:#f92672">\</span>@pre, @r );
        	}
        }
    }

    <span style="color:#66d9ef">my</span> $max <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

    fun eachperm(@perm)
    {
        <span style="color:#66d9ef">my</span> $p <span style="color:#f92672">=</span> join(<span style="color:#e6db74">&#39;&#39;</span>, @perm);
        <span style="color:#75715e">#say &#34;perm: $p&#34;;</span>
        $max <span style="color:#f92672">=</span> $p <span style="color:#66d9ef">if</span> $p <span style="color:#f92672">&gt;</span> $max <span style="color:#f92672">&amp;&amp;</span> $p % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>;
    }

    try_all_perms( <span style="color:#f92672">\&amp;</span>eachperm, @digits );
    say <span style="color:#e6db74">&#34;$max&#34;</span>;
</code></pre></div><h2 id="wild-horses-unfettered-and-running-free">WILD HORSES, UNFETTERED and RUNNING FREE</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/abigail/perl/ch-2.pl"><strong>Abigail</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/athanasius/perl/ch-2.pl"><strong>Athanasius</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/stuart-little/perl/ch-2.pl"><strong>Stuart Little</strong></a></p>
<p>Some solutions were novel enough to warrant their own category, breaking away from the pack, racing across the broken land. I&rsquo;m not exactly sure where I&rsquo;m going with this metaphor, but it&rsquo;s indisputable that horses love to run, and given the chance will run for the sheer love of running.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/abigail/perl/ch-2.pl"><strong>Abigail</strong></a></p>
<p><strong>additional languages:</strong>
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/abigail/awk/ch-2.awk">Awk</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/abigail/bash/ch-2.sh">Bash</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/abigail/c/ch-2.c">C</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/abigail/lua/ch-2.lua">Lua</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/abigail/node/ch-2.js">Node</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/abigail/python/ch-2.py">Python</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/abigail/ruby/ch-2.rb">Ruby</a></p>
<p>Abigail gives us a very interesting alternative to sorting the input array, instead immediately recording the frequency counts of the digits into an array, where the indices represent the digits 0 through 9. We can then use <code>grep</code> to search the frequencies for true values against just the even-numbered indices, to get a list of those even indices that record digits. Assigning this to a 1-element list captures the first element, being the lowest-valued even digit. We decrement this in the frequency array, then print the array mapped back to digit strings. That&rsquo;s a &ldquo;fat comma&rdquo; there, in case you&rsquo;re confused. A bit of syntactic sugar normally seen in hash assignment, it&rsquo;s just an alias for a comma and can be used anywhere one is required.</p>
<p>Finally we see a return of sequentially outputting the even digit in a separate statement after the <code>print</code>, to finish constructing the solution.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span> @DIGITS <span style="color:#f92672">=</span> (<span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> <span style="color:#ae81ff">9</span>);
    <span style="color:#66d9ef">my</span> @EVENS  <span style="color:#f92672">=</span> grep {$_ % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>} @DIGITS;
    <span style="color:#f92672">...</span>

    <span style="color:#66d9ef">my</span> @digits <span style="color:#f92672">=</span> (<span style="color:#ae81ff">0</span>) x @DIGITS;
    $digits [$_] <span style="color:#f92672">++</span> <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">do</span> {local $&#34; <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>; <span style="color:#e6db74">/[@DIGITS]/g</span>};

    <span style="color:#75715e">#</span>
    <span style="color:#75715e"># The last number of the output should be the smallest</span>
    <span style="color:#75715e"># even number in the input. If there is no even number</span>
    <span style="color:#75715e"># in the input, skip it.</span>
    <span style="color:#75715e">#</span>
    <span style="color:#66d9ef">my</span> ($last) <span style="color:#f92672">=</span> grep {$digits [$_]} @EVENS;
    <span style="color:#66d9ef">next</span> <span style="color:#66d9ef">unless</span> defined $last;
    $digits [$last] <span style="color:#f92672">--</span>;

    <span style="color:#75715e">#</span>
    <span style="color:#75715e"># Print the result, with the highest numbers first.</span>
    <span style="color:#75715e">#</span>
    <span style="color:#66d9ef">print</span> join <span style="color:#e6db74">&#34;&#34;</span> <span style="color:#f92672">=&gt;</span> map {$_ x $digits [$_]} reverse @DIGITS;
    say $last;
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/athanasius/perl/ch-2.pl"><strong>Athanasius</strong></a></p>
<p><strong>additional languages:</strong>
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/athanasius/raku/ch-2.raku">Raku</a></p>
<p>The monk&rsquo;s submission functions quite similarly to Abigail&rsquo;s, above, only they use a frequency hash, here referred to as a <a href="https://en.wikipedia.org/wiki/Multiset">multiset</a>, to record the digit data. A quick iteration through the keys locates the smallest even element, which then has its frequency decremented in the hash value. Progressing through the sorted keys of the remaining multiset, an array is constructed with each key pushed on according to the frequency value found. Finally the smallest even value we found earlier is added and the array joined into a number for output.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span> %digits;                       <span style="color:#75715e"># Hash emulating a multiset</span>
     <span style="color:#f92672">++</span>$digits{ $_ } <span style="color:#66d9ef">for</span> @N;

    <span style="color:#66d9ef">my</span> $lsdig;                        <span style="color:#75715e"># Least significant digit: must be even</span>

    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $d (keys %digits)
    {
        $lsdig <span style="color:#f92672">=</span> $d <span style="color:#66d9ef">if</span> ($d % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#f92672">&amp;&amp;</span> (<span style="color:#f92672">!</span>defined( $lsdig ) <span style="color:#f92672">||</span> $d <span style="color:#f92672">&lt;</span> $lsdig);
    }

    <span style="color:#66d9ef">if</span> (defined $lsdig)
    {
        <span style="color:#f92672">--</span>$digits{ $lsdig };          <span style="color:#75715e"># Remove the least significant digit from</span>
                                      <span style="color:#75715e">#   the multiset</span>
        <span style="color:#66d9ef">my</span> @msdigs;                   <span style="color:#75715e"># The remaining (i.e., most sig.) digits</span>

        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $d (keys %digits)      <span style="color:#75715e"># Build the array from the multiset</span>
        {
            push @msdigs, $d <span style="color:#66d9ef">for</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> $digits{ $d };
        }

        printf <span style="color:#e6db74">&#34;Output: %s%d\n&#34;</span>, join( <span style="color:#e6db74">&#39;&#39;</span>, sort { $b <span style="color:#e6db74">&lt;=&gt;</span> $a } @msdigs ),
                                 $lsdig;
    }
    <span style="color:#66d9ef">else</span>
    {
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#39;Output: None (no multiple of 2 can be formed from the given &#39;</span> <span style="color:#f92672">.</span>
              <span style="color:#e6db74">&#34;digits)\n&#34;</span>;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/stuart-little/perl/ch-2.pl"><strong>Stuart Little</strong></a></p>
<p><strong>additional languages:</strong>
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/stuart-little/haskell/ch-2.hs">Haskell</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/stuart-little/node/ch-2.js">Node</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/stuart-little/python/ch-2.py">Python</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/stuart-little/raku/ch-2.p6">Raku</a></p>
<p>Finally, Stuart first sorts his input array descending and joins it into a string, then uses a regular expression to match the tail end against a single character followed by a greedy match of all instances from a character class of odd digits.</p>
<p>This will capture the last not-odd digit followed by a capture of nothing but odd digits until the end of the string. These captures are swapped and the substituted string returned non-destructively, moving the last, smallest even digit to the end of the number. Artful. A little verification is added to make sure a number could be constructed through this trickery, and either the new number or a NULL clause is printed.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span> $attemptedOut <span style="color:#f92672">=</span> (join <span style="color:#e6db74">&#34;&#34;</span>, sort {$b <span style="color:#f92672">cmp</span> $a} @ARGV) <span style="color:#f92672">=~</span> <span style="color:#e6db74">s/(.)([13579]*)$/$2$1/</span>r;
    say(($attemptedOut <span style="color:#f92672">=~</span> <span style="color:#e6db74">m/[02468]$/</span>) ? ($attemptedOut) : (<span style="color:#e6db74">&#34;No even digits..&#34;</span>));
</code></pre></div><h2 id="additional-submissions-in-guest-languages-1">Additional Submissions in Guest Languages</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/arne-sommer/perl/ch-2.pl"><strong>Arne Sommer</strong></a></p>
<p><strong>additional languages:</strong>
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/arne-sommer/raku/ch-2.raku">Raku</a></p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/roger-bell-west/perl/ch-2.pl"><strong>Roger Bell_West</strong></a></p>
<p><strong>additional languages:</strong>
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/roger-bell-west/python/ch-2.py">Python</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/roger-bell-west/raku/ch-2.p6">Raku</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/roger-bell-west/ruby/ch-2.rb">Ruby</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/roger-bell-west/rust/ch-2.rs">Rust</a></p>
<hr>
<hr>
<h1 id="PWC115BLOGS">BLOGS</h1>
<hr>
<p><strong>That’s it for me this week, people! Warped by the rain, driven by the snow, resolute and unbroken by the torrential influx, I somehow continue to maintain my bearings. Looking forward to next wave, the perfect wave, I am: <em>your humble servant</em>.</strong></p>
<h1 id="PWC093BLOGS">But if Your <em>THIRST</em> for <em>KNOWLEDGE</em> is not <em>SLAKED</em>,</h1>
<h1 id="then-run-dont-walk-to-the-watering-hole">then <em>RUN</em> <em>(dont walk!)</em> to the <em>WATERING HOLE</em></h1>
<h1 id="and-read-these-blog-links">and <em>READ</em> these <em>BLOG</em> <em>LINKS</em>:</h1>
<p><strong>( <em>don&rsquo;t think, trust your training, you&rsquo;re in the zone, just do it &hellip;</em> )</strong></p>
<p><strong>Abigail</strong></p>
<ul>
<li><a href="https://abigail.github.io/HTML/Perl-Weekly-Challenge/week-115-1.html">Perl Weekly Challenge 115: String Chain</a> ( <em>Perl</em> )</li>
<li><a href="https://abigail.github.io/HTML/Perl-Weekly-Challenge/week-115-2.html">Perl Weekly Challenge 115: Largest Multiple</a> ( <em>Perl</em> )</li>
</ul>
<p><strong>Adam Russell</strong></p>
<ul>
<li><a href="http://www.rabbitfarm.com/cgi-bin/blosxom/perl/2021/06/05">The Weekly Challenge 115 — RabbitFarm</a> ( <em>Perl</em> )</li>
</ul>
<p><strong>Andinus</strong></p>
<ul>
<li><a href="https://andinus.tilde.institute/pwc/challenge-115/">Challenge 115</a> ( <em>Raku</em> )</li>
</ul>
<p><strong>Arne Sommer</strong></p>
<ul>
<li><a href="https://raku-musings.com/hamilton-unchained.html">Hamilton Unchained with Raku and Perl</a> ( <em>Perl &amp; Raku</em> )</li>
</ul>
<p><strong>Bartosz Jarzyna</strong></p>
<ul>
<li><a href="https://brtastic.xyz/blog/article/zipping-arrays-in-perl">Zipping arrays in Perl - Bartosz Jarzyna</a> ( <em>Perl</em> )</li>
</ul>
<p><strong>Cheok-Yin Fung</strong></p>
<ul>
<li><a href="https://e7-87-83.github.io/coding/challenge_115.html">CY&rsquo;s Take on The Weekly Challenge #115</a> ( <em>Perl</em> )</li>
</ul>
<p><strong>Colin Crain</strong></p>
<ul>
<li><a href="https://colincrain.com/2021/06/04/an-even-larger-string-cheese-chain/">An Even Larger String Cheese Chain — Programming Excursions in Perl and Raku</a> ( <em>Perl &amp; Raku</em> )</li>
</ul>
<p><strong>Dave Jacoby</strong></p>
<ul>
<li><a href="https://jacoby.github.io/2021/06/01/abc-acb-bac-bca-cab-cba-perl-weekly-challenge-115.html">ABC ACB BAC BCA CAB CBA: Perl Weekly Challenge #115 | Committed to Memory</a> ( <em>Perl</em> )</li>
</ul>
<p><strong>Flavio Poletti</strong></p>
<ul>
<li><a href="https://github.polettix.it/ETOOBUSY/2021/06/02/pwc115-string-chain/">PWC115 - String Chain - ETOOBUSY</a> ( <em>Perl &amp; Raku</em> )</li>
<li><a href="https://github.polettix.it/ETOOBUSY/2021/06/03/pwc115-largest-multiple/">PWC115 - Largest Multiple - ETOOBUSY</a> ( <em>Perl &amp; Raku</em> )</li>
</ul>
<p><strong>James Smith</strong></p>
<ul>
<li><a href="https://github.com/drbaggy/perlweeklychallenge-club/tree/master/challenge-115/james-smith">Perl Weekly Challenge #115 — Cursing at Recursion</a> ( <em>Perl</em> )</li>
</ul>
<p><strong>Laurent Rosenfeld</strong></p>
<ul>
<li><a href="http://blogs.perl.org/users/laurent_r/2021/06/-perl-weekly-challenge-115-string-chain-and-largest-multiple.html">Perl Weekly Challenge 115: String Chain and Largest Multiple | laurent_r</a> ( <em>Perl &amp; Raku</em> )</li>
</ul>
<p><strong>Luca Ferrari</strong></p>
<ul>
<li><a href="https://fluca1978.github.io/2021/06/01/PerlWeeklyChallenge115.html#task1">Perl Weekly Challenge 115: words in circles and numbers – Luca Ferrari – Open Source advocate, human being</a> ( <em>Raku</em> )</li>
<li><a href="https://fluca1978.github.io/2021/06/01/PerlWeeklyChallenge115.html#task2">Perl Weekly Challenge 115: words in circles and numbers – Luca Ferrari – Open Source advocate, human being</a> ( <em>Raku</em> )</li>
</ul>
<p><strong>Roger Bell_West</strong></p>
<ul>
<li><a href="https://blog.firedrake.org/archive/2021/06/Perl_Weekly_Challenge_115__Largest_Chain.html">RogerBW&rsquo;s Blog: Perl Weekly Challenge 115: Largest Chain</a> ( <em>Perl &amp; Raku</em> )</li>
</ul>
<p><strong>Simon Green</strong></p>
<ul>
<li><a href="https://dev.to/simongreennet/weekly-challenge-115-26c9">Weekly Challenge 115</a> ( <em>Perl</em> )</li>
</ul>
<p><strong>W. Luis Mochan</strong></p>
<ul>
<li><a href="https://wlmb.github.io/2021/06/01/PWC115/">Perl Weekly Challenge 115 – W. Luis Mochán</a> ( <em>Perl</em> )</li>
</ul>

                </div>
            </div>
        </div>
    </div>
</section>


<!-- Call To Action Section Start -->
<section id="call-to-action">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2 class="title wow fadeInDown" data-wow-delay=".3s" data-wow-duration="500ms">SO WHAT DO YOU THINK ?</h2>
                    <p class="wow fadeInDown" data-wow-delay=".5s" data-wow-duration="500ms">If you have any suggestions or ideas then please do share with us.</p>
                    <a href="mailto:mohammad.anwar@yahoo.com" class="btn btn-default btn-contact wow fadeInDown" data-wow-delay=".7s" data-wow-duration="500ms">Contact with me</a>
                </div>
            </div>

        </div>
    </div>
</section>
<!-- Call To Action Section End -->



<!-- Footer Section Start -->
<footer id="footer">
    <div class="container">
        <div class="row content-justify-between">
            <div class="col-md-8 col-12 text-center text-lg-left text-md-left">
                <p class="copyright">Copyright:
                    <span>
                        2019 - 2025
                    </span> The Weekly Challenge. Theme Design and Developed by
                    <a href="http://www.Themefisher.com" rel="noreferrer" rel="noreferrer" target="_blank">Themefisher</a>.
                </p>
            </div>
            <div class="col-md-4 col-12">
                <!-- Social Media -->
                <ul class="social text-center text-md-right text-lg-right">
                    <li>
                        <a href="https://twitter.com/PerlWChallenge" class="twitter" rel="noreferrer" target="_blank" title="Follow us">
                            <i class="ion-social-twitter"></i>
                        </a>
                    </li>
                    <li>
                        <a href="/rss.xml" class="rss" target="_blank" title="RSS Feed">
                            <i class="ion-social-rss"></i>
                        </a>
                    </li>
                </ul>
            </div>
        </div>
    </div>
</footer>
<!-- footer section end -->

<!-- jquery -->
<script src="https://theweeklychallenge.org/plugins/jquery/jquery.min.js"></script>
<!-- Form Validation -->
<script src="https://theweeklychallenge.org/plugins/form-validation/jquery.form.min.js"></script>
<script src="https://theweeklychallenge.org/plugins/form-validation/jquery.validate.min.js"></script>
<!-- slick slider -->
<script src="https://theweeklychallenge.org/plugins/slick/slick.min.js"></script>
<!-- bootstrap js -->
<script src="https://theweeklychallenge.org/plugins/bootstrap/bootstrap.min.js"></script>
<!-- chart js -->
<script src="https://theweeklychallenge.org/plugins/chart/highstock.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/drilldown.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/data.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/chart.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/pwc-challenge.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/gc-challenge.js"></script>
<!-- wow js -->
<script src="https://theweeklychallenge.org/plugins/wow-js/wow.min.js"></script>
<!-- slider js -->
<script src="https://theweeklychallenge.org/plugins/slider/slider.js"></script>
<!-- Fancybox -->
<script src="https://theweeklychallenge.org/plugins/facncybox/jquery.fancybox.js"></script>
<!-- template main js -->

<script src="https://theweeklychallenge.org/js/script.min.js"></script>
<!-- google analitycs -->

<script async src="https://www.googletagmanager.com/gtag/js?id=G-CJTPYM9SB8"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-CJTPYM9SB8');
</script>
</body>

</html>

