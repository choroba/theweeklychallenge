<!DOCTYPE html>
<html class="no-js" lang="en-us">
<head>
    <!-- Basic Page Needs -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:title"       content="The Weekly Challenge"/>
    <meta property="og:type"        content="website"/>
    <meta property="og:url"         content="https://theweeklychallenge.org/"/>
    <meta property="og:image"       content="https://theweeklychallenge.org/images/about/about.jpg"/>
    <meta property="og:description" content="You do not have to be an expert."/>
    <meta name="twitter:card"       content="summary" />
    <meta name="twitter:image"      content="https://theweeklychallenge.org/images/about/about.jpg"/>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <meta name="description" content="Colin Crain › Perl Weekly Review #101">
    <meta name="author" content="The Weekly Challenge Team">
    <meta name="generator" content="Hugo 0.67.0-DEV" />

    <link rel="me" href="https://fosstodon.org/@manwar">

    <!-- Mobile Specific Metas -->
    <meta name="format-detection" content="telephone=no">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Colin Crain › Perl Weekly Review #101</title>
    <link rel="icon" href="https://theweeklychallenge.org/images/favicon.ico">

    
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css"/>

    <!-- Twitter Bootstrs CSS -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/bootstrap/bootstrap.min.css">
    <!-- Ionicons Fonts Css -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/ionicons/ionicons.min.css">
    <!-- animate css -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/animate-css/animate.css">
    <!-- Hero area slider css-->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/slider/slider.css">
    <!-- slick slider -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/slick/slick.css">
    <!-- Fancybox -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/facncybox/jquery.fancybox.css">
    <!-- hover -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/hover/hover-min.css">
    <!-- Google fonts -->
    <link href='https://fonts.googleapis.com/css?family=Source Code Pro' rel='stylesheet'>
    <!-- template main css file -->
    
    <link rel="stylesheet" href="https://theweeklychallenge.org/css/style.min.css" integrity="" media="screen">
    <link rel="stylesheet" href="https://theweeklychallenge.org/css/main.css">

    <style>
        #goTopButton {
            display: none;          
            position: fixed;        
            bottom: 20px;           
            right: 30px;            
            z-index: 99;            
            border: none;           
            outline: none;          
            background-color: red;  
            color: white;           
            cursor: pointer;        
            padding: 15px;          
            border-radius: 10px;    
            font-size: 18px;        
        }

        #goTopButton:hover {
              background-color: #555;
        }
    </style>


</head>

<body>

<button onclick="goTop()" id="goTopButton" title="Go to top">Top</button>

<script>

    topButton = document.getElementById("goTopButton");

    
    window.onscroll = function() { scrollFunction() };

    function scrollFunction() {
        if (document.body.scrollTop > 40 || document.documentElement.scrollTop > 40) {
            topButton.style.display = "block";
        } else {
            topButton.style.display = "none";
        }
    }

    
    function goTop() {
        document.body.scrollTop = 0; 
        document.documentElement.scrollTop = 0; 
    }

</script>

<section class="top-bar animated-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-12">
                <nav class="navbar navbar-expand-lg navbar-light bg-light">
                    <a class="navbar-brand" href="https://theweeklychallenge.org/">
                        <img src="https://theweeklychallenge.org/images/logo.svg" alt="logo">
                    </a>
                    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navgation" aria-controls="navigation"
                        aria-expanded="false" aria-label="Toggle navigation">
                        <span class="navbar-toggler-icon"></span>
                    </button>

                    <div class="collapse navbar-collapse" id="navigation">
                        <ul class="navbar-nav ml-auto">
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/">Home</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/about">About</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/chart">Chart</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/champions">Champions</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/team">Team</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/challenges">Challenges</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/p5-reviews">Perl/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/p6-reviews">Raku/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/recaps">Recaps</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/blogs">Blogs</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/faq">FAQ</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/contact">Contact</a>
                            </li>
                            
                        </ul>
                    </div>
                </nav>
            </div>
        </div>
    </div>
</section>


<section class="global-page-header">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2>Colin Crain › Perl Weekly Review #101</h2>
                    <div class="portfolio-meta">
                        <span>Monday, Mar 15, 2021</span>|
                        <span> Tags:
                            perl
                        </span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

<section class="single-post">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                
                <div style="text-align: center" class="post-img">
                    <img class="img-fluid" alt="" src="https://theweeklychallenge.org/images/blog/p5-review-challenge-101.jpg">
                </div>
                
                <div style="text-align: justify" class="post-content">
                    <p>( <em>&hellip;continues from <a href="/blog/review-challenge-100/">previous week</a>.</em> )</p>
<p>Welcome to the Perl review for <strong>Week 101</strong> of the Weekly Challenge! Here we will take the time to discuss the  submissions offered by the team, factor out the common methodologies that came up in those solutions, and highlight some of the unique approaches and unusual code created.</p>
<hr>
<h3 id="why-do-we-do-these-challenges">Why do we do these challenges?</h3>
<p>I suppose any answers to that would be as wide ranging and varied as the people who choose to join the team. One thing is clear: it&rsquo;s not a competition, and there are no judges, even if there is a &ldquo;prize&rdquo; of sorts. About that &ndash; I think of it more as an honorarium periodically awarded to acknowledge the efforts we make towards this strange goal. So there&rsquo;s no determination to find the <em>fastest</em>, or the <em>shortest</em>, or even, in some abstract way, the <em>best</em> way to go about things, although I&rsquo;m certain the individuals have their own aspirations and personal drives. As Perl is such a wonderfully expressive language, this provides quite a bit of fodder to the core idea of TMTOWTDI, producing a gamut of wonderfully varied techniques and solutions.</p>
<p>Even the tasks themselves are often open to a certain amount of discretionary interpretation. What we end up with is a situation where each participant is producing something in the manner they find the most interesting or satisfying. Some team members focus on carefully crafted complete applications that thoroughly vet input data and handle every use case they can think up. Others chose to apply themselves to the logic of the underlying puzzle and making it work in the most elegant way they can. Some eschew modules they would ordinarily reach for, others embrace them, bringing to light wheels perhaps invented years ago that happen to exactly solve the problem in front of them today.</p>
<p>I&rsquo;ve been considering this question for some time and have found one binding commonality between all of us solving these challenges each week, in that however we normally live our lives, the task in front of us more than likely has nothing to do with any of that . And I think this has great value. We all do what we do, out in the real world, and hopefully we do it well. The Weekly Challenge provides a opportunity to do something germane to that life yet distinctly different; if we only do the things we already know how to do we only do the same things over and over. This is where the &ldquo;challenge&rdquo; aspect comes into play.</p>
<p>So we can consider the Weekly Challenge as providing a problem space outside of our comfort zone, as far out from comfort as we wish to take things. From those reaches we can gather and learn things and bring what we want back into our lives. Personally, I think that&rsquo;s its greatest value of all.</p>
<hr>
<p>Every week there is an enormous global collective effort made by the team, analyzing and creatively coding the submissions, and that effort deserves credit due. And that&rsquo;s why I&rsquo;m here, to try and figure out how to do that.</p>
<p>Let&rsquo;s have a look and see what we can find.</p>
<hr>
<p><strong><big>For context</big></strong>  before we begin, you may wish to revisit either of the pages for the <a href="/blog/perl-weekly-challenge-101/"><strong>original tasks</strong></a> or the summary <a href="/blog/recap-challenge-101/"><strong>recap</strong></a> of the challenge. But don&rsquo;t worry, the challenges themselves will be briefly summarized, presented below as we progress from task by task. Oh, and one more thing before we get started:</p>
<h3 id="getting-in-touch-with-us">Getting in Touch with Us</h3>
<p><a href="mailto:pwc.perfectwave@gmail.com"><img src="/images/blog/Email.svg" height="50" width="50"> Email</a> › Please email me (Colin) with any feedback, notes, clarifications or whatnot about this review.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge"><img src="/images/blog/Github.svg" height="50" width="50"> GitHub</a> › Submit a pull request to us for any issues you may find with this page.</p>
<p><a href="https://twitter.com/perlwchallenge"><img src="/images/blog/Twitter.svg" height="50" width="50"> Twitter</a> › Join the discussion on Twitter!</p>
<p>I&rsquo;m always curious as to what the people think of these efforts. Everyone here at the PWC would like to hear any feedback you&rsquo;d like to give.</p>
<p><strong>So finally, without further ado&hellip;</strong></p>
<hr>
<h2 id="---nbsp--nbsp--nbsp---task-1pwc101task1-------nbsp--nbsp--nbsp------nbsp--nbsp--nbsp---task-2pwc101task2---nbsp--nbsp--nbsp------nbsp--nbsp--nbsp---blogspwc101blogs----nbsp--nbsp--nbsp---">•             <a href="#PWC101TASK1">Task 1</a>                 •             <a href="#PWC101TASK2">Task 2</a>             	•             <a href="#PWC101BLOGS">BLOGS</a>              	•</h2>
<hr>
<h1 id="PWC101TASK1">TASK 1</h1>
<h1 id="pack-a-spiral">Pack a Spiral</h1>
<p><em>Submitted by: Stuart Little</em></p>
<p>You are given an array @A of items (integers say, but they can be anything).</p>
<p>Your task is to pack that array into an MxN matrix spirally counterclockwise, as tightly as possible.</p>
<p>‘Tightly’ means the absolute value |M-N| of the difference has to be as small as possible.</p>
<p><strong>Example 1:</strong></p>
<pre><code>    Input: @A = (1,2,3,4)

    Output:

        4 3
        1 2
</code></pre><p>Since the given array is already a 1x4 matrix on its own, but that&rsquo;s not as tight as possible. Instead, you&rsquo;d spiral it counterclockwise into</p>
<pre><code>4 3
1 2
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>    Input: @A = (1..6)

    Output:

        6 5 4
        1 2 3

    or

        5 4
        6 3
        1 2
</code></pre><p>Either will do as an answer, because they&rsquo;re equally tight.</p>
<h2 id="about-the-solutions">about the solutions</h2>
<p>There were 21 submissions for the first task this past week.</p>
<p>The problem as stated has two basic components: first, to determine the optimal matrix to fit the data, and then to fill it in the correct manner.</p>
<p>I have come to expect at this point that as far as the task definitions go, that should any chink in the armor exist, ever so small, someone will find a way to open that hole wide for the world to see. In this case the term &lsquo;tightly&rsquo;, well-defined here, dominates the description, leaving the idea of the underlying array a little hazy around the edges. Are 33 items packed into a 5×7 grid more or less tight than those same items packed into a 6×6 grid? The latter is square, but the former has less whitespace. Wait, what? Who let all this whitespace in here in the first place? Isn&rsquo;t a 3×11 best because it has no whitespace at all?</p>
<p>As the tests presented in that submission show the behavior alluded to was certainly intentional, a review and  careful reading of the description reveals that at no point is whitespace actually <em>excluded</em> from the spiral. So I&rsquo;m just going to let that one go by, but I&rsquo;m still surprised, and frankly a little impressed, that it even came up.</p>
<p>As to the second half of the puzzle, drafting out the spiral, several members noted that essentially this is a reverse of the actions taken in PWC 088 task 2, where we took a spiral matrix and unrolled it into an array. Although the act of translating between the idea of a spiralled matrix and a linear sequence exists in both tasks, and the code for one obviously will inform to the other, the implementation cannot be exactly the same.</p>
<p>Well, with the exception of one member&rsquo;s efforts, being a special case of reality wrapping around on itself in some paranormal manner. How&rsquo;s that for a lead in? We&rsquo;ll get to that.</p>
<p>In general the actual spiralling was almost always along the same general pattern: Draw a line in a given direction until it&rsquo;s time to stop, turn left, draw again. Stop when we run out of array. These actions were either factored out as into common functions, or left unrolled in a clear linear stream, depending on taste, and we&rsquo;ll have a look at technique done both ways.</p>
<h2 id="selecting-the-ideal-matrix">SELECTING the IDEAL matrix</h2>
<h2 id="applying-persuasive-force">applying PERSUASIVE FORCE</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/cheok-yin-fung/perl/ch-1.pl"><strong>Cheok-Yin Fung</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/dave-jacoby/perl/ch-1.pl"><strong>Dave Jacoby</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/sgreen/perl/ch-1.pl"><strong>Simon Green</strong></a></p>
<p>Selecting the tightest — as defined — matrix to fill requires us to determine a pair of factors to the length of the input array such that the difference between the two is minimized. At one level this would easily yield to brute force — trying every number less than the length and see if it evenly divides. As premature optimization is a cardinal sin out in the real world there&rsquo;s no reason to discount this approach out-of-hand.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/sgreen/perl/ch-1.pl"><strong>Simon Green</strong></a></p>
<p>Simon demonstrates. After initializing his starting pair as the whole length and 1, he then works through the values within the remaining range looking for pairs of factors, and if they are closer to greater than any yet found the running minumum is updated.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">_get_tightest_grid</span> {
        <span style="color:#66d9ef">my</span> $count <span style="color:#f92672">=</span> shift;
        <span style="color:#66d9ef">my</span> $max_x <span style="color:#f92672">=</span> $count;
        <span style="color:#66d9ef">my</span> $max_y <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;

        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $y ( <span style="color:#ae81ff">2</span> <span style="color:#f92672">..</span> $count <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> ) {
            <span style="color:#66d9ef">my</span> $x <span style="color:#f92672">=</span> $count <span style="color:#f92672">/</span> $y;
            <span style="color:#66d9ef">if</span> ( $count % <span style="color:#960050;background-color:#1e0010">$</span>y <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> abs( $x <span style="color:#f92672">-</span> $y ) <span style="color:#f92672">&lt;</span> abs( $max_x <span style="color:#f92672">-</span> $max_y ) ) {
                <span style="color:#75715e"># We have found a tighter solution</span>
                ( $max_x, $max_y ) <span style="color:#f92672">=</span> ( $x, $y );
            }
        }

        <span style="color:#66d9ef">return</span> ( $max_x, $max_y );
    }
</code></pre></div><h3 id="using-the-square-root">using the SQUARE ROOT</h3>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/abigail/perl/ch-1.pl"><strong>Abigail</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/athanasius/perl/ch-1.pl"><strong>Athanasius</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/bob-lied/perl/ch-1.pl"><strong>Bob Lied</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/colin-crain/perl/ch-1.pl"><strong>Colin Crain</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/duane-powell/perl/ch-1.pl"><strong>Duane Powell</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/duncan-c-white/perl/ch-1.pl"><strong>Duncan C. White</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/e-choroba/perl/ch-1.pl"><strong>E. Choroba</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/james-smith/perl/ch-1.pl"><strong>James Smith</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/lubos-kolouch/perl/ch-1.pl"><strong>Lubos Kolouch</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/perlboy1967/perl/ch-1.pl"><strong>Niels van Dijke</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/paulo-custodio/perl/ch-1.pl"><strong>Paulo Custodio</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/pete-houston/perl/ch-1.pl"><strong>Pete Houston</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/roger-bell-west/perl/ch-1.pl"><strong>Roger Bell_West</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/wlmb/perl/ch-1.pl"><strong>W. Luis Mochan</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/wanderdoc/perl/ch-1.pl"><strong>Wanderdoc</strong></a></p>
<p>Moving along, it&rsquo;s intuitively obvious that the rectangle whose height and width will most nearly coincide is the one where they&rsquo;re the same value: a square. Perhaps rather than saying it&rsquo;s obvious we should just call it a tautology. In any case it then stands to reason that the ideal form for our &lsquo;tightly&rsquo; qualifier would be that of a square. The dimension of a side of one of these ideal spirals then is naturally the square root of the length. If that value works out evenly to an integer, then ding, ding, we have a winner.</p>
<p>If it does not, however, we will need to find the next best fit.</p>
<p>For every factor that evenly divides the target value there will be a complement factor, being the number it multiplies by to obtain the desired value. For each of these pairs one value will be less than the square root, the other more. Unless they <em>are</em> the square root, of course, in which case both values are the same. As such we really only need to search one side, the smaller, iterating up to and including the square root. Any factor located past that point will just be the complement to another already found on the way up.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/paulo-custodio/perl/ch-1.pl"><strong>Paulo Custodio</strong></a></p>
<p>In Paulo&rsquo;s solution he, as we said, iterates upward from 1 to the square root, and when a given pair evenly divides out the target length he keeps a running total that is overwritten without validating. This last point is interesting because as we get closer to the square root the difference between the two factors will always become smaller as the numbers approach the ideal. Thus the last values assigned to his <code>$low, $high</code> pair will always have the smallest difference between them.</p>
<p>He avoids actually calculating the square root exactly, and rather the iteration stops when the square of the iterator exceeds the target.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">smallest_rect</span> {
        <span style="color:#66d9ef">my</span>($n) <span style="color:#f92672">=</span> @_;
        <span style="color:#66d9ef">my</span> $low <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">my</span> $high <span style="color:#f92672">=</span> $n;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">my</span> $i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; $i<span style="color:#f92672">*</span>$i <span style="color:#f92672">&lt;=</span> $n; $i<span style="color:#f92672">++</span>) {
            <span style="color:#66d9ef">if</span> (($n % <span style="color:#960050;background-color:#1e0010">$</span>i) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
                $low <span style="color:#f92672">=</span> $i;
                $high <span style="color:#f92672">=</span> $n<span style="color:#f92672">/</span>$i;
            }
        }
        <span style="color:#66d9ef">return</span> ($low, $high);
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/athanasius/perl/ch-1.pl"><strong>Athanasius</strong></a></p>
<p>The monk gives us a different take, reversing the iteration range so we count downward from the square root. In this form we just take the first value that evenly divides, as that will be half the closest pair. After a quick check to make sure the square root itself is not the factor, their solution continues:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $div1 (reverse <span style="color:#ae81ff">2</span> <span style="color:#f92672">..</span> $root)
    {
        <span style="color:#66d9ef">my</span> $div2 <span style="color:#f92672">=</span> int($N <span style="color:#f92672">/</span> $div1);

        <span style="color:#66d9ef">if</span> ($div1 <span style="color:#f92672">*</span> $div2 <span style="color:#f92672">==</span> $N)
        {
            ($M, $N) <span style="color:#f92672">=</span> ($div1, $div2);
            <span style="color:#66d9ef">last</span>;
        }
    }
</code></pre></div><p>This was by far the most common trick for calculating the required matrix edges in the easiest manner. At least I thought so; it&rsquo;s a good trick:</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/colin-crain/perl/ch-1.pl"><strong>My Own Solution</strong></a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">find_dim</span> ($size) {
        <span style="color:#66d9ef">my</span> $try <span style="color:#f92672">=</span> (int sqrt $size) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">while</span> (<span style="color:#f92672">--</span>$try <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>) {
            <span style="color:#66d9ef">last</span> <span style="color:#66d9ef">unless</span> $size % <span style="color:#960050;background-color:#1e0010">$</span>try;
        }
        <span style="color:#66d9ef">return</span> ($try, int $size<span style="color:#f92672">/</span>$try);
    }
</code></pre></div><p>Finally, we have a ridiculously compact method from</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/james-smith/perl/ch-1.pl"><strong>James Smith</strong></a></p>
<p>The <code>grep</code> filters a list of all values from 1 to the square root, leaving only those that are factors of the target length. Reversing this list and assigning to an array of one element cleanly extracts the value closest to the root.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span>( $rows ) <span style="color:#f92672">=</span> reverse grep { <span style="color:#f92672">!</span> (@_ % <span style="color:#960050;background-color:#1e0010">$</span>_) } <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> sqrt @_;
</code></pre></div><h3 id="using-a-module">using a MODULE</h3>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/gustavo-chaves/perl/ch-1.pl"><strong>Gustavo Chaves</strong></a></p>
<p>Gustavo presents us with an interesting alternative to finding the ideal dimensions that deserves a further look.</p>
<p>He first imports the <code>Math::PARI</code> module to give him access to the <a href="https://en.wikipedia.org/wiki/PARI/GP">PARI</a> number theory library. This it turn gives him a <code>divisors</code> function, supplying the factors of the input array length. Starting with this list of factors, he then selects the value closest to the center index. As every factor in the list below the half-way point will have a corresponding complement above the half-way point, and the difference between the two values will diverge as we get further from the middle, those closest to the center will be be the closest pair.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">use</span> Math::Pari <span style="color:#e6db74">qw(:number)</span>;
    <span style="color:#66d9ef">use</span> integer;

    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">tight_matrix_dimensions</span> {
        <span style="color:#66d9ef">my</span> ($elements) <span style="color:#f92672">=</span> @_;
        <span style="color:#66d9ef">my</span> $divisors <span style="color:#f92672">=</span> divisors($elements);
        <span style="color:#66d9ef">my</span> $m <span style="color:#f92672">=</span> $divisors<span style="color:#f92672">-&gt;</span>[@$divisors<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>];
        <span style="color:#66d9ef">my</span> $n <span style="color:#f92672">=</span> $elements <span style="color:#f92672">/</span> $m;
        <span style="color:#66d9ef">return</span> (Math::Pari::pari2iv($m), Math::Pari::pari2iv($n));
    }
</code></pre></div><h2 id="wrapping-the-spiral">WRAPPING THE SPIRAL</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/abigail/perl/ch-1.pl"><strong>Abigail</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/athanasius/perl/ch-1.pl"><strong>Athanasius</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/bob-lied/perl/ch-1.pl"><strong>Bob Lied</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/colin-crain/perl/ch-1.pl"><strong>Colin Crain</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/dave-jacoby/perl/ch-1.pl"><strong>Dave Jacoby</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/duane-powell/perl/ch-1.pl"><strong>Duane Powell</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/e-choroba/perl/ch-1.pl"><strong>E. Choroba</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/paulo-custodio/perl/ch-1.pl"><strong>Paulo Custodio</strong></a></p>
<p>To actually fill the spiral matrix, overwhelmingly the method of choice was to work through the input array values, placing them one-by-one into the next location of the sequence. Because the spiral describes a continuous path, successive coordinates will only ever differ by 1, but the actual change in row and column indices will be determined by the direction of travel at any one moment.</p>
<p>To properly locate the next cell to fill then requires two pieces of information: the coordinate change in the current direction, and the limit of travel before the direction changes. Because the actual changes in direction always occur in the same sequential pattern, many people chose to unwind the operation into four distinct phases as each loop of the spiral is scribed.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/duane-powell/perl/ch-1.pl"><strong>Duane Powell</strong></a></p>
<p>Duane starts by establishing a &ldquo;bounding box&rdquo; of limits to the spiral being drawn. As rows and columns are filled in, these values are adjusted inwards, constraining the path as it spirals smaller.</p>
<p>The input array is iterated over, and each item placed in the current coordinates, then a series of <code>if/elsif</code> clauses determine where to position the next location.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#75715e"># Init bounding box walls and set matrix index to origin at (a,b)</span>
    <span style="color:#66d9ef">my</span> ($a, $b, $c, $d) <span style="color:#f92672">=</span> (<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, $n, $m);
    <span style="color:#66d9ef">my</span> ($x, $y) <span style="color:#f92672">=</span> ($a, $b);

    <span style="color:#75715e"># Populate matrix by spiralling counterclockwise</span>
    <span style="color:#75715e"># Start by heading east along the bottom of the matrix</span>
    <span style="color:#66d9ef">my</span> ($east, $north, $west, $south) <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>);
    <span style="color:#66d9ef">my</span> $dir <span style="color:#f92672">=</span> $east;
    <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $e (@array) {
        $matrix<span style="color:#f92672">-&gt;</span>[$y][$x] <span style="color:#f92672">=</span> $e;

        <span style="color:#66d9ef">if</span> ($dir <span style="color:#f92672">==</span> $east) {
            $x<span style="color:#f92672">++</span>;
            <span style="color:#66d9ef">if</span> ($x <span style="color:#f92672">==</span> $c) {
                $dir <span style="color:#f92672">=</span> $north;
                $a<span style="color:#f92672">++</span>; <span style="color:#75715e"># heading north raise the floor</span>
            }
        }
        <span style="color:#66d9ef">elsif</span> ($dir <span style="color:#f92672">==</span> $north) {
            $y<span style="color:#f92672">++</span>;
            <span style="color:#66d9ef">if</span> ($y <span style="color:#f92672">==</span> $d) {
                $dir <span style="color:#f92672">=</span> $west;
                $c<span style="color:#f92672">--</span>; <span style="color:#75715e"># heading west move right wall to the left</span>
            }
        }
        <span style="color:#66d9ef">elsif</span> ($dir <span style="color:#f92672">==</span> $west) {
            $x<span style="color:#f92672">--</span>;
            <span style="color:#66d9ef">if</span> ($x <span style="color:#f92672">&lt;</span> $a) {
                $dir <span style="color:#f92672">=</span> $south;
                $d<span style="color:#f92672">--</span>; <span style="color:#75715e"># heading south, lower the ceiling</span>
            }
        }
        <span style="color:#66d9ef">elsif</span> ($dir <span style="color:#f92672">==</span> $south) {
            $y<span style="color:#f92672">--</span>;
            <span style="color:#66d9ef">if</span> ($y <span style="color:#f92672">==</span> $b) {
                $dir <span style="color:#f92672">=</span> $east;
                $b<span style="color:#f92672">++</span>; <span style="color:#75715e"># heading east move left wall to the right</span>

                <span style="color:#75715e"># set (x,y) to origin of contracted bounding box</span>
                ($x, $y) <span style="color:#f92672">=</span> ($a, $b);
            }
        }
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/abigail/perl/ch-1.pl"><strong>Abigail</strong></a></p>
<p>Here&rsquo;s another version of the same technique from Abigail. Here the turn progression is not hard-coded in the directional clauses, but rather a flag is set and at the end of the sequence the <code>$direction</code> variable is incremented, modulo 4, to cycle through the pattern.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span> $matrix;
    <span style="color:#66d9ef">my</span> ($min_x, $max_x, $min_y, $max_y) <span style="color:#f92672">=</span> (<span style="color:#ae81ff">0</span>, $h <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, $w <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
    <span style="color:#66d9ef">my</span> $x <span style="color:#f92672">=</span> $max_x;
    <span style="color:#66d9ef">my</span> $y <span style="color:#f92672">=</span> $min_y;
    <span style="color:#66d9ef">my</span> $direction <span style="color:#f92672">=</span> $RIGHT;
    <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $element (@elements) {
        $$matrix [$x] [$y] <span style="color:#f92672">=</span> $element;
        <span style="color:#66d9ef">my</span> $turn <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">if</span> ($direction <span style="color:#f92672">==</span> $RIGHT) {
            <span style="color:#66d9ef">if</span>   ($y <span style="color:#f92672">&gt;=</span> $max_y) {$turn <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; $x <span style="color:#f92672">--</span>; $max_x <span style="color:#f92672">--</span>}
            <span style="color:#66d9ef">else</span> {$y <span style="color:#f92672">++</span>}
        }
        <span style="color:#66d9ef">if</span> ($direction <span style="color:#f92672">==</span> $UP) {
            <span style="color:#66d9ef">if</span>   ($x <span style="color:#f92672">&lt;=</span> $min_x) {$turn <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; $y <span style="color:#f92672">--</span>; $max_y <span style="color:#f92672">--</span>}
            <span style="color:#66d9ef">else</span> {$x <span style="color:#f92672">--</span>}
        }
        <span style="color:#66d9ef">if</span> ($direction <span style="color:#f92672">==</span> $LEFT) {
            <span style="color:#66d9ef">if</span>   ($y <span style="color:#f92672">&lt;=</span> $min_y) {$turn <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; $x <span style="color:#f92672">++</span>; $min_x <span style="color:#f92672">++</span>}
            <span style="color:#66d9ef">else</span> {$y <span style="color:#f92672">--</span>}
        }
        <span style="color:#66d9ef">if</span> ($direction <span style="color:#f92672">==</span> $DOWN) {
            <span style="color:#66d9ef">if</span>   ($x <span style="color:#f92672">&gt;=</span> $max_x) {$turn <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; $y <span style="color:#f92672">++</span>; $min_y <span style="color:#f92672">++</span>}
            <span style="color:#66d9ef">else</span> {$x <span style="color:#f92672">++</span>}
        }
        <span style="color:#66d9ef">if</span> ($turn) {
            $direction <span style="color:#f92672">++</span>;
            $direction %<span style="color:#960050;background-color:#1e0010">=</span> 4;
        }
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/paulo-custodio/perl/ch-1.pl"><strong>Paulo Custodio</strong></a></p>
<p>Returning to Paulo, he gives us a nicely laid out example of one technique. In it he loops through the four directions, continuing in each until he arrives at either an outside edge boundary or an already assigned, and hence not undefined, cell. At that point the direction is changed and the plotting continues. At the end of the four inner loops the cycle is restarted, progressing until the input runs out of data. Because the matrix has already been carefully sized, there is no need to validate that there is enough room; we will always be assured there will be space.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">while</span> (@list) {
        <span style="color:#75715e"># go East</span>
        <span style="color:#66d9ef">while</span> (@list <span style="color:#f92672">&amp;&amp;</span> $c <span style="color:#f92672">&lt;=</span> $n <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>defined($rect[$r][$c])) {
            $rect[$r][$c] <span style="color:#f92672">=</span> sprintf(<span style="color:#e6db74">&#34;%*s&#34;</span>, $width, shift @list);
            $c<span style="color:#f92672">++</span>;
        }
        $c<span style="color:#f92672">--</span>; $r<span style="color:#f92672">--</span>;
        <span style="color:#75715e"># go North</span>
        <span style="color:#66d9ef">while</span> (@list <span style="color:#f92672">&amp;&amp;</span> $r <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>defined($rect[$r][$c])) {
            $rect[$r][$c] <span style="color:#f92672">=</span> sprintf(<span style="color:#e6db74">&#34;%*s&#34;</span>, $width, shift @list);
            $r<span style="color:#f92672">--</span>;
        }
        $r<span style="color:#f92672">++</span>; $c<span style="color:#f92672">--</span>;
        <span style="color:#75715e"># go West</span>
        <span style="color:#66d9ef">while</span> (@list <span style="color:#f92672">&amp;&amp;</span> $c <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>defined($rect[$r][$c])) {
            $rect[$r][$c] <span style="color:#f92672">=</span> sprintf(<span style="color:#e6db74">&#34;%*s&#34;</span>, $width, shift @list);
            $c<span style="color:#f92672">--</span>;
        }
        $c<span style="color:#f92672">++</span>; $r<span style="color:#f92672">++</span>;
        <span style="color:#75715e"># go South</span>
        <span style="color:#66d9ef">while</span> (@list <span style="color:#f92672">&amp;&amp;</span> $r <span style="color:#f92672">&lt;=</span> $m <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>defined($rect[$r][$c])) {
            $rect[$r][$c] <span style="color:#f92672">=</span> sprintf(<span style="color:#e6db74">&#34;%*s&#34;</span>, $width, shift @list);
            $r<span style="color:#f92672">++</span>;
        }
        $r<span style="color:#f92672">--</span>; $c<span style="color:#f92672">++</span>;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/dave-jacoby/perl/ch-1.pl"><strong>Dave Jacoby</strong></a></p>
<p>The process we&rsquo;re described is to take a step, &ldquo;Are we done?&rdquo; Check what to do next, take a step&hellip; which sounds, to Dave, like a job for recursion.</p>
<p>So, Dave introduces recursion to the picture.</p>
<p>It&rsquo;s a good fit, and I&rsquo;m a little surprised more didn&rsquo;t make the selection. Eventually with really long arrays things could get problematically deep, but, well, you know. Then we do have Stuart Little&rsquo;s solution, but that&rsquo;s a whole &lsquo;nother level of arcane weirdness.</p>
<p>Abstaining from a mutable set of bounding parameters, Dave only uses the pair of earlier calculated ideal spiral parameters and a check for definition to look ahead to the limits of his directional runs. Once he&rsquo;s found which way to go, he descends and repeats the process with a new set of coordinates, for as long as there&rsquo;s more elements to allocate.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#75715e">#   0 = right</span>
    <span style="color:#75715e">#   1 = up</span>
    <span style="color:#75715e">#   2 = left</span>
    <span style="color:#75715e">#   3 = down</span>
    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">make_spiral</span> ( $base, $array, $dir, $m, $n, $x, $y, $i ) {
        <span style="color:#66d9ef">my</span> $s <span style="color:#f92672">=</span> scalar $array<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>
        <span style="color:#960050;background-color:#1e0010">$</span>base<span style="color:#f92672">-&gt;</span>[$x][$y] <span style="color:#f92672">=</span> $array<span style="color:#f92672">-&gt;</span>[$i];

        <span style="color:#75715e"># handles cases when we need to change $dir</span>
        <span style="color:#66d9ef">if</span> (<span style="color:#ae81ff">0</span>) { <span style="color:#e6db74">&#39;&#39;</span> }
        <span style="color:#66d9ef">elsif</span> ( $dir <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> ( $y <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;=</span> $n <span style="color:#f92672">||</span> defined $base<span style="color:#f92672">-&gt;</span>[$x][ $y <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> ] ) ) {
            $dir <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        }
        <span style="color:#66d9ef">elsif</span> ( $dir <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> ( $x <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> defined $base<span style="color:#f92672">-&gt;</span>[ $x <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> ][$y] ) ) {
            $dir <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
        }
        <span style="color:#66d9ef">elsif</span> ( $dir <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">&amp;&amp;</span> ( $y <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> defined $base<span style="color:#f92672">-&gt;</span>[$x][ $y <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> ] ) ) {
            $dir <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
        }
        <span style="color:#66d9ef">elsif</span> ( $dir <span style="color:#f92672">==</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">&amp;&amp;</span> ( $x <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> defined $base<span style="color:#f92672">-&gt;</span>[ $x <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> ][$y] ) ) {
            $dir <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        }

        <span style="color:#75715e"># goes to the next spot in the matrix</span>
        <span style="color:#75715e"># if there&#39;s any places in the matrix open still</span>
        <span style="color:#66d9ef">if</span> ( scalar grep { <span style="color:#f92672">!</span>defined } flatten($base) ) {
            <span style="color:#66d9ef">if</span> (<span style="color:#ae81ff">0</span>) { }
            <span style="color:#66d9ef">elsif</span> ( $dir <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> ) {
                make_spiral( $base, $array, $dir, $m, $n, $x, $y <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, $i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> );
            }
            <span style="color:#66d9ef">elsif</span> ( $dir <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> ) {
                make_spiral( $base, $array, $dir, $m, $n, $x <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, $y, $i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> );
            }
            <span style="color:#66d9ef">elsif</span> ( $dir <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span> ) {
                make_spiral( $base, $array, $dir, $m, $n, $x, $y <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, $i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> );
            }
            <span style="color:#66d9ef">elsif</span> ( $dir <span style="color:#f92672">==</span> <span style="color:#ae81ff">3</span> ) {
                make_spiral( $base, $array, $dir, $m, $n, $x <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, $y, $i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> );
            }
        }

    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/duncan-c-white/perl/ch-1.pl"><strong>Duncan C. White</strong></a></p>
<p>Duncan takes the unusual twist of sectioning out the four parts driving his directional fills into separate subroutines, each calling the next at the final line if any input values remain to be placed. When the array runs out, the entire structure collapses and the spiral remains complete.</p>
<p>Here is an example of his <code>east</code> function (think subroutine with a signature):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#75715e"># east( $currm, $currn, $m, $n );</span>
    <span style="color:#75715e">#    Move EAST $n times using values from global @vals, adding</span>
    <span style="color:#75715e">#    them to global $the_mat[$currm][$currn..], then carry the spiral</span>
    <span style="color:#75715e">#    on to an M-1 x N matrix, NORTH, then WEST..</span>
    <span style="color:#75715e">#</span>
    fun east( $currm, $currn, $m, $n )
    {
        <span style="color:#66d9ef">my</span> $mstr <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;E($currm,$currn,$m,$n):\n&#34;</span><span style="color:#f92672">.</span>mat2str(@the_mat);
        say $mstr <span style="color:#66d9ef">if</span> $debug;
        <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $i (<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$n)
        {
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">unless</span> @vals;
            die <span style="color:#e6db74">&#34;run out of values in $mstr\n&#34;</span> <span style="color:#66d9ef">unless</span> @vals;
            <span style="color:#66d9ef">my</span> $val <span style="color:#f92672">=</span> shift @vals;
            $currn<span style="color:#f92672">++</span>;
            $the_mat[$currm][$currn] <span style="color:#f92672">=</span> $val;
        }

        <span style="color:#75715e"># have now dealt with current row, (m-1) x n matrix to fill, north</span>
        north( $currm, $currn, $m<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, $n ) <span style="color:#66d9ef">if</span> @vals;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/e-choroba/perl/ch-1.pl"><strong>E. Choroba</strong></a></p>
<p>Choroba refactors the four directional cases from the unrolled version, creating a single  parameterized structure to place the next element into whatever continuing line is being built at that moment.</p>
<p>The innermost <code>if</code> block is executed when the next element to be filled falls outside the boundaries,  registering a change in direction. And the clever part: when this happens <code>redo</code> is called, restarting the loop cycle without grabbing the next element. Thus the element is placed again at the same coordinates, but this time as start of of a new directional path. Because the <code>redo</code> prevents the next value from being taken in the <code>for</code> loop this sequence will never terminate when we get to boxed in at the end of the spiral; consequently a <code>last</code> statement is buried deep within the structure, which will only execute when two turns are taken sequentially without moving. Nice.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $element (@arr) {
        $spiral[$y][$x] <span style="color:#f92672">=</span> $element;

        <span style="color:#66d9ef">my</span> $new_x <span style="color:#f92672">=</span> $x <span style="color:#f92672">+</span> $DIRECTIONS[$direction][<span style="color:#ae81ff">0</span>];
        <span style="color:#66d9ef">my</span> $new_y <span style="color:#f92672">=</span> $y <span style="color:#f92672">+</span> $DIRECTIONS[$direction][<span style="color:#ae81ff">1</span>];
        <span style="color:#66d9ef">if</span> ($new_x <span style="color:#f92672">&lt;</span> $borders[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">||</span> $new_x <span style="color:#f92672">&gt;</span> $borders[<span style="color:#ae81ff">1</span>]
            <span style="color:#f92672">||</span> $new_y <span style="color:#f92672">&lt;</span> $borders[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">||</span> $new_y <span style="color:#f92672">&gt;</span> $borders[<span style="color:#ae81ff">0</span>]
        ) {
            <span style="color:#66d9ef">last</span> <span style="color:#66d9ef">if</span> $turned;

            $borders[$direction] <span style="color:#f92672">+=</span> (<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>)[$direction];
            $direction <span style="color:#f92672">=</span> ($direction <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) % 4;
            $turned <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
            <span style="color:#66d9ef">redo</span>
        }
        undef $turned;
        ($x, $y) <span style="color:#f92672">=</span> ($new_x, $new_y);
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/perlboy1967/perl/ch-1.pl"><strong>Niels van Dijke</strong></a></p>
<p>Niels encodes a set of directional delta pairs for each direction travelled; accessing these values in a <code>@d</code> array by an index modulo 4 and detecting his interior boundaries as already-filled cells allows him to keep the core logic quite compact, albeit at a certain expense of clarity.</p>
<p>It does have a directness to though, which I like.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">  <span style="color:#66d9ef">my</span> @d <span style="color:#f92672">=</span> ([<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>],[<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>],[<span style="color:#ae81ff">0</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>],[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>]);
  <span style="color:#66d9ef">my</span> $d <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

  <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $v (@$arA) {
    $g<span style="color:#f92672">-&gt;</span>[$r][$c] <span style="color:#f92672">=</span> $v;
    <span style="color:#66d9ef">if</span> ($r <span style="color:#f92672">+</span> $d[$d][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> $w <span style="color:#f92672">or</span>
        $c <span style="color:#f92672">+</span> $d[$d][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> $h <span style="color:#f92672">or</span>
        $r <span style="color:#f92672">+</span> $d[$d][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span>
        $c <span style="color:#f92672">+</span> $d[$d][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span>
        defined $g<span style="color:#f92672">-&gt;</span>[$r <span style="color:#f92672">+</span> $d[$d][<span style="color:#ae81ff">0</span>]][$c <span style="color:#f92672">+</span> $d[$d][<span style="color:#ae81ff">1</span>]]) {
      $d <span style="color:#f92672">=</span> (<span style="color:#f92672">++</span>$d % 4);
    }
    ($r, $c) <span style="color:#f92672">=</span> ($r <span style="color:#f92672">+</span> $d[$d][<span style="color:#ae81ff">0</span>], $c <span style="color:#f92672">+</span> $d[$d][<span style="color:#ae81ff">1</span>]);
  }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/james-smith/perl/ch-1.pl"><strong>James Smith</strong></a></p>
<p>James&rsquo; assignment to the spiral matrix is similarly as compact as his dimensional solution. By inserting his adjustment of the individual routines directly into the assignment, the loops controlling the directional placements become a single line each:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">while</span>( @_ ) {                                        <span style="color:#75715e"># do until empty</span>
        $out[ $r ][ <span style="color:#f92672">++</span>$c ] <span style="color:#f92672">=</span> shift <span style="color:#66d9ef">foreach</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> $cols<span style="color:#f92672">--</span>; <span style="color:#75715e"># &gt;&gt;</span>
        $out[ <span style="color:#f92672">--</span>$r ][ $c ] <span style="color:#f92672">=</span> shift <span style="color:#66d9ef">foreach</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> <span style="color:#f92672">--</span>$rows; <span style="color:#75715e"># ^^</span>
        <span style="color:#66d9ef">last</span>                       <span style="color:#66d9ef">unless</span>  @_;           <span style="color:#75715e"># exit if empty</span>
        $out[ $r ][ <span style="color:#f92672">--</span>$c ] <span style="color:#f92672">=</span> shift <span style="color:#66d9ef">foreach</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> $cols<span style="color:#f92672">--</span>; <span style="color:#75715e"># &lt;&lt;</span>
        $out[ <span style="color:#f92672">++</span>$r ][ $c ] <span style="color:#f92672">=</span> shift <span style="color:#66d9ef">foreach</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> <span style="color:#f92672">--</span>$rows; <span style="color:#75715e"># vv</span>
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/wlmb/perl/ch-1.pl"><strong>W. Luis Mochan</strong></a></p>
<p>Perhaps taking the refactoring further than anyone else, Luis abstracts out the idea of  forward movement itself into not a specific routine, but rather a <code>build_moves()</code> function generator, which when properly configured produces four coderefs, one for each of the directions around the spiral. One curious aspect of this is that the anonymous routines themselves contain a reference to the <em>next</em> routine, called when the need arises to change direction. This in turn produces a seeming reference paradox, as we need to initialize the routines with references to other routines, producing a chicken-and-egg problem. He gets around this by using double-indirection on initialization, calling the generator with a reference to a reference.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span> $right;
    <span style="color:#66d9ef">my</span> $down<span style="color:#f92672">=</span> build_moves(<span style="color:#ae81ff">0</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,  <span style="color:#ae81ff">0</span>, <span style="color:#f92672">\</span>$right);
    <span style="color:#66d9ef">my</span> $left<span style="color:#f92672">=</span> build_moves(<span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">\</span>$down);
    <span style="color:#66d9ef">my</span> $up<span style="color:#f92672">=</span>   build_moves(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, $N, <span style="color:#f92672">\</span>$left);
    $right<span style="color:#f92672">=</span>   build_moves(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, $M, <span style="color:#f92672">\</span>$up);
    <span style="color:#66d9ef">my</span> $next_move<span style="color:#f92672">=</span>$right; <span style="color:#75715e"># First move to try</span>

    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">build_moves</span> {
        <span style="color:#66d9ef">my</span> $index<span style="color:#f92672">=</span>shift; <span style="color:#75715e"># which coordinate to affect</span>
        <span style="color:#66d9ef">my</span> $delta<span style="color:#f92672">=</span>shift; <span style="color:#75715e"># increment</span>
        <span style="color:#66d9ef">my</span> $border<span style="color:#f92672">=</span>shift; <span style="color:#75715e"># current position of border</span>
        <span style="color:#66d9ef">my</span> $next<span style="color:#f92672">=</span>shift;  <span style="color:#75715e"># next direction to try.</span>
        <span style="color:#66d9ef">sub</span> {
        <span style="color:#66d9ef">if</span>($current_coords[$index]<span style="color:#f92672">+</span>$delta<span style="color:#f92672">==</span>$border){
            $next_move<span style="color:#f92672">=</span>$$next;
            $border<span style="color:#f92672">=</span> $border<span style="color:#f92672">-</span>$delta;
            $next_move<span style="color:#f92672">-&gt;</span>();
        } <span style="color:#66d9ef">else</span> {
            $current_coords[$index]<span style="color:#f92672">+=</span>$delta;
        }
        }
    }
</code></pre></div><h2 id="temporal-anomalies-and-radical-data-engineering">TEMPORAL ANOMALIES and RADICAL DATA ENGINEERING</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/cheok-yin-fung/perl/ch-1.pl"><strong>Cheok-Yin Fung</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/jo-37/perl/ch-1.pl"><strong>Jorg Sommrey</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/stuart-little/perl/ch-1.pl"><strong>Stuart Little</strong></a></p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/cheok-yin-fung/perl/ch-1.pl"><strong>Cheok-Yin Fung</strong></a></p>
<p>Many members were able to revisit concepts they first gleaned in <a href="https://perlweeklychallenge.org/blog/perl-weekly-challenge-088/">PWC 088</a> to guide their methods, but CY, exercising her unparalleled powers of prognostication, was able to solve this challenge <em>in its entirety</em> a <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/cheok-yin-fung/perl/ch-2.pl">full 14 weeks before it was even issued</a>. I would like to know more about these techniques of time travel she she wields so adroitly.</p>
<p>As its very existence seemingly defies the laws of physics, here it is in its entirety, lest it disappear at any moment into the paradox from which it came.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">matrixize_anticlockwise</span> {
        <span style="color:#66d9ef">my</span> @list <span style="color:#f92672">=</span> @{$_[<span style="color:#ae81ff">0</span>]};
        <span style="color:#66d9ef">my</span> $M <span style="color:#f92672">=</span> $_[<span style="color:#ae81ff">1</span>];
        <span style="color:#66d9ef">my</span> $N <span style="color:#f92672">=</span> $_[<span style="color:#ae81ff">2</span>];
        <span style="color:#66d9ef">my</span> @mat;
        <span style="color:#66d9ef">my</span> @helper_mat;

    <span style="color:#75715e">#BEGIN: special case handling: the numbers of entries is prime</span>
        <span style="color:#66d9ef">if</span> ($M <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {<span style="color:#66d9ef">return</span> <span style="color:#f92672">\</span>@list;}
    <span style="color:#75715e">#END: special case handling</span>

        <span style="color:#66d9ef">my</span> @row_dir <span style="color:#f92672">=</span> (  <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,  <span style="color:#ae81ff">0</span>, <span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> );
        <span style="color:#66d9ef">my</span> @col_dir <span style="color:#f92672">=</span> ( <span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,  <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,  <span style="color:#ae81ff">0</span> );

        <span style="color:#66d9ef">my</span> ($r, $c) <span style="color:#f92672">=</span> ( $M<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> , <span style="color:#ae81ff">0</span>);
        ${$mat[$r]}[$c] <span style="color:#f92672">=</span> $list[<span style="color:#ae81ff">0</span>];
        ${$helper_mat[$r]}[$c] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;

        <span style="color:#66d9ef">my</span> @numbering <span style="color:#f92672">=</span> (
            [<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$N<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>],
            [$N<span style="color:#f92672">..</span>$N<span style="color:#f92672">+</span>$M<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>],
            [$N<span style="color:#f92672">+</span>$M<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$N<span style="color:#f92672">+</span>$M<span style="color:#f92672">+</span>$N<span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>],
            [$N<span style="color:#f92672">+</span>$M<span style="color:#f92672">+</span>$N<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span><span style="color:#f92672">..</span>($M<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span><span style="color:#f92672">+</span>($N<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
        );

        say <span style="color:#e6db74">&#34;@$_&#34;</span> <span style="color:#66d9ef">for</span> @numbering;

        <span style="color:#66d9ef">my</span> $count <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $q (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">3</span>) {
            <span style="color:#66d9ef">for</span> (@{$numbering[$q]}) {
                $r <span style="color:#f92672">+=</span> $row_dir[$q];
                $c <span style="color:#f92672">+=</span> $col_dir[$q];

                ${$mat[$r]}[$c] <span style="color:#f92672">=</span> $list[$count];
                ${$helper_mat[$r]}[$c] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;

                $count<span style="color:#f92672">++</span>;
            }
        }

        <span style="color:#66d9ef">my</span> $time_now <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
        <span style="color:#66d9ef">my</span> $success_click <span style="color:#f92672">=</span> undef;
        <span style="color:#66d9ef">while</span> ($count <span style="color:#f92672">&lt;</span> $M<span style="color:#f92672">*</span>$N) {
            <span style="color:#66d9ef">if</span> ($success_click) {
                $r <span style="color:#f92672">+=</span> $row_dir[$time_now];
                $c <span style="color:#f92672">+=</span> $col_dir[$time_now];
                <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>defined ${$helper_mat[$r]}[$c]  )
                {
                    ${$mat[$r]}[$c] <span style="color:#f92672">=</span> $list[$count];
                    ${$helper_mat[$r]}[$c] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
                    $success_click <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
                    $count<span style="color:#f92672">++</span>;
                } <span style="color:#66d9ef">else</span>
                {
                    $success_click <span style="color:#f92672">=</span> undef;
                    $r <span style="color:#f92672">-=</span> $row_dir[$time_now];
                    $c <span style="color:#f92672">-=</span> $col_dir[$time_now];
                }
            } <span style="color:#66d9ef">else</span>
            {
                $time_now <span style="color:#f92672">=</span> ($time_now<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) % 4;
                $success_click <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
            }
        }
        <span style="color:#66d9ef">return</span> @mat;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/jo-37/perl/ch-1.pl"><strong>Jorg Sommrey</strong></a></p>
<p>After determining the ideal form factor for the spiral by finding the middle of a list of divisors, Jorg whips out the Perl Data Language to manipulate his spiral matrix.  He builds his matrix from the back forward, literally rolling it up like rug: adding a slice of the array, then flopping it over, adding on the next row of values, and rolling again. I found his technique somewhat hilarious in its ridiculous practicality. I must need more sleep.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">form</span> :prototype($) ($n) {
        <span style="color:#66d9ef">my</span> @d <span style="color:#f92672">=</span> divisors $n;

        <span style="color:#75715e"># Difference of the &#34;middle&#34; divisors.</span>
        $d[@d <span style="color:#e6db74">/ 2] - $d[-(@d /</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)];
    }

    <span style="color:#75715e"># Roll a matrix from an array of numeric values.</span>
    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">roll</span> ($arr, $alt=0) {

        <span style="color:#75715e"># Create the starting matrix as a single row or column from a piece</span>
        <span style="color:#75715e"># off the list tail, sized according to the matrix&#39; form.  The</span>
        <span style="color:#75715e"># solution&#39;s orientation is predefined by the starting matrix.</span>
        <span style="color:#75715e"># Providing either variants.</span>
        <span style="color:#66d9ef">my</span> $roll <span style="color:#f92672">=</span> pdl(splice @$arr, <span style="color:#f92672">-</span>(form(@$arr) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>))
            <span style="color:#f92672">-&gt;</span>slice($alt ? <span style="color:#e6db74">&#39;*,-1:0&#39;</span> : <span style="color:#e6db74">&#39;X,*&#39;</span>)<span style="color:#f92672">-&gt;</span>sever;
        say $roll <span style="color:#66d9ef">if</span> $verbose;

        <span style="color:#66d9ef">while</span> (@$arr) {
            <span style="color:#75715e"># Left-rotate the current matrix and add an apt piece off the</span>
            <span style="color:#75715e"># list tail.</span>
            $roll <span style="color:#f92672">=</span> $roll
                <span style="color:#f92672">-&gt;</span>slice(<span style="color:#e6db74">&#39;-1:0&#39;</span>)<span style="color:#f92672">-&gt;</span>xchg(<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>)
                <span style="color:#f92672">-&gt;</span>glue(<span style="color:#ae81ff">1</span>, pdl splice @$arr, <span style="color:#f92672">-</span>$roll<span style="color:#f92672">-&gt;</span>dim(<span style="color:#ae81ff">1</span>))
                <span style="color:#f92672">-&gt;</span>sever;
            say $roll <span style="color:#66d9ef">if</span> $verbose;
        }

        <span style="color:#75715e"># Return the solution as an AoA or as the piddle itself depending on</span>
        <span style="color:#75715e"># the context.</span>
        wantarray ? $roll<span style="color:#f92672">-&gt;</span>unpdl<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span> : $roll;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/stuart-little/perl/ch-1.pl"><strong>Stuart Little</strong></a></p>
<p>Stuart&rsquo;s amazing submission shares quite a lot of process with Jorg&rsquo;s, albeit using entirely different methods.</p>
<p>First, he dispatches his quest of the ideal spiral dimensions by creating a list of all factors to the target length and selecting the middle elements. So far so good.</p>
<p>Then remarkably, Stuart has managed to accomplish the same rolling motion described above through recursion. The path is tortuous, but first the recursion, in <code>pck()</code>, descends to the bottom, slicing shorter and shorter segments off the input array. Then once hitting bottom, on each return another routine, <code>rtcc()</code> rotates the progressively reassembled matrix as the original segments are rejoined. It&rsquo;s a work of art, I say.</p>
<p>Note the way the two first elements are reversed on every call, so that first one row is removed, then one column, then one row. Impressed doesn&rsquo;t cover it.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">use</span> List::AllUtils <span style="color:#e6db74">qw(min_by)</span>;

    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">rtcc</span>($m) {
        <span style="color:#66d9ef">my</span> @res;
        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $ix (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>scalar @{$m<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>]}<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
        <span style="color:#66d9ef">my</span> @col <span style="color:#f92672">=</span> map {$_<span style="color:#f92672">-&gt;</span>[$ix]} @{$m};
        push @res, (<span style="color:#f92672">\</span>@col,);
        }
        <span style="color:#66d9ef">return</span> [reverse @res];
    }

    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">pck</span>($rows,$cols,$a) {
        $rows <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#66d9ef">return</span> [$a,];
        $cols <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#66d9ef">return</span> [map {[$_,]} reverse @{$a}];
        <span style="color:#66d9ef">my</span> $rot <span style="color:#f92672">=</span> rtcc(pck($cols,$rows<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,[$a<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">[$</span>cols<span style="color:#f92672">..</span>scalar @{$a}<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]]));
        <span style="color:#66d9ef">return</span> [@$rot,[$a<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">[</span>0<span style="color:#f92672">..</span>$cols<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]]];
    }

    <span style="color:#66d9ef">my</span> $els <span style="color:#f92672">=</span> scalar @ARGV;
    <span style="color:#66d9ef">my</span> $rows <span style="color:#f92672">=</span> min_by { abs($_ <span style="color:#f92672">-</span> $els<span style="color:#e6db74">/$_) } grep {$els % $_ == 0} (1..int($els/</span><span style="color:#ae81ff">2</span>));
    <span style="color:#66d9ef">my</span> $cols <span style="color:#f92672">=</span> int($els<span style="color:#f92672">/</span>$rows);

    <span style="color:#66d9ef">for</span> (@{pck($rows,$cols,[map {sprintf(<span style="color:#e6db74">&#34;%5s&#34;</span>, $_)} @ARGV])}) {
        say <span style="color:#e6db74">&#34;@$_&#34;</span>;
    }
</code></pre></div><hr>
<h1 id="PWC101TASK2">TASK 2</h1>
<h1 id="origin-containing-triangle">Origin-containing Triangle</h1>
<p><em>Submitted by: Stuart Little</em></p>
<p>You are given three points in the plane, as a list of six co-ordinates: A=(x1,y1), B=(x2,y2) and C=(x3,y3).</p>
<p>Write a script to find out if the triangle formed by the given three co-ordinates contain origin (0,0).</p>
<p>Print 1 if found otherwise 0.</p>
<p>Example 1:</p>
<pre><code>Input : A=(0,1), B=(1,0) and C=(2,2)
Output: 0 because that triangle does not contain (0,0).
</code></pre>
<p>Example 2:</p>
<pre><code>Input : A=(1,1), B=(-1,1) and C=(0,-3)
Output: 1 because that triangle contains (0,0) in its interior.
</code></pre>
<p>Example 3:</p>
<pre><code>Input : A=(0,1), B=(2,0) and C=(-6,0)
Output: 1 because (0,0) is on the edge connecting B and C.
</code></pre>
<h2 id="about-the-solutions-1">about the solutions</h2>
<p>There were 20 submissions for the second task this past week.</p>
<p>This particular task, whether a given point lies within a bounded area, be it a triangle or a generalized polygon, comes into play in real, practical applications, specifically modeling the real world in virtual simulation: &ldquo;Is this thing touching that?&rdquo;</p>
<p>Because video games require quite a lot of this sort of thing, mountains of work has been done and a great many schemes have evolved to determine this state quickly and efficiently. To list a few of the most common methods:</p>
<ol>
<li>using barycentric coodinates</li>
<li>using parametric equations</li>
<li>using the vector product</li>
<li>checking an equal sum of triangle areas</li>
<li>checking a 360° sum of angles</li>
<li>counting single edge intersection with a ray-cast line</li>
<li>non-zero winding numbers counting axis crossings</li>
</ol>
<p>Most of these techniques were represented today. We&rsquo;ll have a brief look at those that were.</p>
<h2 id="the-vector-product">the VECTOR PRODUCT</h2>
<p><strong>Abigail</strong>,
<strong>Colin Crain</strong>,
<strong>Lubos Kolouch</strong>,
<strong>Paulo Custodio</strong>,
<strong>Pete Houston</strong>,
<strong>Roger Bell_West</strong>, and
<strong>W. Luis Mochan</strong></p>
<p>The most common method chosen involves some advanced mathematics, but in another sense is fairly easy to understand. What we do here is, for each point, to take what is known as the <a href="https://en.wikipedia.org/wiki/Cross_product">vector product</a> between the two vectors going from the origin to the point, and from the point to the next point. Consider a vector to be a line with a direction attached, a point to go <em>from</em> and a point to go <em>to</em>. Without delving too far into the mathematics, due to a property known as the <a href="https://en.wikipedia.org/wiki/Right-hand_rule">right hand rule</a>, it&rsquo;s easy to visualize that the <em>z</em>-component of this calculation will, if the direction of the turning described by the vectors is counterclockwise, be upward, or positive. Conversely if the turning is clockwise, this value will be negative.</p>
<p>This gives us a quick and easy insight as to whether the origin lies to the left or the right of each edge of the triangle. Now some more visualization tells us that if the origin lies consistently to the left of each edge, the edges must by necessity wrap around the origin. The same logic applies for the right side as well of course, and to complete the picture if the origin lies on one of the edges this value will be 0.</p>
<p>Thus if all values for this calculation are either positive or negative, or any value is 0, the triangle encloses the origin.</p>
<p><strong>Abigail</strong></p>
<p>Abigail walks us through the process:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#75715e"># This determines on which side of the line through ($x1, $y1) and</span>
    <span style="color:#75715e"># ($x2, $y2) the origin lies. If &gt; 0, then the origin lies to the left</span>
    <span style="color:#75715e"># of the line, if &lt; 0, the origin lies to the right of the line, if</span>
    <span style="color:#75715e"># = 0, the origin lies on the line.</span>
    <span style="color:#75715e">#</span>
    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">side</span> ($x1, $y1, $x2, $y2) {
        ($y2 <span style="color:#f92672">-</span> $y1) <span style="color:#f92672">*</span> $x2 <span style="color:#f92672">-</span> ($x2 <span style="color:#f92672">-</span> $x1) <span style="color:#f92672">*</span> $y2;
    }

    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">&lt;&gt;</span>) {
        <span style="color:#66d9ef">my</span> ($x1, $y1, $x2, $y2, $x3, $y3) <span style="color:#f92672">=</span> split;

        <span style="color:#75715e">#</span>
        <span style="color:#75715e"># Determine where the origin is relative to the three lines</span>
        <span style="color:#75715e"># through the vertices of the triangle. Note we have to go</span>
        <span style="color:#75715e"># in a specific order through the points. (Either clock wise,</span>
        <span style="color:#75715e"># or counter clockwise, as long as we&#39;re consistent).</span>
        <span style="color:#75715e">#</span>
        <span style="color:#66d9ef">my</span> $s1 <span style="color:#f92672">=</span> side ($x2, $y2, $x3, $y3);
        <span style="color:#66d9ef">my</span> $s2 <span style="color:#f92672">=</span> side ($x3, $y3, $x1, $y1);
        <span style="color:#66d9ef">my</span> $s3 <span style="color:#f92672">=</span> side ($x1, $y1, $x2, $y2);

        <span style="color:#75715e">#</span>
        <span style="color:#75715e"># If the origin either lies to the left (or on) each of the</span>
        <span style="color:#75715e"># lines, or to the right (or on) each of the lines, the origin</span>
        <span style="color:#75715e"># lies inside the triangle. If not, it does not.</span>
        <span style="color:#75715e">#</span>
        say $s1 <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> $s2 <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> $s3 <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span>
            $s1 <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> $s2 <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> $s3 <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> ? <span style="color:#ae81ff">1</span> : <span style="color:#ae81ff">0</span>
    }
</code></pre></div><p><strong>Pete Houston</strong></p>
<p>With Pete it&rsquo;s more clear that what we&rsquo;re looking at is the delta, that is the change, in the x and y coordinates between the points.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">inside_paths</span> {
        <span style="color:#75715e"># Determine if the origin is on the same side of each line segment</span>
        <span style="color:#75715e"># as the 3rd point. If so, it is inside. If it is on any of the line</span>
        <span style="color:#75715e"># segments that&#39;s a positive result right away.</span>
        <span style="color:#75715e"># Return 1 for inside or on the line, 0 otherwise</span>

        <span style="color:#66d9ef">my</span> @p <span style="color:#f92672">=</span> pairs @_;
        <span style="color:#66d9ef">my</span> $sameside <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i (<span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> <span style="color:#ae81ff">2</span>) {
            <span style="color:#66d9ef">my</span> @q <span style="color:#f92672">=</span> map { $p[$_] } grep { $_ <span style="color:#f92672">!=</span> $i } (<span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> <span style="color:#ae81ff">2</span>);
            <span style="color:#66d9ef">my</span> $dx <span style="color:#f92672">=</span> $q[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">-</span> $q[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>];
            <span style="color:#66d9ef">my</span> $dy <span style="color:#f92672">=</span> $q[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> $q[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>];
            <span style="color:#66d9ef">my</span> $originside <span style="color:#f92672">=</span> (<span style="color:#ae81ff">0</span> <span style="color:#f92672">-</span> $q[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>]) <span style="color:#f92672">*</span> $dx <span style="color:#f92672">-</span>
                (<span style="color:#ae81ff">0</span> <span style="color:#f92672">-</span> $q[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">*</span> $dy;
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">if</span> $originside <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e"># On the line</span>
            <span style="color:#66d9ef">my</span> $cornerside <span style="color:#f92672">=</span> ($p[$i]<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> $q[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>]) <span style="color:#f92672">*</span> $dx <span style="color:#f92672">-</span>
                ($p[$i]<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">-</span> $q[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">*</span> $dy;
            $sameside<span style="color:#f92672">++</span> <span style="color:#66d9ef">unless</span> ($originside <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> xor $cornerside <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>);
        }
        <span style="color:#66d9ef">return</span> $sameside <span style="color:#f92672">==</span> <span style="color:#ae81ff">3</span> ? <span style="color:#ae81ff">1</span> : <span style="color:#ae81ff">0</span>;
    }
</code></pre></div><p><strong>W. Luis Mochan</strong></p>
<p>Another version by Luis, with added commentary in the output as to how the conclusion was made.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">cross</span> {
        <span style="color:#66d9ef">my</span> ($A, $B)<span style="color:#f92672">=</span>@_;
        <span style="color:#66d9ef">return</span> $A<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">*</span>$B<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">-</span>$A<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">*</span>$B<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>];
    }

    <span style="color:#66d9ef">my</span> ( $A, $B, $C ) <span style="color:#f92672">=</span> pairs @ARGV;
    <span style="color:#66d9ef">my</span> ( $AB, $BC, $CA ) <span style="color:#f92672">=</span> ( cross( $A, $B ), cross( $B, $C ), cross( $C, $A ) );
    <span style="color:#66d9ef">my</span> $clockwise <span style="color:#f92672">=</span> all { $_ <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> } ( $AB, $BC, $CA );
    <span style="color:#66d9ef">my</span> $counterclockwise <span style="color:#f92672">=</span> all { $_ <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span> } ( $AB, $BC, $CA );
    <span style="color:#66d9ef">my</span> $result <span style="color:#f92672">=</span> ( $clockwise<span style="color:#f92672">||</span>$counterclockwise )?<span style="color:#ae81ff">1</span>:<span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">my</span> $edge <span style="color:#f92672">=</span> any { $_ <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> } ( $AB, $BC, $CA );

    say <span style="color:#e6db74">&#34;Input: &#34;</span>, join <span style="color:#e6db74">&#34; &#34;</span>, map {<span style="color:#e6db74">&#34;($_-&gt;[0],$_-&gt;[1])&#34;</span>} ($A, $B, $C);
    say <span style="color:#e6db74">&#34;Output: $result&#34;</span>;
    say <span style="color:#e6db74">&#34;Since (0,0) is within the triangle&#34;</span>     <span style="color:#66d9ef">if</span> $result <span style="color:#f92672">and</span> <span style="color:#f92672">!</span>$edge;
    say <span style="color:#e6db74">&#34;Since (0,0) is within an edge&#34;</span>          <span style="color:#66d9ef">if</span> $result <span style="color:#f92672">and</span> $edge;
    say <span style="color:#e6db74">&#34;Since (0,0) is not within the triangle&#34;</span> <span style="color:#66d9ef">unless</span> $result;
</code></pre></div><p><strong>Roger Bell_West</strong></p>
<p>After first copying the first point onto the end of his point array, Roger factors out the product equation and places it into a parameterized loop. He then no longer need worry about jumping from the third point to the first again, as the equation is solved for a virtual, ghost &ldquo;fourth&rdquo; point, the same as the first. This is a really nice touch.</p>
<p>For example, the first iteration of the loop ends up looking like:</p>
<pre><code>    x1 * (y2 - y1) - y1 * (x2 - x1)

</code></pre><p>which should by now look familiar.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">ot</span> {
      <span style="color:#66d9ef">my</span> @points<span style="color:#f92672">=</span>@_;
      $points[<span style="color:#ae81ff">3</span>]<span style="color:#f92672">=</span>$points[<span style="color:#ae81ff">0</span>];
      <span style="color:#66d9ef">my</span> @xp;
      <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $i (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">2</span>) {
        push @xp,($points[$i][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span>
                    ($points[$i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>]<span style="color:#f92672">-</span>$points[$i][<span style="color:#ae81ff">1</span>]))
          <span style="color:#f92672">-</span>
          ($points[$i][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span>
           ($points[$i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>]<span style="color:#f92672">-</span>$points[$i][<span style="color:#ae81ff">0</span>]));
      }
      @xp<span style="color:#f92672">=</span>sort @xp;
      <span style="color:#66d9ef">if</span> ($xp[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">&lt;=</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> $xp[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">&lt;=</span><span style="color:#ae81ff">0</span>) {
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
      }
      <span style="color:#66d9ef">if</span> ($xp[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> $xp[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span>) {
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
      }
      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
    }
</code></pre></div><h2 id="equal-triangle-area">equal TRIANGLE AREA</h2>
<p><strong>Bob Lied</strong>,
<strong>Dave Jacoby</strong>,
<strong>Duncan C. White</strong>,
<strong>E. Choroba</strong>, and
<strong>Stuart Little</strong></p>
<p>The second most popular method, and the easiest to intuit, is to make three new triangles each with two of the given points and the origin, and for each compute the area. If the areas of these three triangles, summed, equals that of the original triangle, then the origin is inside the triangle.</p>
<p>This can be visualized by imagining a triangle with a point contained within it, and drawing radial lines outward from that point to each of the vertices surrounding it. The  triangle will be trisected into three smaller triangles that will fill it completely.</p>
<p>The complementary case, when the point is outside, is a just little harder to visualize but easy to prove. If this is the case, then consider the point and the triangle in space. One edge will be closer to the point than the others. The two other edges, when we scribe our new lines, will produce two triangles with a common side. These two triangles, taken together, describe a quadrilateral that completely encloses the original triangle. There will always be some area outside the original triangle but within this new quadrilateral, so the area of the quadrilateral will always be larger than the original triangle. We are already larger than the original triangle; when we add the area of the final edge to the point the area only grows further.</p>
<p>There were a variety of techniques offered to obtain the area of a triangle from its vertex points alone.</p>
<p><strong>Arne Sommer</strong></p>
<p>Arne presents a very nice writeup on his <a href="https://raku-musings.com/packed-origin.html">blog</a> which provides some rather nice visual aides.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span> ($x1, $y1, $x2, $y2, $x3, $y3, $x, $y) <span style="color:#f92672">=</span> @ARGV;

    $x <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">unless</span> defined $x;
    $y <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">unless</span> defined $y;

    <span style="color:#66d9ef">my</span> $ABC <span style="color:#f92672">=</span> area($x1, $y1, $x2, $y2, $x3, $y3);
    <span style="color:#66d9ef">my</span> $PBC <span style="color:#f92672">=</span> area($x,  $y,  $x2, $y2, $x3, $y3);
    <span style="color:#66d9ef">my</span> $PAC <span style="color:#f92672">=</span> area($x1, $y1, $x,  $y,  $x3, $y3);
    <span style="color:#66d9ef">my</span> $PAB <span style="color:#f92672">=</span> area($x1, $y1, $x2, $y2, $x,  $y);

    ($ABC <span style="color:#f92672">==</span> $PBC <span style="color:#f92672">+</span> $PAC <span style="color:#f92672">+</span> $PAB) ? say <span style="color:#ae81ff">1</span> : say <span style="color:#ae81ff">0</span>;

    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">area</span>($x1, $y1, $x2, $y2, $x3, $y3)
    {
      <span style="color:#66d9ef">return</span> abs( ($x1 <span style="color:#f92672">*</span> ($y2 <span style="color:#f92672">-</span> $y3) <span style="color:#f92672">+</span> $x2 <span style="color:#f92672">*</span> ($y3 <span style="color:#f92672">-</span> $y1) <span style="color:#f92672">+</span> $x3 <span style="color:#f92672">*</span> ($y1 <span style="color:#f92672">-</span> $y2) ) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>);
    }
</code></pre></div><p><strong>Stuart Little</strong></p>
<p>Stuart uses a slightly different area calculation&hellip;</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">areaTr2</span>($x1,$y1,$x2,$y2,$x3,$y3) {
        abs(($y3<span style="color:#f92672">-</span>$y1)<span style="color:#f92672">*</span>($x2<span style="color:#f92672">-</span>$x1) <span style="color:#f92672">-</span> ($y2<span style="color:#f92672">-</span>$y1)<span style="color:#f92672">*</span>($x3<span style="color:#f92672">-</span>$x1))
    }

    <span style="color:#66d9ef">my</span> ($x1,$y1,$x2,$y2,$x3,$y3) <span style="color:#f92672">=</span> @ARGV[<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">5</span>];

    say <span style="color:#ae81ff">0</span><span style="color:#f92672">+</span>(areaTr2(<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,$x1,$y1,$x2,$y2) <span style="color:#f92672">+</span> areaTr2(<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,$x2,$y2,$x3,$y3) <span style="color:#f92672">+</span> areaTr2(<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,$x3,$y3,$x1,$y1) <span style="color:#f92672">==</span> areaTr2($x1,$y1,$x2,$y2,$x3,$y3));
</code></pre></div><p><strong>E. Choroba</strong></p>
<p>&hellip;which surfaces again in Choroba&rsquo;s example.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">area</span> {
        <span style="color:#66d9ef">my</span> ($A, $B, $C) <span style="color:#f92672">=</span> @_;
        <span style="color:#66d9ef">return</span> abs((  $B<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">-</span> $A<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">*</span> ($C<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> $A<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>])
                   <span style="color:#f92672">-</span> ($C<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">-</span> $A<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">*</span> ($B<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> $A<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>])) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>
    }

    <span style="color:#66d9ef">my</span> $Z <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>];
    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">origin_containing_trianlge</span> {
        <span style="color:#66d9ef">my</span> ($A, $B, $C) <span style="color:#f92672">=</span> @_;

        <span style="color:#66d9ef">my</span> $whole <span style="color:#f92672">=</span> area($A, $B, $C);
        <span style="color:#66d9ef">my</span> ($a1) <span style="color:#f92672">=</span> area($A, $B, $Z);
        <span style="color:#66d9ef">my</span> ($a2) <span style="color:#f92672">=</span> area($B, $C, $Z);
        <span style="color:#66d9ef">my</span> ($a3) <span style="color:#f92672">=</span> area($A, $C, $Z);
        <span style="color:#66d9ef">my</span> $sum <span style="color:#f92672">=</span> $a1 <span style="color:#f92672">+</span> $a2 <span style="color:#f92672">+</span> $a3;

        <span style="color:#66d9ef">return</span> abs($sum <span style="color:#f92672">-</span> $whole) <span style="color:#f92672">&lt;</span> THRESHOLD ? <span style="color:#ae81ff">1</span> : <span style="color:#ae81ff">0</span>
    }
</code></pre></div><p><strong>Dave Jacoby</strong></p>
<p>Dave <a href="https://github.polettix.it/ETOOBUSY/2020/10/01/area-of-triangle/">borrows his area coding from Flavio Poletti</a>, who isn&rsquo;t represented this week. So this becomes a way to acknowledge both efforts. In addition, he adds a rather bonkers routine to graph the results, which is pretty. This pleases me.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">find_area</span> ( $A, $B, $C ) {
        <span style="color:#66d9ef">my</span> ( $v_x, $v_y ) <span style="color:#f92672">=</span> map { $B<span style="color:#f92672">-&gt;</span>[$_] <span style="color:#f92672">-</span> $A<span style="color:#f92672">-&gt;</span>[$_] } <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">my</span> ( $w_x, $w_y ) <span style="color:#f92672">=</span> map { $C<span style="color:#f92672">-&gt;</span>[$_] <span style="color:#f92672">-</span> $A<span style="color:#f92672">-&gt;</span>[$_] } <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">my</span> $vv <span style="color:#f92672">=</span> $v_x <span style="color:#f92672">*</span> $v_x <span style="color:#f92672">+</span> $v_y <span style="color:#f92672">*</span> $v_y;
        <span style="color:#66d9ef">my</span> $ww <span style="color:#f92672">=</span> $w_x <span style="color:#f92672">*</span> $w_x <span style="color:#f92672">+</span> $w_y <span style="color:#f92672">*</span> $w_y;
        <span style="color:#66d9ef">my</span> $vw <span style="color:#f92672">=</span> $v_x <span style="color:#f92672">*</span> $w_x <span style="color:#f92672">+</span> $v_y <span style="color:#f92672">*</span> $w_y;
        <span style="color:#66d9ef">return</span> sqrt( $vv <span style="color:#f92672">*</span> $ww <span style="color:#f92672">-</span> $vw <span style="color:#f92672">*</span> $vw ) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
    }

    <span style="color:#75715e"># this is thrown in as a bonus: showing the graph with the origin</span>
    <span style="color:#75715e"># represented as * and the points shown as +</span>

    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">map_points</span>( $list ) {
        <span style="color:#66d9ef">my</span> %points;
        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $p ( $list<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span> ) { $points{ $p<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] }{ $p<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>] } <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; }
        <span style="color:#66d9ef">my</span> @x <span style="color:#f92672">=</span> map { $_<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] } $list<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>
        my @y <span style="color:#f92672">=</span> map { $_<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>] } $list<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>
        my $minx <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> min <span style="color:#ae81ff">0</span>, @x;
        <span style="color:#66d9ef">my</span> $miny <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> min <span style="color:#ae81ff">0</span>, @y;
        <span style="color:#66d9ef">my</span> $maxx <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> max <span style="color:#ae81ff">0</span>,  @x;
        <span style="color:#66d9ef">my</span> $maxy <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> max <span style="color:#ae81ff">0</span>,  @y;
        say <span style="color:#e6db74">&#39;&#39;</span>;

        say join <span style="color:#e6db74">&#39; &#39;</span>, <span style="color:#e6db74">&#39;+&#39;</span>, ( map { <span style="color:#e6db74">&#39;-&#39;</span> } $minx <span style="color:#f92672">..</span> $maxx ), <span style="color:#e6db74">&#39;+&#39;</span>;

        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $y ( reverse $miny <span style="color:#f92672">..</span> $maxy ) {
            <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#39;| &#39;</span>;
            <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $x ( $minx <span style="color:#f92672">..</span> $maxx ) {
                <span style="color:#66d9ef">if</span> ( defined $points{$x}{$y} ) { <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#39;+&#39;</span> }
                <span style="color:#66d9ef">elsif</span> ( $x <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> $y <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> ) { <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#39;*&#39;</span> }
                <span style="color:#66d9ef">elsif</span> ( $x <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> ) { <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#39;|&#39;</span> }
                <span style="color:#66d9ef">elsif</span> ( $y <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> ) { <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#39;-&#39;</span> }
                <span style="color:#66d9ef">else</span>              { <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#39; &#39;</span> }
                <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#39; &#39;</span>;
            }
            say <span style="color:#e6db74">&#39;|&#39;</span>;
        }
        say join <span style="color:#e6db74">&#39; &#39;</span>, <span style="color:#e6db74">&#39;+&#39;</span>, ( map { <span style="color:#e6db74">&#39;-&#39;</span> } $minx <span style="color:#f92672">..</span> $maxx ), <span style="color:#e6db74">&#39;+&#39;</span>;
        say <span style="color:#e6db74">&#39;&#39;</span>;
    }
</code></pre></div><pre><code>    0,1  1,0  2,2
    0 : 0

    + - - - - - +
    |   |       |
    |   |   +   |
    |   +       |
    | - * + - - |
    |   |       |
    + - - - - - +

    1,1  -1,1  0,-3
    1 : 1

    + - - - - - +
    |     |     |
    |   + | +   |
    | - - * - - |
    |     |     |
    |     |     |
    |     +     |
    |     |     |
    + - - - - - +


    1,2  4,3  3,4
    0 : 0

    + - - - - - - - +
    |   |           |
    |   |     +     |
    |   |       +   |
    |   | +         |
    |   |           |
    | - * - - - - - |
    |   |           |
    + - - - - - - - +

</code></pre><h2 id="using-barycentric-coordinates">using BARYCENTRIC COORDINATES</h2>
<p><strong>Simon Green</strong>, and
<strong>Wanderdoc</strong></p>
<p>The trianglar area method, described above, is the perfect lead-in introduction to what is known as <a href="https://en.wikipedia.org/wiki/Barycentric_coordinate_system#Barycentric_coordinates_on_triangles">barycentric coordinates</a>. In this coordinate system, a point can be described by the <em>ratios</em> of the areas of the smaller triangles created by scribing from that point to the three vertices. Kind of exactly what we just did. Considered as ratios to the whole, the three areas become unitless fractions that sum to 1.</p>
<p>Linear algebra can be used to convert the point, in this case the origin, to barycentric coordinates in reference to the triangle, and then, if and only if all three coordinates fall, inclusively, between 0 and 1, the point is inside the triangle.</p>
<p>The simple case for this, when the point lies inside, is directly analogous to the three smaller triangles described in the previous section, where the three areas sum to the larger. Each sub-triangle can be seen to have some fractional component of the area of the whole, say one half or two-fifths or such, that when summed with the others will yield 1, the whole area.</p>
<p>Here are three versions of the math using barycentric coordinates:</p>
<p><strong>Simon Green</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">main</span> {
        <span style="color:#66d9ef">my</span> ($x1, $y1, $x2, $y2, $x3, $y3) <span style="color:#f92672">=</span> ( join( <span style="color:#e6db74">&#39; &#39;</span>, @_ ) <span style="color:#f92672">=~</span><span style="color:#e6db74"> /(-?\d+)/g</span> );

        <span style="color:#66d9ef">my</span> $x <span style="color:#f92672">=</span> <span style="color:#66d9ef">my</span> $y <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">my</span> $a <span style="color:#f92672">=</span> (($y2 <span style="color:#f92672">-</span> $y3)<span style="color:#f92672">*</span>($x <span style="color:#f92672">-</span> $x3) <span style="color:#f92672">+</span> ($x3 <span style="color:#f92672">-</span> $x2)<span style="color:#f92672">*</span>($y <span style="color:#f92672">-</span> $y3)) <span style="color:#f92672">/</span> (($y2 <span style="color:#f92672">-</span> $y3)<span style="color:#f92672">*</span>($x1 <span style="color:#f92672">-</span> $x3) <span style="color:#f92672">+</span> ($x3 <span style="color:#f92672">-</span> $x2)<span style="color:#f92672">*</span>($y1 <span style="color:#f92672">-</span> $y3));
        <span style="color:#66d9ef">my</span> $b <span style="color:#f92672">=</span> (($y3 <span style="color:#f92672">-</span> $y1)<span style="color:#f92672">*</span>($x <span style="color:#f92672">-</span> $x3) <span style="color:#f92672">+</span> ($x1 <span style="color:#f92672">-</span> $x3)<span style="color:#f92672">*</span>($y <span style="color:#f92672">-</span> $y3)) <span style="color:#f92672">/</span> (($y2 <span style="color:#f92672">-</span> $y3)<span style="color:#f92672">*</span>($x1 <span style="color:#f92672">-</span> $x3) <span style="color:#f92672">+</span> ($x3 <span style="color:#f92672">-</span> $x2)<span style="color:#f92672">*</span>($y1 <span style="color:#f92672">-</span> $y3));
        <span style="color:#66d9ef">my</span> $c <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> $a <span style="color:#f92672">-</span> $b;

        <span style="color:#66d9ef">my</span> $contained <span style="color:#f92672">=</span> ($a <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> $a <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">and</span> $b <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> $b <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">and</span> $c <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> $c <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>) ? <span style="color:#ae81ff">1</span>: <span style="color:#ae81ff">0</span>;
        say $contained;
    }
</code></pre></div><p><strong>Athanasius</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">point_in_triangle</span>
    {
        <span style="color:#66d9ef">my</span> ($A, $B, $C) <span style="color:#f92672">=</span> @_;

        <span style="color:#66d9ef">my</span>  $den <span style="color:#f92672">=</span>  ($B<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> $C<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>]) <span style="color:#f92672">*</span> ($A<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">-</span> $C<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">+</span>
                    ($C<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">-</span> $B<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">*</span> ($A<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> $C<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>]);

        <span style="color:#66d9ef">my</span>  $x   <span style="color:#f92672">=</span> (($B<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> $C<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>]) <span style="color:#f92672">*</span> <span style="color:#f92672">-</span>$C<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>]  <span style="color:#f92672">+</span>
                    ($C<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">-</span> $B<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">*</span> <span style="color:#f92672">-</span>$C<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>]) <span style="color:#f92672">/</span> $den;

        <span style="color:#66d9ef">my</span>  $y   <span style="color:#f92672">=</span> (($C<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> $A<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>]) <span style="color:#f92672">*</span> <span style="color:#f92672">-</span>$C<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>]  <span style="color:#f92672">+</span>
                    ($A<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">-</span> $C<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">*</span> <span style="color:#f92672">-</span>$C<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>]) <span style="color:#f92672">/</span> $den;

        <span style="color:#66d9ef">my</span>  $z   <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> $x <span style="color:#f92672">-</span> $y;

        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&lt;=</span> $x <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span>
               <span style="color:#ae81ff">0</span> <span style="color:#f92672">&lt;=</span> $y <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span>
               <span style="color:#ae81ff">0</span> <span style="color:#f92672">&lt;=</span> $z <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>;
    }
</code></pre></div><p><strong>Gustavo Chaves</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span> ($x1, $y1, $x2, $y2, $x3, $y3) <span style="color:#f92672">=</span> @ARGV;
    <span style="color:#75715e">#my ($x1, $y1, $x2, $y2, $x3, $y3, $x, $y) = (0, 1, 1, 0, 2, 2);</span>
    <span style="color:#75715e">#my ($x1, $y1, $x2, $y2, $x3, $y3, $x, $y) = (1, 1, -1, 1, 0, -3);</span>
    <span style="color:#75715e">#my ($x1, $y1, $x2, $y2, $x3, $y3, $x, $y) = (0, 1, 2, 0, -6, 0);</span>

    <span style="color:#75715e"># Shamelessly copying from http://totologic.blogspot.com/2014/01/accurate-point-in-triangle-test.html</span>

    <span style="color:#66d9ef">my</span> $denominator <span style="color:#f92672">=</span> ($y2 <span style="color:#f92672">-</span> $y3)<span style="color:#f92672">*</span>($x1 <span style="color:#f92672">-</span> $x3) <span style="color:#f92672">+</span> ($x3 <span style="color:#f92672">-</span> $x2)<span style="color:#f92672">*</span>($y1 <span style="color:#f92672">-</span> $y3);
    <span style="color:#66d9ef">my</span> $A <span style="color:#f92672">=</span> (($y2 <span style="color:#f92672">-</span> $y3)<span style="color:#f92672">*</span>(<span style="color:#ae81ff">0</span> <span style="color:#f92672">-</span> $x3) <span style="color:#f92672">+</span> ($x3 <span style="color:#f92672">-</span> $x2)<span style="color:#f92672">*</span>(<span style="color:#ae81ff">0</span> <span style="color:#f92672">-</span> $y3)) <span style="color:#f92672">/</span> $denominator;
    <span style="color:#66d9ef">my</span> $B <span style="color:#f92672">=</span> (($y3 <span style="color:#f92672">-</span> $y1)<span style="color:#f92672">*</span>(<span style="color:#ae81ff">0</span> <span style="color:#f92672">-</span> $x3) <span style="color:#f92672">+</span> ($x1 <span style="color:#f92672">-</span> $x3)<span style="color:#f92672">*</span>(<span style="color:#ae81ff">0</span> <span style="color:#f92672">-</span> $y3)) <span style="color:#f92672">/</span> $denominator;
    <span style="color:#66d9ef">my</span> $C <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> $A <span style="color:#f92672">-</span> $B;

    say <span style="color:#ae81ff">0</span> <span style="color:#f92672">&lt;=</span> $A <span style="color:#f92672">&amp;&amp;</span> $A <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&lt;=</span> $B <span style="color:#f92672">&amp;&amp;</span> $B <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&lt;=</span> $C <span style="color:#f92672">&amp;&amp;</span> $C <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span> ? <span style="color:#ae81ff">1</span> : <span style="color:#ae81ff">0</span>;
</code></pre></div><h2 id="calculating-the-winding-number">calculating the WINDING NUMBER</h2>
<p><strong>James Smith</strong></p>
<p>Winding numbers are a convenient abstraction used in topology to describe a curve encircling a point. If we consider the three points of the triangle as a minimal degeneration of a curve then if the winding number is 1 or -1, a complete revolution has been made and the point lies within the triangle.</p>
<p>The mathematical techniques used to determine the winding number can get quite complicated, but with the point in question set to the origin, as we have done here, we can simply count crossing the horizontal axis.</p>
<p>Considering the edges of the triangle as connected directional vectors that describe a curve, we add 1 when we either cross the axis in an upwards direction in the positive quadrants or descend in the negative, and we subtract 1 for the opposite directions. If the resultant winding number is 0 the triangle does not enclose the origin.</p>
<p><strong>James Smith</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">winding_number</span> {
      <span style="color:#75715e">## Winding number is a generic way of working out whether a point lies</span>
      <span style="color:#75715e">## within a polygon - as this is not difficult we can implement the</span>
      <span style="color:#75715e">## trick for our triangle...</span>
      <span style="color:#75715e">## We have to work with edges - each edge in the code is represented</span>
      <span style="color:#75715e">## by ($a,$b) -&gt; ($x,$y)... We start from the edge which joins the</span>
      <span style="color:#75715e">## &#34;last&#34; node to the first and then we work our way around the circle</span>
      <span style="color:#75715e">## The winding number goes up or down depening on whether the edge</span>
      <span style="color:#75715e">## crosses the +ve axis (adding or subtracking 1 depending on the</span>
      <span style="color:#75715e">## direction) - this boils down to the algorithm below..</span>

      <span style="color:#66d9ef">my</span> ( $a, $b, $wn ) <span style="color:#f92672">=</span> @_[ <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> ], <span style="color:#ae81ff">0</span>;

      <span style="color:#66d9ef">while</span>( <span style="color:#66d9ef">my</span>($x,$y) <span style="color:#f92672">=</span> splice @_, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">2</span> ) {
        $wn <span style="color:#f92672">+=</span> $a<span style="color:#f92672">&lt;=</span><span style="color:#ae81ff">0</span> ? $y<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span>  <span style="color:#f92672">&amp;&amp;</span> $a<span style="color:#f92672">*</span>$y<span style="color:#f92672">-</span>$x<span style="color:#f92672">*</span>$b <span style="color:#f92672">&gt;</span>  <span style="color:#ae81ff">0</span> ?  <span style="color:#ae81ff">1</span> : <span style="color:#ae81ff">0</span>
                     : $y<span style="color:#f92672">&lt;=</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> $a<span style="color:#f92672">*</span>$y<span style="color:#f92672">-</span>$x<span style="color:#f92672">*</span>$b <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span> ? <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> : <span style="color:#ae81ff">0</span>;
        ($a,$b)<span style="color:#f92672">=</span>($x,$y);
      }
      <span style="color:#66d9ef">return</span> $wn%2;
    }

</code></pre></div><h2 id="summing-the-angles">summing the ANGLES</h2>
<p><strong>Niels van Dijke</strong></p>
<p>We can always sum the angles created by scribing lines to the three vertices of the triangles. Somewhat analogous to the equal area solution, if the sum of the angles subtended by the lines is equal to 360, then the point lies within the triangle.</p>
<p><strong>Niels van Dijke</strong></p>
<p>Niels brings in a math library, <code>Math::Trig</code>, importing a few functions <code>rad2deg</code> and <code>acos_real</code> to help him with the necessary calculations.</p>
<p>Given the origin and two points, subtending the angles is the tricky part. He does this for each pairing of the three points in the triangle and checks the sum. Here&rsquo;s the function he has crafted to perform the trigonometry:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">calcZAngle</span>($$$$) {
      <span style="color:#66d9ef">my</span> ($x1,$y1,$x2,$y2) <span style="color:#f92672">=</span> @_;

      <span style="color:#75715e"># Cosine rule:</span>
      <span style="color:#75715e">#   c^2 = a^2 + b^2 - 2ab cos(gamma)</span>
      <span style="color:#75715e">#   gamma = acos((a^2 + b^2 - c^2) / 2ab)</span>
      <span style="color:#66d9ef">my</span> $a <span style="color:#f92672">=</span> sqrt($x1<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> $y1<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span>);
      <span style="color:#66d9ef">my</span> $b <span style="color:#f92672">=</span> sqrt($x2<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> $y2<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span>);
      <span style="color:#66d9ef">my</span> $c <span style="color:#f92672">=</span> sqrt(($x2<span style="color:#f92672">-</span>$x1)<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> ($y2<span style="color:#f92672">-</span>$y1)<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span>);

      <span style="color:#66d9ef">return</span> rad2deg acos_real(($a<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> $b<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">-</span> $c<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span>)<span style="color:#f92672">/</span> (<span style="color:#ae81ff">2.0</span> <span style="color:#f92672">*</span> $a <span style="color:#f92672">*</span> $b));
    }
</code></pre></div><h2 id="the-power-of-the-pdl">the power of the PDL</h2>
<p><strong>Jorg Sommrey</strong></p>
<p>The Perl Data Language is very effective at munging matrices, and calculating the vector product can be effected using matrix determinants. In fact the equation used previously is that for finding that same matrix determinant.</p>
<p><strong>Jorg Sommrey</strong></p>
<p>As stated, the natural fit here is a variation on the vector product solution. Instead of plugging into an existing equation for each pair of points he can ask the PDL to do it for him with a simple function call. His submission is well annotated; it&rsquo;s always a joy to follow his methods.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">inner_origin</span> {
        <span style="color:#75715e"># Convert coordinate pairs to a nx2 piddle.</span>
        <span style="color:#66d9ef">my</span> $p <span style="color:#f92672">=</span> pdl(@_)<span style="color:#f92672">-&gt;</span>xchg(<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>)<span style="color:#f92672">-&gt;</span>sever;
        say <span style="color:#e6db74">&#34;coords:$p&#34;</span> <span style="color:#66d9ef">if</span> $verbose;

        <span style="color:#75715e"># Create a piddle holding the indices of the first coordinate of</span>
        <span style="color:#75715e"># all points.</span>
        <span style="color:#66d9ef">my</span> $indx <span style="color:#f92672">=</span> append sequence(indx, <span style="color:#ae81ff">1</span>, $p<span style="color:#f92672">-&gt;</span>dim(<span style="color:#ae81ff">0</span>)),
            zeroes(indx, <span style="color:#ae81ff">1</span>, $p<span style="color:#f92672">-&gt;</span>dim(<span style="color:#ae81ff">0</span>));

        <span style="color:#75715e"># Get the minimum and the maximum of the matrices&#39; determinants</span>
        <span style="color:#75715e"># formed by the point pairs.</span>
        <span style="color:#66d9ef">my</span> ($min_d, $max_d) <span style="color:#f92672">=</span> $p<span style="color:#f92672">-&gt;</span>range($indx, <span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#39;p&#39;</span>)
            <span style="color:#f92672">-&gt;</span>reorder(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">0</span>)<span style="color:#f92672">-&gt;</span>determinant<span style="color:#f92672">-&gt;</span>minmax;
        say <span style="color:#e6db74">&#34;min/max det: $min_d/$max_d&#34;</span> <span style="color:#66d9ef">if</span> $verbose;

        <span style="color:#75715e"># If determinants have different signs, the origin is outside the</span>
        <span style="color:#75715e"># polygon.</span>
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">if</span> $min_d <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> $max_d <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>;

        <span style="color:#75715e"># If there is at least one nonzero determinant and there are no</span>
        <span style="color:#75715e"># differing signs, the origin is located inside the polygon (or on</span>
        <span style="color:#75715e"># its border).</span>
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">if</span> $min_d <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> $max_d <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> $min_d <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> $max_d <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>;

        <span style="color:#75715e"># At this point all determinants are zero.</span>

        <span style="color:#75715e"># Get the projections onto the x and y axis for collinear points</span>
        <span style="color:#75715e"># and check if they both contain the origin.</span>
        <span style="color:#66d9ef">my</span> ($min_p, $max_p) <span style="color:#f92672">=</span> $p<span style="color:#f92672">-&gt;</span>minmaximum;
        say <span style="color:#e6db74">&#34;min/max proj: $min_p/$max_p&#34;</span> <span style="color:#66d9ef">if</span> $verbose;

        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">if</span> max($min_p) <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> min($max_p) <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>;

        <span style="color:#75715e"># Else: origin is not within the given line segment.</span>
        <span style="color:#ae81ff">0</span>;
    }
</code></pre></div><hr>
<h1 id="PWC101BLOGS">BLOGS</h1>
<hr>
<p><strong>That’s it for me this week, people! Warped by the rain, driven by the snow, resolute and unbroken by the torrential influx, I somehow continue to maintain my bearings. Looking forward to next wave, the perfect wave, I am: <em>your humble servant</em>.</strong></p>
<h1 id="PWC093BLOGS">But if Your <em>THIRST</em> for <em>KNOWLEDGE</em> is not <em>SLAKED</em>,</h1>
<h1 id="then-run-dont-walk-to-the-watering-hole">then <em>RUN</em> <em>(dont walk!)</em> to the <em>WATERING HOLE</em></h1>
<h1 id="and-read-these-blog-links">and <em>READ</em> these <em>BLOG</em> <em>LINKS</em>:</h1>
<p><strong>( <em>don&rsquo;t think, trust your training, you&rsquo;re in the zone, just do it &hellip;</em> )</strong></p>
<p><strong>Aaron Smith</strong></p>
<ul>
<li><a href="https://aaronreidsmith.github.io/blog/perl-weekly-challenge-101/">Perl Weekly Challenge 101 - Aaron Smith</a> ( <em>Raku</em> )</li>
</ul>
<p><strong>Abigail</strong></p>
<ul>
<li><a href="https://wp.me/pcxd30-r7">Perl Weekly Challenge 101: Pack a Spiral — Abigail&rsquo;s Programming Blog</a> ( <em>Perl</em> )</li>
<li><a href="https://wp.me/pcxd30-s8">Perl Weekly Challenge 101: Origin-containing Triangle — Abigail&rsquo;s Programming Blog</a> ( <em>Perl</em> )</li>
</ul>
<p><strong>Arne Sommer</strong></p>
<ul>
<li><a href="https://raku-musings.com/packed-origin.html">Packed Origin with Raku (and Perl)</a> ( <em>Perl &amp; Raku</em> )</li>
</ul>
<p><strong>Dave Jacoby</strong></p>
<ul>
<li><a href="https://jacoby.github.io/2021/02/23/spirals-and-triangles-perl-weekly-challenge-101.html">Spirals and Triangles: Perl Weekly Challenge #101 | Committed to Memory</a> ( <em>Perl</em> )</li>
</ul>
<p><strong>Roger Bell_West</strong></p>
<ul>
<li><a href="https://blog.firedrake.org/archive/2021/02/Perl_Weekly_Challenge_101__Spiral_Origin.html">RogerBW&rsquo;s Blog: Perl Weekly Challenge 101: Spiral Origin</a> ( <em>Perl &amp; Raku</em> )</li>
</ul>
<p><strong>Simon Green</strong></p>
<ul>
<li><a href="https://dev.to/simongreennet/weekly-challenge-101-jeo">Weekly Challenge 101</a> ( <em>Perl</em> )</li>
</ul>
<p><strong>W. Luis Mochan</strong></p>
<ul>
<li><a href="https://wlmb.github.io/2021/02/22/PWC101/">Perl Weekly Challenge 101 – W. Luis Mochán</a> ( <em>Perl</em> )</li>
</ul>

                </div>
            </div>
        </div>
    </div>
</section>


<!-- Call To Action Section Start -->
<section id="call-to-action">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2 class="title wow fadeInDown" data-wow-delay=".3s" data-wow-duration="500ms">SO WHAT DO YOU THINK ?</h2>
                    <p class="wow fadeInDown" data-wow-delay=".5s" data-wow-duration="500ms">If you have any suggestions or ideas then please do share with us.</p>
                    <a href="/contact" class="btn btn-default btn-contact wow fadeInDown" data-wow-delay=".7s" data-wow-duration="500ms">Contact with me</a>
                </div>
            </div>

        </div>
    </div>
</section>
<!-- Call To Action Section End -->



<!-- Footer Section Start -->
<footer id="footer">
    <div class="container">
        <div class="row content-justify-between">
            <div class="col-md-8 col-12 text-center text-lg-left text-md-left">
                <p class="copyright">Copyright:
                    <span>
                        2019 - 2025
                    </span> The Weekly Challenge. Theme Design and Developed by
                    <a href="http://www.Themefisher.com" rel="noreferrer" rel="noreferrer" target="_blank">Themefisher</a>.
                </p>
            </div>
            <div class="col-md-4 col-12">
                <!-- Social Media -->
                <ul class="social text-center text-md-right text-lg-right">
                    <li>
                        <a href="https://twitter.com/PerlWChallenge" class="twitter" rel="noreferrer" target="_blank" title="Follow us">
                            <i class="ion-social-twitter"></i>
                        </a>
                    </li>
                    <li>
                        <a href="/rss.xml" class="rss" target="_blank" title="RSS Feed">
                            <i class="ion-social-rss"></i>
                        </a>
                    </li>
                </ul>
            </div>
        </div>
    </div>
</footer>
<!-- footer section end -->

<!-- jquery -->
<script src="https://theweeklychallenge.org/plugins/jquery/jquery.min.js"></script>
<!-- Form Validation -->
<script src="https://theweeklychallenge.org/plugins/form-validation/jquery.form.min.js"></script>
<script src="https://theweeklychallenge.org/plugins/form-validation/jquery.validate.min.js"></script>
<!-- slick slider -->
<script src="https://theweeklychallenge.org/plugins/slick/slick.min.js"></script>
<!-- bootstrap js -->
<script src="https://theweeklychallenge.org/plugins/bootstrap/bootstrap.min.js"></script>
<!-- chart js -->
<script src="https://theweeklychallenge.org/plugins/chart/highstock.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/drilldown.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/data.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/chart.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/pwc-challenge.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/gc-challenge.js"></script>
<!-- wow js -->
<script src="https://theweeklychallenge.org/plugins/wow-js/wow.min.js"></script>
<!-- slider js -->
<script src="https://theweeklychallenge.org/plugins/slider/slider.js"></script>
<!-- Fancybox -->
<script src="https://theweeklychallenge.org/plugins/facncybox/jquery.fancybox.js"></script>
<!-- template main js -->

<script src="https://theweeklychallenge.org/js/script.min.js"></script>
<!-- google analitycs -->

<script async src="https://www.googletagmanager.com/gtag/js?id=G-CJTPYM9SB8"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-CJTPYM9SB8');
</script>
</body>

</html>

