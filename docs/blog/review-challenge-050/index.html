<!DOCTYPE html>
<html class="no-js" lang="en-us">
<head>
    <!-- Basic Page Needs -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:title"       content="Ryan Thompson › Perl Weekly Review #050"/>
    <meta property="og:type"        content="website"/>
    <meta property="og:url"         content="https://theweeklychallenge.org/blog/review-challenge-050/"/>
    <meta property="og:image"       content="https://theweeklychallenge.org/images/about/about.jpg"/>
    <meta property="og:description" content="Ryan Thompson › Perl Weekly Review #050"/>
    <meta name="twitter:card"       content="summary" />
    <meta name="twitter:image"      content="https://theweeklychallenge.org/images/about/about.jpg"/>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <meta name="description" content="Ryan Thompson › Perl Weekly Review #050">
    <meta name="author" content="The Weekly Challenge Team">
    <meta name="generator" content="Hugo 0.67.0-DEV" />

    <link rel="me" href="https://fosstodon.org/@manwar">
    <link rel="canonical" href="https://theweeklychallenge.org/blog/review-challenge-050/" />

    <!-- Mobile Specific Metas -->
    <meta name="format-detection" content="telephone=no">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Ryan Thompson › Perl Weekly Review #050</title>
    <link rel="icon" href="https://theweeklychallenge.org/images/favicon.ico">

    
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css"/>

    <!-- Twitter Bootstrs CSS -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/bootstrap/bootstrap.min.css">
    <!-- Ionicons Fonts Css -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/ionicons/ionicons.min.css">
    <!-- animate css -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/animate-css/animate.css">
    <!-- Hero area slider css-->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/slider/slider.css">
    <!-- slick slider -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/slick/slick.css">
    <!-- Fancybox -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/facncybox/jquery.fancybox.css">
    <!-- hover -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/hover/hover-min.css">
    <!-- Google fonts -->
    <link href='https://fonts.googleapis.com/css?family=Source Code Pro' rel='stylesheet'>
    <!-- template main css file -->
    
    <link rel="stylesheet" href="https://theweeklychallenge.org/css/style.min.css" integrity="" media="screen">
    <link rel="stylesheet" href="https://theweeklychallenge.org/css/main.css">

    <style>
        #goTopButton {
            display: none;          
            position: fixed;        
            bottom: 20px;           
            right: 30px;            
            z-index: 99;            
            border: none;           
            outline: none;          
            background-color: red;  
            color: white;           
            cursor: pointer;        
            padding: 15px;          
            border-radius: 10px;    
            font-size: 18px;        
        }

        #goTopButton:hover {
              background-color: #555;
        }

        
        .toggle-links {
            margin: 15px 0;
            padding-left: 15px;
        }
        .toggle-links a {
            display: inline-flex;
            align-items: center;
            padding: 8px 16px;
            border-radius: 20px;
            background-color: #4285f4;
            color: white !important;
            text-decoration: none;
            font-weight: 500;
            transition: background-color 0.2s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .toggle-links a:hover {
            background-color: #3367d6;
        }
        .arrow-icon {
            margin-left: 8px;
            font-size: 1.1em;
        }

    </style>


</head>

<body>

<button onclick="goTop()" id="goTopButton" title="Go to top">Top</button>

<script>

    topButton = document.getElementById("goTopButton");

    
    window.onscroll = function() { scrollFunction() };

    function scrollFunction() {
        if (document.body.scrollTop > 40 || document.documentElement.scrollTop > 40) {
            topButton.style.display = "block";
        } else {
            topButton.style.display = "none";
        }
    }

    
    function goTop() {
        document.body.scrollTop = 0; 
        document.documentElement.scrollTop = 0; 
    }

    
    document.addEventListener('DOMContentLoaded', function() {
        const showMoreLink = document.querySelector('.show-more');
        const showLessLink = document.querySelector('.show-less');
        const hiddenLinks = document.querySelectorAll('.hidden-link');

        showMoreLink.addEventListener('click', function(e) {
            e.preventDefault();
            
            hiddenLinks.forEach(link  => {
                link.style.display = 'list-item';
            });
            showMoreLink.style.display = 'none';
            showLessLink.style.display = 'inline-flex';
        });

        showLessLink.addEventListener('click', function(e) {
            e.preventDefault();
            
            hiddenLinks.forEach(link  => {
                link.style.display = 'none';
            });
            showLessLink.style.display = 'none';
            showMoreLink.style.display = 'inline-flex';
        });
    });

</script>

<section class="top-bar animated-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-12">
                <nav class="navbar navbar-expand-lg navbar-light bg-light">
                    <a class="navbar-brand" href="https://theweeklychallenge.org/">
                        <img src="https://theweeklychallenge.org/images/logo.svg" alt="logo">
                    </a>

                    <button class="navbar-toggler d-lg-none"
                            type="button"
                            data-toggle="collapse"
                            data-target="#navigation"
                            aria-controls="navigation"
                            aria-expanded="false"
                            aria-label="Toggle navigation">
                        <span class="navbar-toggler-icon"></span>
                    </button>

                    <div class="navbar-collapse" id="navigation">
                        <ul class="navbar-nav ml-auto">
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/">Home</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/about">About</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/chart">Chart</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/champions">Champions</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/team">Team</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/challenges">Challenges</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/p5-reviews">Perl/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/p6-reviews">Raku/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/recaps">Recaps</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/blogs">Blogs</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/faq">FAQ</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/contact">Contact</a>
                            </li>
                            
                        </ul>
                    </div>
                </nav>
            </div>
        </div>
    </div>
</section>


<section class="global-page-header">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2>Ryan Thompson › Perl Weekly Review #050</h2>
                    <div class="portfolio-meta">
                        <span>Friday, Mar 20, 2020</span>|
                        <span> Tags:
                            perl
                        </span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

<section class="single-post">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                
                <div style="text-align: center" class="post-img">
                    <img class="img-fluid" alt="" src="https://theweeklychallenge.org/images/blog/p5-review-challenge-050.jpg">
                </div>
                
                <div style="text-align: justify" class="post-content">
                    <p>Continues from <a href="/blog/review-challenge-049/">previous week</a>.</p>
<p>Welcome to the Perl review for Week 050 of the Weekly Challenge! For a quick overview, go through the <a href="/blog/perl-weekly-challenge-050/">original tasks</a> and <a href="/blog/recap-challenge-050/">recap</a> of the weekly challenge.</p>
<h2 id="getting-in-touch">Getting in Touch</h2>
<p><a href="mailto:rjt@cpan.org"><img src="/images/blog/Email.svg" height="50" width="50"> Email</a> › Email me (Ryan) with any feedback about this review.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge"><img src="/images/blog/Github.svg" height="50" width="50"> GitHub</a> › Submit a pull request for any issues you may find with this page.</p>
<p><a href="https://twitter.com/perlwchallenge"><img src="/images/blog/Twitter.svg" height="50" width="50"> Twitter</a> › Join the discussion on Twitter!</p>
<p>We&rsquo;d greatly appreciate any feedback you&rsquo;d like to give.</p>
<h2 id="table-of-contents">Table of Contents</h2>
<h3 id="task-1task1"><a href="#task1">Task 1</a></h3>
<p>[ <a href="#alexander-karelas1">Alexander Karelas</a>  | <a href="#alicia-bielsa1">Alicia Bielsa</a>  | <a href="#andrezgz1">Andrezgz</a>  | <a href="#cheok-yin-fung1">Cheok-Yin Fung</a>  | <a href="#colin-crain1">Colin Crain</a>  | <a href="#dave-cross1">Dave Cross</a>  | <a href="#dave-jacoby1">Dave Jacoby</a>  | <a href="#duncan-c-white1">Duncan C. White</a>  | <a href="#e-choroba1">E. Choroba</a>  | <a href="#ianrifkin1">Ian Rifkin</a>  | <a href="#jaldhar-h-vyas1">Jaldhar H. Vyas</a>  | <a href="#javier-luque1">Javier Luque</a>  | <a href="#laurent-rosenfeld1">Laurent Rosenfeld</a>  | <a href="#mohammad-anwar1">Mohammad S Anwar</a>  | <a href="#phillip-harris1">Phillip Harris</a>  | <a href="#roger-bell-west1">Roger Bell West</a>  | <a href="#ruben-westerberg1">Ruben Westerberg</a>  | <a href="#ryan-thompson1">Ryan Thompson</a>  | <a href="#saiftynet1">Saif Ahmed</a>  | <a href="#sol-demuth1">Sol DeMuth</a>  | <a href="#southpawgeek1">Jen Guerra</a>  | <a href="#user-person1">User Person</a>  | <a href="#wanderdoc1">Wanderdoc</a>  | <a href="#yet-ebreo1">Yet Ebreo</a>  ]</p>
<h3 id="task-2task2"><a href="#task2">Task 2</a></h3>
<p>[ <a href="#alexander-karelas2">Alexander Karelas</a>  | <a href="#alicia-bielsa2">Alicia Bielsa</a>  | <a href="#andrezgz2">Andrezgz</a>  | <a href="#cheok-yin-fung2">Cheok-Yin Fung</a>  | <a href="#colin-crain2">Colin Crain</a>  | <a href="#cristian-heredia2">Cristina Heredia</a>  | <a href="#dave-cross2">Dave Cross</a>  | <a href="#dave-jacoby2">Dave Jacoby</a>  | <a href="#duncan-c-white2">Duncan C. White</a>  | <a href="#e-choroba2">E. Choroba</a>  | <a href="#ianrifkin2">Ian Rifkin</a>  | <a href="#jaldhar-h-vyas2">Jaldhar H. Vyas</a>  | <a href="#javier-luque2">Javier Luque</a>  | <a href="#laurent-rosenfeld2">Laurent Rosenfeld</a>  | <a href="#mohammad-anwar2">Mohammad S Anwar</a>  | <a href="#phillip-harris2">Phillip Harris</a>  | <a href="#roger-bell-west2">Roger Bell West</a>  | <a href="#ruben-westerberg2">Ruben Westerberg</a>  | <a href="#ryan-thompson2">Ryan Thompson</a>  | <a href="#saiftynet2">Saif Ahmed</a>  | <a href="#sol-demuth2">Sol DeMuth</a>  | <a href="#southpawgeek2">Jen Guerra</a>  | <a href="#ulrich-rieke2">Ulrich Rieke</a>  | <a href="#user-person2">User Person</a>  | <a href="#wanderdoc2">Wanderdoc</a>  | <a href="#yet-ebreo2">Yet Ebreo</a>  ]</p>
<h3 id="blogsblogs"><a href="#blogs">Blogs</a></h3>
<hr>
<hr>
<h1 id="task1">Task #1 - Merge Intervals</h1>
<p>Mohammad&rsquo;s description:</p>
<p><em>Write a script to merge the given intervals where ever possible.</em></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">[<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">7</span>], [<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">9</span>], [<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">12</span>], [<span style="color:#ae81ff">15</span>,<span style="color:#ae81ff">19</span>], [<span style="color:#ae81ff">18</span>,<span style="color:#ae81ff">22</span>]
</code></pre></div><p><em>The script should merge <code>[2, 7]</code> and <code>[3, 9]</code> together to return <code>[2, 9]</code>.</em></p>
<p><em>Similarly it should also merge <code>[15, 19]</code> and <code>[18, 22]</code> together to return <code>[15, 22]</code>.</em></p>
<p>The final result should be something like below:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">[<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">9</span>], [<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">12</span>], [<span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">22</span>]
</code></pre></div><hr>
<h2 id="solution-types">Solution types</h2>
<h3 id="brute-force">Brute force</h3>
<p>There is an O(n²) brute force method for this task, which involves checking every interval against every other interval. It&rsquo;s simple enough to implement, and fast enough for small lists of intervals.</p>
<p>There is a slight variation in these solutions, whereby some hackers only look at the intervals <em>following</em> the current interval, in the inner loop. This is indeed a little faster, but is still O(n²). The big-theta efficiency would be Θ(<a href="https://en.wikipedia.org/wiki/Triangular_number">T</a>(n)) = Θ(n(n+1)/2), which is still O(n²).</p>
<h3 id="sort-then-scan">Sort then scan</h3>
<p>By sorting the list of intervals by their first element, you can then merge the ranges linearly. For example, with <code>[2,7], [3,9]</code>, you need only see if the last element of the first interval is greater or equal to the first element of the second interval. Or, in this case, 7 &gt;= 3.</p>
<p>The <code>sort</code> itself is O(<em>n</em> log <em>n</em>), which dominates the complexity, so the linear merge doesn&rsquo;t even factor in to the big-O complexity.</p>
<h3 id="unroll">Unroll</h3>
<p>A third solution involves unrolling each interval into all the integers it contains. These integers can then be iterated over, and the merged intervals obtained whenever there is a gap in the overall sequence of integers. For example, <code>[2,7], [3,9], [10,12], [15,19], [18,22]</code> unrolls into <code>2 3 4 5 6 7 8 9 10 11 12 15 16 17 18 19 20 21 22</code>. Scanning through that array, it is simple to find the discontinuity and return <code>[2,12], [15,22]</code>.</p>
<p>It is important to note that this method cannot distinguish adjacent intervals, meaning <code>[3,9], [10,12]</code> will be merged to <code>[3,12]</code>, whereas the first two methods can keep those intervals separate. The problem description seems to indicate that these intervals should, in fact, be separated.</p>
<h3 id="which-one-is-faster">Which one is faster?</h3>
<p>For those playing along at home, the (theoretical) point at which the <code>sort</code> method is faster than the brute force method is where <em>n</em>² = 2<em>n</em> log <em>n</em>.  (Here I&rsquo;ve added the extra <em>n</em> term, because we want to compare the true coefficients.)</p>
<p>That simplifies to <em>n</em> = 2 log <em>n</em>, but either way, there is no crossover point; the 2<em>n</em> log <em>n</em> algorithm is always faster, at least in theory. In practice, constant factors can easily push things in favour of &ldquo;worse&rdquo; algorithms for small numbers. We say &ldquo;sufficiently large&rdquo; for good reason, after all.</p>
<p>The third (unroll) method scales on a completely different variable: it scales on either the <em>total</em> range of all the intervals, or (with some optimization) on the sum of the ranges of each interval.</p>
<hr>
<h2 id="alexander-karelas1">Alexander Karelas</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/alexander-karelas/perl/ch-1.pl">Alexander Karelas&rsquo;s solution</a> uses the <code>sort</code>-scan method:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">use</span> Data::Dumper;
<span style="color:#66d9ef">my</span> @intervals <span style="color:#f92672">=</span> ([<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">7</span>], [<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">9</span>], [<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">12</span>], [<span style="color:#ae81ff">15</span>,<span style="color:#ae81ff">19</span>], [<span style="color:#ae81ff">18</span>,<span style="color:#ae81ff">22</span>]);
<span style="color:#75715e"># solution</span>
@intervals <span style="color:#f92672">=</span> sort {$a<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] <span style="color:#e6db74">&lt;=&gt;</span> $b<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>]} @intervals;
<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">my</span> $i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; $i <span style="color:#f92672">&lt;</span> $#intervals; $i<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">if</span> ($intervals[$i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;=</span> $intervals[$i][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">and</span> $intervals[$i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&gt;</span> $intervals[$i][<span style="color:#ae81ff">1</span>]) {
        $intervals[$i][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> $intervals[$i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>];
        splice @intervals, $i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>;
    }
}
<span style="color:#66d9ef">print</span> Dumper(<span style="color:#f92672">\</span>@intervals);
</code></pre></div><p>Using <code>Data::Dumper</code> to print out the results is a good time-saver.</p>
<h2 id="alicia-bielsa1">Alicia Bielsa</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/alicia-bielsa/perl/ch-1.pl">Alicia Bielsa</a> took a modular design with her code, with subroutines as follows:</p>
<ul>
<li><code>checkIntervals</code> › The top-level subroutine, responsible for scanning through the intervals, checking for overlap, and merging those that do overlap.</li>
<li><code>doIntervalsOverlap</code>› Takes two intervals, and returns 1 <em>iff</em> they overlap</li>
<li><code>mergeIntervals</code> › Takes two intervals, and merges the second into the first.</li>
</ul>
<p>These subroutines implement an interesting recursive algorithm. The last two are straightforward, so here is <code>checkIntervals</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">checkIntervals</span> {
    <span style="color:#66d9ef">my</span> @aIntervals <span style="color:#f92672">=</span> @_;
    <span style="color:#66d9ef">my</span> @aMergedIntervals <span style="color:#f92672">=</span> ();
    <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $interval ( @aIntervals){
        <span style="color:#66d9ef">unless</span>(scalar @aMergedIntervals){
            push (@aMergedIntervals, $interval);
            <span style="color:#66d9ef">next</span>;
        }
        <span style="color:#66d9ef">my</span> $isMerged <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $mergedInterval (@aMergedIntervals){
            <span style="color:#66d9ef">my</span> $flagMerge <span style="color:#f92672">=</span> doIntervalsOverlap($interval, $mergedInterval );
            <span style="color:#66d9ef">if</span> ($flagMerge){
                mergeIntervals($interval, $mergedInterval);
                $isMerged <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
            }
        }
        <span style="color:#66d9ef">unless</span>  ($isMerged)  {
             push (@aMergedIntervals, $interval);
        }
    }
    <span style="color:#66d9ef">if</span> (scalar(@aMergedIntervals) <span style="color:#f92672">!=</span> scalar(@aIntervals)){
         checkIntervals(@aMergedIntervals);
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#66d9ef">return</span> @aMergedIntervals;
    }
}
</code></pre></div><p>Alicia&rsquo;s code attempts to merge all adjacent intervals, and then the recursion step essentially turns it into a <a href="https://www.youtube.com/watch?v=9jWGbvemTag">multi-pass</a> implementation. This means that <code>checkIntervals</code> does not require sorted inputs.</p>
<p>Efficiency-wise, this saves an O(<em>n</em> log <em>n</em>) sort, but might potentially scan <a href="https://en.wikipedia.org/wiki/Triangular_number">T</a>(n) = n(n+1)/2 intervals, which is back to O(n²) time. However, the average case is still much better than the brute force O(n²) algorithm, and the best case (already sorted input) is linear. I like this approach a lot.</p>
<h2 id="andrezgz1">Andrezgz</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/andrezgz/perl/ch-1.pl">Andrezgz&rsquo;s solution</a> accepts (and returns) lists of intervals in string form. The algorithm parses the input string, and puts all intervals into an <code>%output</code> hash, keyed on the lower (<code>$from</code>) number:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">merge</span> {
    <span style="color:#66d9ef">my</span> $intervals <span style="color:#f92672">=</span> shift;
    $intervals <span style="color:#f92672">=~</span> <span style="color:#e6db74">s/\s+//</span>; <span style="color:#75715e">#remove unnecessary spaces</span>
    <span style="color:#66d9ef">my</span> %output;
    <span style="color:#66d9ef">foreach</span> ( split <span style="color:#e6db74">/\Q],[\E/</span>, $intervals ){
        <span style="color:#66d9ef">next</span> <span style="color:#66d9ef">unless</span> (<span style="color:#e6db74">/(-?\d+),(-?\d+)/</span>);
        <span style="color:#66d9ef">my</span> ($from,$to) <span style="color:#f92672">=</span> ($1,$2);
        $output{$from} <span style="color:#f92672">=</span> $to <span style="color:#66d9ef">unless</span> exists $output{$from} <span style="color:#f92672">&amp;&amp;</span> $output{$from} <span style="color:#f92672">&gt;=</span> $to;
    }
</code></pre></div><p>Note that some intervals are already merged at this stage. If their <code>$from</code> numbers match, the one with the lower <code>$to</code> number is discarded. Most of the merging is yet to come, though:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#75715e"># merge overlapping intervals</span>
    <span style="color:#66d9ef">my</span> $prev;
    <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $k (sort {$a <span style="color:#e6db74">&lt;=&gt;</span> $b} keys %output){
        <span style="color:#66d9ef">if</span> (defined $prev <span style="color:#f92672">&amp;&amp;</span> $output{$prev} <span style="color:#f92672">&gt;=</span> $k) {
            $output{$prev} <span style="color:#f92672">=</span> $output{$k} <span style="color:#66d9ef">if</span> $output{$k} <span style="color:#f92672">&gt;</span> $output{$prev};
            delete $output{$k};
        }
        <span style="color:#66d9ef">else</span> {
            $prev <span style="color:#f92672">=</span> $k;
        }
    }
    <span style="color:#66d9ef">return</span> join <span style="color:#e6db74">&#39;,&#39;</span>, map { <span style="color:#e6db74">qq|[$_,$output{$_}]|</span> }
                     sort {$a <span style="color:#e6db74">&lt;=&gt;</span> $b}
                     keys %output;
}
</code></pre></div><p>The <code>%output</code> keys are sorted numerically, effectively sorting the intervals, and then the intervals are merged in place. Finally, the output is returned in string form.</p>
<h2 id="cheok-yin-fung1">Cheok-Yin Fung</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/cheok-yin-fung/perl/ch-1.pl">Cheok-Yin Fung&rsquo;s solution</a> is recursive, and uses a number of data structures:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> @L <span style="color:#f92672">=</span> (<span style="color:#ae81ff">0</span>) x <span style="color:#ae81ff">100</span>;
$L[<span style="color:#ae81ff">100</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
$L[<span style="color:#ae81ff">101</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
<span style="color:#66d9ef">my</span> %interval;     <span style="color:#75715e"># key: the head of the interval; value: the tail of the interval</span>
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">newroute</span> {
    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i ($_[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">..</span>$_[<span style="color:#ae81ff">1</span>]) {$L[$i]<span style="color:#f92672">++</span>;}
    $interval{$_[<span style="color:#ae81ff">0</span>]}<span style="color:#f92672">=</span>$_[<span style="color:#ae81ff">1</span>];
}
newroute(<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">7</span>);
newroute(<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">9</span>);
newroute(<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">12</span>);
newroute(<span style="color:#ae81ff">15</span>,<span style="color:#ae81ff">19</span>);
newroute(<span style="color:#ae81ff">18</span>,<span style="color:#ae81ff">22</span>);
newroute(<span style="color:#ae81ff">100</span>,<span style="color:#ae81ff">100</span>); <span style="color:#75715e"># a temporary arrangement</span>
<span style="color:#66d9ef">my</span> @trainstation <span style="color:#f92672">=</span> sort {$a <span style="color:#e6db74">&lt;=&gt;</span> $b} keys %interval;
<span style="color:#66d9ef">my</span> %finterval;  <span style="color:#75715e"># key: the head of the interval; value: the tail of the interval</span>
<span style="color:#66d9ef">my</span> $stationnum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</code></pre></div><p>The <code>newroute</code> sub sets up each interval in the <code>@L</code> array and <code>%interval</code> hash.</p>
<p>The <code>seektermination</code> sub recursively scans through <code>@L</code> and skips to the next interval.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">seektermination</span> {
    <span style="color:#66d9ef">my</span> $i <span style="color:#f92672">=</span> $_[<span style="color:#ae81ff">0</span>];
    <span style="color:#66d9ef">my</span> $nextstop <span style="color:#f92672">=</span> $_[<span style="color:#ae81ff">1</span>];
    <span style="color:#66d9ef">while</span> ($L[$i] <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> $i <span style="color:#f92672">&lt;</span> $nextstop) {
        $i<span style="color:#f92672">++</span>;
    }
    <span style="color:#66d9ef">if</span> ($L[$i] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> $i<span style="color:#f92672">&lt;</span>$nextstop) {
        <span style="color:#66d9ef">return</span> $i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    }
    <span style="color:#66d9ef">if</span> ($L[$i]<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">1</span>) {
        $stationnum<span style="color:#f92672">++</span>;
        <span style="color:#66d9ef">return</span> seektermination($_[<span style="color:#ae81ff">0</span>], $trainstation[$stationnum<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]);
    }
    <span style="color:#66d9ef">if</span> ($i<span style="color:#f92672">==</span>$nextstop <span style="color:#f92672">and</span> $L[$i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">and</span> $L[$i]<span style="color:#f92672">==</span><span style="color:#ae81ff">1</span>) {
        <span style="color:#66d9ef">return</span> $i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    }
}
</code></pre></div><p>Finally, the calling and cleanup code does some of the work itself:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">while</span> ($stationnum<span style="color:#f92672">&lt;=</span>$#trainstation<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
    <span style="color:#66d9ef">my</span> $start <span style="color:#f92672">=</span> $trainstation[$stationnum];
    $finterval{$start} <span style="color:#f92672">=</span> seektermination($start, $trainstation[$stationnum<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]);
    $stationnum<span style="color:#f92672">++</span>;
}
delete $finterval{<span style="color:#ae81ff">100</span>}; <span style="color:#75715e">#goodbye to the temporary arrangement</span>
<span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $s (sort {$a <span style="color:#e6db74">&lt;=&gt;</span> $b} keys %finterval) {
    <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;[&#34;</span>, $s, <span style="color:#e6db74">&#34;, &#34;</span>, $finterval{$s}, <span style="color:#e6db74">&#34;]&#34;</span>, <span style="color:#e6db74">&#34;\n&#34;</span>;
}
</code></pre></div><p>Compared to an O(<em>n</em> log <em>n</em>) <code>sort</code> + scan solution, there is more happening, here, and since there is already a <code>sort</code>, the performance cannot be any better than O(<em>n</em> log <em>n</em>). Unrolling the intervals in <code>@L</code> means that for intervals over large ranges, this will no longer scale on the number of intervals, but rather on the size and number of those intervals.</p>
<h2 id="colin-crain1">Colin Crain</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/colin-crain/perl/ch-1.pl">Colin Crain&rsquo;s solution</a> uses a <code>sort</code>-then-scan method, <code>shift</code>ing each interval from a <code>@sorted</code> list, and <code>push</code>ing the results to <code>@output</code>. Colin repeatedly peeks at the next element of <code>@sorted</code>, and if it can be merged, it, too, is <code>shift</code>ed, and the results are merged:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#75715e">## sort and order the data before commencing</span>
<span style="color:#66d9ef">my</span> @intervals   <span style="color:#f92672">=</span> ([<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">7</span>], [<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">9</span>], [<span style="color:#ae81ff">19</span>,<span style="color:#ae81ff">15</span>], [<span style="color:#ae81ff">18</span>,<span style="color:#ae81ff">22</span>], [<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">12</span>]);
<span style="color:#66d9ef">my</span> @remapped    <span style="color:#f92672">=</span> map  { $_<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;=</span> $_<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>] ? $_ : [reverse $_<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*]</span> <span style="color:#960050;background-color:#1e0010">}</span> <span style="color:#960050;background-color:#1e0010">@</span>intervals;
<span style="color:#66d9ef">my</span> @sorted      <span style="color:#f92672">=</span> sort { $a<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] <span style="color:#e6db74">&lt;=&gt;</span> $b<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] } @remapped;
<span style="color:#66d9ef">my</span> @output;
<span style="color:#66d9ef">while</span> ( <span style="color:#66d9ef">my</span> $current <span style="color:#f92672">=</span> shift @sorted ){
    <span style="color:#75715e">## iterate through the intervals until a lower is greater than the current upper bound</span>
    <span style="color:#66d9ef">while</span> (scalar @sorted <span style="color:#f92672">&amp;&amp;</span> ($sorted[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;=</span> $current<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>])) {
        <span style="color:#66d9ef">my</span> $next <span style="color:#f92672">=</span> shift @sorted;
        $current<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> $next<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>] <span style="color:#66d9ef">if</span> $next<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&gt;</span> $current<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>];
    }
    <span style="color:#75715e">## once out of there we add to the output list, loop and and start again</span>
    <span style="color:#75715e">## with the next discontinuous interval</span>
    push @output, $current;
}
<span style="color:#75715e">## output</span>
say join <span style="color:#e6db74">&#39;, &#39;</span>, map { <span style="color:#e6db74">&#34;[&#34;</span> <span style="color:#f92672">.</span> (join <span style="color:#e6db74">&#34;, &#34;</span>, $_<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span>) <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34;]&#34;</span> } @output;
</code></pre></div><h2 id="dave-cross1">Dave Cross</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/dave-cross/perl/ch-1.pl">Dave Cross&rsquo;s solution</a> performs a linear scan without sorting, and produces some strange results:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">get_input</span> {
    die <span style="color:#e6db74">&#34;No input given\n&#34;</span> <span style="color:#66d9ef">unless</span> @ARGV;
    <span style="color:#66d9ef">my</span> $input <span style="color:#f92672">=</span> join <span style="color:#e6db74">&#39;&#39;</span>, @ARGV;
    <span style="color:#66d9ef">if</span> ( $input <span style="color:#f92672">=~</span><span style="color:#e6db74"> /[^\[\],\d\s]/</span> ) {
        die <span style="color:#e6db74">&#34;Invalid input: $input\n&#34;</span>;
    }
    <span style="color:#66d9ef">return</span> eval <span style="color:#e6db74">&#39;[&#39;</span> <span style="color:#f92672">.</span> $input <span style="color:#f92672">.</span> <span style="color:#e6db74">&#39;]&#39;</span>;
}

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">merge_intervals</span> {
    <span style="color:#66d9ef">my</span> $intervals_in <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">my</span> $intervals_out;
    $_ <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">while</span> ( $_ <span style="color:#f92672">&lt;=</span> $#{$intervals_in} <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> ) {
        <span style="color:#66d9ef">if</span> ( $intervals_in<span style="color:#f92672">-&gt;</span>[ $_ <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> ][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;=</span> $intervals_in<span style="color:#f92672">-&gt;</span>[$_][<span style="color:#ae81ff">1</span>] ) {
            warn <span style="color:#e6db74">&#34;Merging [$intervals_in-&gt;[$_][0],$intervals_in-&gt;[$_][1]] &#34;</span>,
              <span style="color:#e6db74">&#34;with [$intervals_in-&gt;[$_ + 1][0],$intervals_in-&gt;[$_ + 1][1]]\n&#34;</span>;
            push @$intervals_out,
              [ $intervals_in<span style="color:#f92672">-&gt;</span>[$_][<span style="color:#ae81ff">0</span>], $intervals_in<span style="color:#f92672">-&gt;</span>[ $_ <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> ][<span style="color:#ae81ff">1</span>] ];
            $_ <span style="color:#f92672">+=</span> <span style="color:#ae81ff">2</span>;
        }
        <span style="color:#66d9ef">else</span> {
            push @$intervals_out, $intervals_in<span style="color:#f92672">-&gt;</span>[$_];
            $_<span style="color:#f92672">++</span>;
        }
    }
    <span style="color:#66d9ef">return</span> $intervals_out;
}
</code></pre></div><p>I tried this program with <code>[2,7],[3,4],[8,10],[4,5]</code>, and it returned <code>[2,4],[8,5]</code>, which is incorrect. However, even if I pre-sort the intervals first (<code>[2,7],[3,4],[4,5],[8,10]</code>), it returns <code>[2,4],[4,5]</code>, which is also incorrect.</p>
<p>A quick survey of the code suggests the scan needs to consider consecutive merged intervals, and be careful not to advance past the next interval. After that, the input would either need to be <code>sort</code>ed or documentation added indicating the sorted input requirement. It&rsquo;s very possible I&rsquo;m missing something.</p>
<h2 id="dave-jacoby1">Dave Jacoby</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/dave-jacoby/perl/ch-1.pl">Dave Jacoby&rsquo;s solution</a> sorts the input <code>@array</code> first, and then does an O(n²) traversal to merge:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">use</span> JSON;
<span style="color:#66d9ef">my</span> $json <span style="color:#f92672">=</span> JSON<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">new</span>;
<span style="color:#66d9ef">my</span> @array <span style="color:#f92672">=</span> ( [ <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">7</span> ], [ <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">9</span> ], [ <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">12</span> ], [ <span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">19</span> ], [ <span style="color:#ae81ff">18</span>, <span style="color:#ae81ff">22</span> ] );
<span style="color:#75715e"># unnecessary in THIS case, but if we take on abstract</span>
<span style="color:#75715e"># two-dimensional array, we&#39;ll have to enforce order</span>
@array <span style="color:#f92672">=</span> sort { $a<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] <span style="color:#e6db74">&lt;=&gt;</span> $b<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] } @array;
say $json<span style="color:#f92672">-&gt;</span>encode( <span style="color:#f92672">\</span>@array );
LOOP: <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>) {
    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i ( <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> scalar @array <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> ) {
        <span style="color:#66d9ef">my</span> @i <span style="color:#f92672">=</span> $array[$i]<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>
        for <span style="color:#66d9ef">my</span> $j ( $i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> scalar @array <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> ) {
            <span style="color:#66d9ef">my</span> @j <span style="color:#f92672">=</span> $array[$j]<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>
            if ( $i[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;=</span> $j[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&amp;&amp;</span> $i[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&gt;=</span> $j[<span style="color:#ae81ff">0</span>] ) {
                $array[$i][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> int $j[<span style="color:#ae81ff">1</span>];
                undef $array[$j];
                @array <span style="color:#f92672">=</span> grep { defined } @array;
                <span style="color:#66d9ef">next</span> LOOP;
            }
        }
    }
    say $json<span style="color:#f92672">-&gt;</span>encode( <span style="color:#f92672">\</span>@array );
    exit;
}
</code></pre></div><p>Dave&rsquo;s blog mentions the efficiency as being O(<em>n</em> log <em>n</em>), but the nested loop makes it O(n²). More specifically, the nested loop is Θ(T(n)) = Θ(n(n+1)/2), but this is O(n²).</p>
<p><strong>Blog</strong> › <a href="https://jacoby.github.io/2020/03/02/perl-challenge-50.html">Perl Challenge #50</a></p>
<h2 id="duncan-c-white1">Duncan C. White</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/duncan-c-white/perl/ch-1.pl">Duncan C. White&rsquo;s solution</a> first poses an interesting question. Given the &ldquo;final result&rdquo; from the problem description (<code>[2, 9], [10, 12], [15, 22]</code>), Duncan asks, &ldquo;why wouldn&rsquo;t we also merge <code>[2,9]</code> and <code>[10,12]</code> to give <code>[2,12]</code>?  I think we would&rdquo;. Thus, Duncan&rsquo;s solution merges adjacent integer intervals as well:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#75715e"># build %on: a set of all integers marked &#34;on&#34; by the ranges</span>
<span style="color:#66d9ef">my</span> %on;
<span style="color:#66d9ef">my</span> $min <span style="color:#f92672">=</span> <span style="color:#ae81ff">1000000</span>;
<span style="color:#66d9ef">my</span> $max <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
<span style="color:#66d9ef">while</span> ( @ARGV <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">2</span> ) {
    ( <span style="color:#66d9ef">my</span> $a, <span style="color:#66d9ef">my</span> $b, @ARGV ) <span style="color:#f92672">=</span> @ARGV;
    die <span style="color:#e6db74">&#34;int-sequences: a=$a, b=$b, a&gt;b\n&#34;</span> <span style="color:#66d9ef">if</span> $a <span style="color:#f92672">&gt;</span> $b;
    <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $i ( $a <span style="color:#f92672">..</span> $b ) {
        $on{$i}<span style="color:#f92672">++</span>;
        $min <span style="color:#f92672">=</span> $i <span style="color:#66d9ef">if</span> $i <span style="color:#f92672">&lt;</span> $min;
        $max <span style="color:#f92672">=</span> $i <span style="color:#66d9ef">if</span> $i <span style="color:#f92672">&gt;</span> $max;
    }
}

<span style="color:#75715e">#say &#34;min=$min, max=$max&#34;;</span>
<span style="color:#75715e"># now, produce the sequence of ranges from %on, using min and max</span>
<span style="color:#66d9ef">my</span> $start <span style="color:#f92672">=</span> <span style="color:#66d9ef">my</span> $end <span style="color:#f92672">=</span> $min;
<span style="color:#66d9ef">for</span> ( ; ; ) {
    <span style="color:#66d9ef">while</span> ( $on{ $end <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> } ) {
        $end<span style="color:#f92672">++</span>;
    }
    say <span style="color:#e6db74">&#34;[$start - $end]&#34;</span>;
    $start <span style="color:#f92672">=</span> $end <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">while</span> ( $start <span style="color:#f92672">&lt;=</span> $max <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>$on{$start} ) {
        $start<span style="color:#f92672">++</span>;
    }
    <span style="color:#66d9ef">last</span> <span style="color:#66d9ef">if</span> $start <span style="color:#f92672">&gt;</span> $max;
    $end <span style="color:#f92672">=</span> $start;
}
</code></pre></div><p>Duncan&rsquo;s algorithm unrolls each interval into all of the integers within, also keeping track of the <code>$min</code> and <code>$max</code> values seen. So, <code>[2,7] = 2, 3, 4, 5, 6, 7</code>. Once that has been done, Duncan iterates from <code>$min..$max</code> and prints out each interval as he comes to gaps in the number sequence (i.e., the keys in <code>%on</code>).</p>
<p>Efficiency-wise, this algorithm scales (nearly) with the total range. For example, <code>[1,2], [999,1000]</code> iterates 998 times.</p>
<p>At first glance, I think one could still satisfy the &ldquo;adjacent interval&rdquo; design decision by merging intervals where <code>$intervalA[1] + 1 &gt;= $intervalB[0]</code>. (E.g., <code>[2,9],[10,12]</code>: <code>9+1 &gt;= 10</code>, so they can be merged.)</p>
<h2 id="e-choroba1">E. Choroba</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/e-choroba/perl/ch-1.pl">E. Choroba</a> gives us a unique OO solution using bitmasks and the <a href="https://metacpan.org/pod/enum"><code>enum</code></a> CPAN module:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">package</span> MyInterval;
<span style="color:#66d9ef">use</span> enum <span style="color:#e6db74">&#39;BITMASK:&#39;</span> <span style="color:#f92672">=&gt;</span> <span style="color:#e6db74">qw( LEFT RIGHT SINGLE )</span>;

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">new</span> { bless {}, shift }

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">insert</span> {
    <span style="color:#66d9ef">my</span> ($self, $from, $to) <span style="color:#f92672">=</span> @_;
    $self<span style="color:#f92672">-&gt;</span>{$from} <span style="color:#f92672">|=</span> SINGLE, <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">if</span> $from <span style="color:#f92672">==</span> $to;
    $self<span style="color:#f92672">-&gt;</span>{$from} <span style="color:#f92672">|=</span> LEFT;
    $self<span style="color:#f92672">-&gt;</span>{$_} <span style="color:#f92672">=</span> LEFT <span style="color:#f92672">|</span> RIGHT <span style="color:#66d9ef">for</span> $from <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> $to <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
    $self<span style="color:#f92672">-&gt;</span>{$to} <span style="color:#f92672">|=</span> RIGHT;
}

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">out</span> {
    <span style="color:#66d9ef">my</span> ($self) <span style="color:#f92672">=</span> @_;
    <span style="color:#66d9ef">my</span> @r;
    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $k (sort { $a <span style="color:#e6db74">&lt;=&gt;</span> $b } keys %$self) {
        <span style="color:#66d9ef">if</span> (($self<span style="color:#f92672">-&gt;</span>{$k} <span style="color:#f92672">&amp;</span> (LEFT <span style="color:#f92672">|</span> RIGHT)) <span style="color:#f92672">==</span> LEFT) {
            push @r, [$k];
        } <span style="color:#66d9ef">elsif</span> (($self<span style="color:#f92672">-&gt;</span>{$k} <span style="color:#f92672">&amp;</span> (LEFT <span style="color:#f92672">|</span> RIGHT)) <span style="color:#f92672">==</span> RIGHT) {
            push @{ $r[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] }, $k
        } <span style="color:#66d9ef">elsif</span> ((<span style="color:#f92672">!</span> @r <span style="color:#f92672">||</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">!=</span> @{ $r[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] }) <span style="color:#f92672">&amp;&amp;</span> ($self<span style="color:#f92672">-&gt;</span>{$k} <span style="color:#f92672">==</span> SINGLE)) {
            push @r, [$k, $k];
        }
    }
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">\</span>@r
}
</code></pre></div><p>As you can see, the <code>insert</code> method unrolls each interval, using <code>$self</code> for storage. The <code>out</code> method simply trundles through the keys of <code>$self</code> in numerical order, merging or <code>push</code>ing as indicated. Maintaining the <code>LEFT</code>, <code>RIGHT</code>, and <code>SINGLE</code> boundaries allows Choroba to use the unrolling method while still maintaining separation between adjacent ranges.</p>
<p><strong>Blog</strong> › <a href="http://blogs.perl.org/users/e_choroba/2020/03/perl-weekly-challenge-050-merge-intervals-and-noble-integer.html">Merge Intervals and Noble Integer</a></p>
<h2 id="ianrifkin1">Ian Rifkin</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/ianrifkin/perl/ch-1.pl">Ian Rifkin&rsquo;s solution</a> makes an explicit assumption that the input is sorted, which allows him to craft a simple linear solution, using <code>splice</code> to remove the right-hand counterpart in every &ldquo;merged&rdquo; pair:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> @numbers <span style="color:#f92672">=</span> ( [ <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">7</span> ], [ <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">9</span> ], [ <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">12</span> ], [ <span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">19</span> ], [ <span style="color:#ae81ff">18</span>, <span style="color:#ae81ff">22</span> ] );
<span style="color:#66d9ef">for</span> ( <span style="color:#66d9ef">my</span> $i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> ; $i <span style="color:#f92672">&lt;</span> scalar @numbers <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> ; $i<span style="color:#f92672">++</span> ) {
    <span style="color:#66d9ef">if</span> (   $numbers[$i][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&gt;=</span> $numbers[ $i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> ][<span style="color:#ae81ff">0</span>]
        <span style="color:#f92672">&amp;&amp;</span> $numbers[$i][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&lt;=</span> $numbers[ $i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> ][<span style="color:#ae81ff">1</span>] )
    {
        $numbers[$i][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> $numbers[ $i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> ][<span style="color:#ae81ff">1</span>];
        splice( @numbers, $i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span> );
        $i<span style="color:#f92672">--</span>; <span style="color:#75715e">#loop through to check if new merged interval should also merge with the next one</span>
    }
}
</code></pre></div><p>Thus, this solution is O(n) on sorted inputs, but would require a <code>sort</code> to allow it to work on any input, which would bring it in line with other O(<em>n</em> log <em>n</em>) solutions we&rsquo;ve seen.</p>
<h2 id="jaldhar-h-vyas1">Jaldhar H. Vyas</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/jaldhar-h-vyas/perl/ch-1.pl">Jaldhar H. Vyas&rsquo;s solution</a> accepts a list of sorted intervals in string form on the commandline:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> @intervals;
<span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $arg (@ARGV) {
    $arg <span style="color:#f92672">=~</span><span style="color:#e6db74"> /\[ (\d+) , (\d+) \] ,?/gmx</span>;
    push @intervals,  [$1, $2];
}
<span style="color:#66d9ef">my</span> $size <span style="color:#f92672">=</span> scalar @intervals;
</code></pre></div><p>By the way, the <code>scalar</code> is not necessary here, as assigning to a scalar variable already activates scalar context. It doesn&rsquo;t hurt, though.</p>
<p>Next, Jaldhar has a slightly unorthodox nested loop that increments the outer loop variable in the inner <code>while</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> @merged;
<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">my</span> $i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; $i <span style="color:#f92672">&lt;</span> $size <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; $i<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">my</span> $start <span style="color:#f92672">=</span> $intervals[$i]<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>];
    <span style="color:#66d9ef">my</span> $end <span style="color:#f92672">=</span> $intervals[$i]<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>];
    <span style="color:#66d9ef">while</span> ($i <span style="color:#f92672">&lt;</span> $size <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span>
    $end <span style="color:#f92672">&gt;=</span> $intervals[$i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&amp;&amp;</span> $end <span style="color:#f92672">&lt;=</span> $intervals[$i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>]) {
        $end <span style="color:#f92672">=</span> $intervals[$i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>];
        $i<span style="color:#f92672">++</span>;
    }
    push @merged, [$start, $end];
}
say join <span style="color:#e6db74">&#39;, &#39;</span>, map { <span style="color:#e6db74">&#34;[$_-&gt;[0],$_-&gt;[1]]&#34;</span> } @merged;
</code></pre></div><p>What this does is take the current interval (<code>[$start, $end]</code>), and then loop <code>while</code> the <code>$end</code> (which is updated in the inner loop) is bigger than the next interval&rsquo;s lower number, but less than or equal to the higher number. Thus, it only works on pre-sorted inputs. Given the sequence <code>[2,3] [3,5] [7,8] [3,6]</code>, the output is <code>[2,5], [7,8]</code>, but I would expect <code>[2,6], [7,8]</code>.</p>
<h2 id="javier-luque1">Javier Luque</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/javier-luque/perl/ch-1.pl">Javier Luque&rsquo;s solution</a> also relies on sorted input. He first parses <code>@ARGV</code> and builds up a list of intervals in <code>@values</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">use</span> List::Util <span style="color:#e6db74">qw /min </span>max <span style="color:#f92672">/</span>;
<span style="color:#66d9ef">my</span> $arg_string <span style="color:#f92672">=</span> join <span style="color:#e6db74">&#39;&#39;</span>, @ARGV;
$arg_string <span style="color:#f92672">=~</span> <span style="color:#e6db74">s/[\s\[\]]//g</span>;
<span style="color:#66d9ef">my</span> @values <span style="color:#f92672">=</span> split (<span style="color:#e6db74">&#39;,&#39;</span>, $arg_string);
<span style="color:#66d9ef">my</span> @lists;
<span style="color:#75715e"># Create the lists</span>
<span style="color:#66d9ef">while</span> (@values) {
    <span style="color:#66d9ef">my</span> $min <span style="color:#f92672">=</span> shift @values;
    <span style="color:#66d9ef">my</span> $max <span style="color:#f92672">=</span> shift @values;
    push @lists, [$min, $max];
}
</code></pre></div><p>The merging code is then just a linear traversal:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> $i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#66d9ef">while</span> ($i <span style="color:#f92672">&lt;</span> scalar(@lists) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) {
    <span style="color:#66d9ef">if</span> ( $lists[$i]<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&gt;=</span> $lists[$i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&amp;&amp;</span>
         $lists[$i]<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;=</span> $lists[$i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>]) {
        <span style="color:#66d9ef">my</span> $new_min <span style="color:#f92672">=</span> min($lists[$i]<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>], $lists[$i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>]);
        <span style="color:#66d9ef">my</span> $new_max <span style="color:#f92672">=</span> max($lists[$i]<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>], $lists[$i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>]);
        splice ( @lists, $i, <span style="color:#ae81ff">2</span>, [$new_min, $new_max] );
    } <span style="color:#66d9ef">else</span> {
        $i<span style="color:#f92672">++</span>;
    }
}
say join <span style="color:#e6db74">&#39;, &#39;</span>,
    map { <span style="color:#e6db74">&#39;[&#39;</span> <span style="color:#f92672">.</span> $_<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">.</span> <span style="color:#e6db74">&#39;, &#39;</span> <span style="color:#f92672">.</span> $_<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">.</span> <span style="color:#e6db74">&#39;]&#39;</span>}
    @lists;
</code></pre></div><p><strong>Blog</strong> › <a href="https://perlchallenges.wordpress.com/2020/03/02/perl-weekly-challenge-050/">050 – Perl Weekly Challenge</a></p>
<h2 id="laurent-rosenfeld1">Laurent Rosenfeld</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/laurent-rosenfeld/perl/ch-1.pl">Laurent Rosenfeld&rsquo;s solution</a> sorts, then does an O(n) traversal of the sorted <code>@intervals</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">use</span> strict;
<span style="color:#66d9ef">use</span> warnings;
<span style="color:#66d9ef">use</span> feature <span style="color:#e6db74">&#34;say&#34;</span>;
<span style="color:#66d9ef">use</span> Data::Dumper;
<span style="color:#66d9ef">my</span> @intervals <span style="color:#f92672">=</span> ([<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">7</span>], [<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>], [<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">9</span>], [<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">12</span>], [<span style="color:#ae81ff">15</span>,<span style="color:#ae81ff">19</span>], [<span style="color:#ae81ff">18</span>,<span style="color:#ae81ff">22</span>], [<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>], [<span style="color:#ae81ff">24</span>,<span style="color:#ae81ff">35</span>], [<span style="color:#ae81ff">25</span>,<span style="color:#ae81ff">30</span>]);
@intervals <span style="color:#f92672">=</span>  sort { $a<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] <span style="color:#e6db74">&lt;=&gt;</span> $b<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] } @intervals;
<span style="color:#66d9ef">my</span> @merged;
<span style="color:#75715e"># say Dumper \@intervals;</span>
<span style="color:#66d9ef">my</span> $current <span style="color:#f92672">=</span> $intervals[<span style="color:#ae81ff">0</span>];
<span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i (<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$#intervals) {
    <span style="color:#66d9ef">if</span> ($intervals[$i][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&gt;</span> $current<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>]) {
        push @merged, $current;
        $current <span style="color:#f92672">=</span> $intervals[$i];
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#66d9ef">next</span> <span style="color:#66d9ef">unless</span> $intervals[$i][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&gt;</span> $current<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>];
        $current<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> $intervals[$i][<span style="color:#ae81ff">1</span>];
    }
}
push @merged, $current;
say Dumper <span style="color:#f92672">\</span>@merged;
</code></pre></div><p><strong>Blog</strong> › <a href="http://blogs.perl.org/users/laurent_r/2020/03/perl-weekly-challenge-merge-inrervals-and-noble-numbers.html">Merge [Intervals] and Noble Numbers</a></p>
<h2 id="mohammad-anwar1">Mohammad S Anwar</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/mohammad-anwar/perl/ch-1.pl">Mohammad S Anwar&rsquo;s solution</a> includes no less than 73 test cases. I respect that sort of dedication to correctness.</p>
<p>Mohammad&rsquo;s solution sorts and then does a linear traversal to <code>push</code> all intervals to a result array ref, <code>$m</code>. <code>merge_intervals</code> is the main sub:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">merge_intervals</span> {
    <span style="color:#66d9ef">my</span> ($intervals) <span style="color:#f92672">=</span> @_;
    <span style="color:#66d9ef">my</span> $k;
    <span style="color:#66d9ef">my</span> $l;
    <span style="color:#66d9ef">my</span> $m;
    $intervals <span style="color:#f92672">=</span> _order_intervals($intervals);
    <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $interval (@$intervals) {
        <span style="color:#66d9ef">my</span> $i <span style="color:#f92672">=</span> $interval<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>];
        <span style="color:#66d9ef">if</span> (defined $l <span style="color:#f92672">&amp;&amp;</span> defined $k) {
            <span style="color:#66d9ef">if</span> (($i <span style="color:#f92672">&lt;=</span> $l) <span style="color:#f92672">||</span> ($k <span style="color:#f92672">==</span> $i)) {
                $k <span style="color:#f92672">=</span> $interval<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>];
                <span style="color:#66d9ef">if</span> ($m<span style="color:#f92672">-&gt;</span>[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&lt;</span> $k) {
                    $m<span style="color:#f92672">-&gt;</span>[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> $k;
                }
                <span style="color:#66d9ef">next</span>;
            }
        }
        <span style="color:#66d9ef">my</span> ($j, $_k) <span style="color:#f92672">=</span> _merge_intervals($interval<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>], $intervals);
        <span style="color:#66d9ef">if</span> ($j <span style="color:#f92672">&lt;</span> $interval<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>]) {
            $j <span style="color:#f92672">=</span> $interval<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>];
        }
        push @$m, [$i, $j];
        $k <span style="color:#f92672">=</span> $_k;
        $l <span style="color:#f92672">=</span> $j;
    }
    <span style="color:#66d9ef">return</span> $m;
}
</code></pre></div><p>Mohammad sorts the input with the help of <code>_order_intervals</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">_order_intervals</span> {
    <span style="color:#66d9ef">my</span> ($intervals) <span style="color:#f92672">=</span> @_;
    <span style="color:#66d9ef">my</span> @intervals <span style="color:#f92672">=</span> ();
    <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $i (@$intervals) {
        push @intervals, sprintf(<span style="color:#e6db74">&#34;%d-%d&#34;</span>, $i<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>], $i<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>]);
    }
    <span style="color:#75715e"># Borrowed with input from E. Choroba</span>
    <span style="color:#75715e"># https://stackoverflow.com/questions/27089498/sorting-arrays-of-intervals-in-perl</span>
    <span style="color:#66d9ef">my</span> @_sorted <span style="color:#f92672">=</span> sort {
        <span style="color:#66d9ef">my</span> ($a1, $a2) <span style="color:#f92672">=</span> $a <span style="color:#f92672">=~</span><span style="color:#e6db74"> /-?\d+/g</span>;
        <span style="color:#66d9ef">my</span> ($b1, $b2) <span style="color:#f92672">=</span> $b <span style="color:#f92672">=~</span><span style="color:#e6db74"> /-?\d+/g</span>;
        $a1 <span style="color:#e6db74">&lt;=&gt;</span> $b1 <span style="color:#f92672">||</span> $a2 <span style="color:#e6db74">&lt;=&gt;</span> $b2;
    } @intervals;
    <span style="color:#66d9ef">my</span> $sorted <span style="color:#f92672">=</span> <span style="color:#f92672">[]</span>;
    <span style="color:#66d9ef">foreach</span> (@_sorted) {
        <span style="color:#66d9ef">my</span> ($a, $b) <span style="color:#f92672">=</span> split <span style="color:#e6db74">/(?&lt;=\d)-(?=\d)/</span>, $_, <span style="color:#ae81ff">2</span>;
        push @$sorted, [ $a<span style="color:#f92672">+</span><span style="color:#ae81ff">0</span>, $b<span style="color:#f92672">+</span><span style="color:#ae81ff">0</span> ];
    }
    <span style="color:#66d9ef">return</span> $sorted;
}
</code></pre></div><p>For my taste, this <code>_order_intervals</code> is more complex than it needs to be. Converting the interval to a string, using a regex to parse that string, and then converting it back to an array ref is a lot of extra work, when <code>sort</code> is perfectly capable of dealing with the array ref as-is, more efficiently and concisely:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#75715e"># Ryan&#39;s version</span>
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">_order_intervals</span> {
    [ sort { $a<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] <span style="color:#e6db74">&lt;=&gt;</span> $b<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">||</span> $a<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>] <span style="color:#e6db74">&lt;=&gt;</span> $b<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>] } @{$_[<span style="color:#ae81ff">0</span>]} ]
}
</code></pre></div><p>Lastly, the <code>_merge_intervals</code> subroutine merges an arbitrary number of intervals into a single interval, returned as <code>$_j</code> and <code>$_i</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">_merge_intervals</span> {
    <span style="color:#66d9ef">my</span> ($j, $intervals) <span style="color:#f92672">=</span> @_;
    <span style="color:#66d9ef">my</span> $_j <span style="color:#f92672">=</span> $j;
    <span style="color:#66d9ef">my</span> $_i;
    <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $i (@$intervals) {
        <span style="color:#66d9ef">if</span> ($i<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;=</span> $j) {
            $_j <span style="color:#f92672">=</span> $i<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>];
            $_i <span style="color:#f92672">=</span> $i<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>];
        }
    }
    <span style="color:#66d9ef">return</span> ($_j, $_i);
}
</code></pre></div><p><strong>Blog</strong> › <a href="https://perlweeklychallenge.org/blog/weekly-challenge-050/">BLOG: The Weekly Challenge #050</a></p>
<h2 id="phillip-harris1">Phillip Harris</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/phillip-harris/perl/ch-1.pl">Phillip Harris&rsquo;s solution</a> uses the O(n²) brute force method, with <code>splice</code> to merge intervals in place:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> @in <span style="color:#f92672">=</span> ( [ <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">7</span> ], [ <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">9</span> ], [ <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">12</span> ], [ <span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">19</span> ], [ <span style="color:#ae81ff">18</span>, <span style="color:#ae81ff">22</span> ] );

<span style="color:#66d9ef">for</span> ( <span style="color:#66d9ef">my</span> $x <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> ; $x <span style="color:#f92672">&lt;=</span> $#in ; $x<span style="color:#f92672">++</span> ) {
    <span style="color:#66d9ef">for</span> ( <span style="color:#66d9ef">my</span> $y <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> ; $y <span style="color:#f92672">&lt;=</span> $#in ; $y<span style="color:#f92672">++</span> ) {
        <span style="color:#66d9ef">if</span> ( $y <span style="color:#f92672">==</span> $x ) { <span style="color:#66d9ef">next</span> }
        <span style="color:#66d9ef">my</span> $s1 <span style="color:#f92672">=</span> $in[$x][<span style="color:#ae81ff">0</span>];
        <span style="color:#66d9ef">my</span> $e1 <span style="color:#f92672">=</span> $in[$x][<span style="color:#ae81ff">1</span>];
        <span style="color:#66d9ef">my</span> $s2 <span style="color:#f92672">=</span> $in[$y][<span style="color:#ae81ff">0</span>];
        <span style="color:#66d9ef">my</span> $e2 <span style="color:#f92672">=</span> $in[$y][<span style="color:#ae81ff">1</span>];
        <span style="color:#66d9ef">my</span> $splice;
        <span style="color:#66d9ef">my</span> $target;
        <span style="color:#66d9ef">if</span> (   ( $s2 <span style="color:#f92672">&gt;=</span> $s1 <span style="color:#f92672">and</span> $s2 <span style="color:#f92672">&lt;=</span> $e1 )
            <span style="color:#f92672">or</span> ( $e2 <span style="color:#f92672">&gt;=</span> $s1 <span style="color:#f92672">and</span> $e2 <span style="color:#f92672">&lt;=</span> $e1 )
            <span style="color:#f92672">or</span> ( $s2 <span style="color:#f92672">&lt;=</span> $s1 <span style="color:#f92672">and</span> $e2 <span style="color:#f92672">&gt;=</span> $s1 ) )
        {
            <span style="color:#66d9ef">my</span> @sort <span style="color:#f92672">=</span> sort { $a <span style="color:#e6db74">&lt;=&gt;</span> $b } ( $s1, $e1, $s2, $e2 );
            <span style="color:#66d9ef">if</span> ( $y <span style="color:#f92672">&gt;</span> $x ) { $splice <span style="color:#f92672">=</span> $y, $target <span style="color:#f92672">=</span> $x }
            <span style="color:#66d9ef">if</span> ( $y <span style="color:#f92672">&lt;</span> $x ) { $splice <span style="color:#f92672">=</span> $x, $target <span style="color:#f92672">=</span> $y }
            <span style="color:#66d9ef">my</span> $temp <span style="color:#f92672">=</span> splice( @in, $splice, <span style="color:#ae81ff">1</span> );
            $in[$target][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> $sort[<span style="color:#ae81ff">0</span>];
            $in[$target][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> $sort[<span style="color:#ae81ff">3</span>];
            $y<span style="color:#f92672">--</span>;
        }
    }
}
<span style="color:#66d9ef">print</span> Dumper(@in);
</code></pre></div><h2 id="roger-bell-west1">Roger Bell West</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/roger-bell-west/perl/ch-1.pl">Roger Bell West&rsquo;s solution</a> takes intervals as <code>sort</code>ed pairs of numbers from <code>@ARGV</code>. The overall list of intervals is not sorted, and so Roger does an O(n²) nested loop:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> @i;
<span style="color:#66d9ef">while</span> (@ARGV) {
    <span style="color:#66d9ef">if</span> ( scalar @ARGV <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span> ) {
        push @i, [ sort ( shift @ARGV, shift @ARGV ) ];
    }
}

<span style="color:#66d9ef">my</span> $dirty <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
<span style="color:#66d9ef">while</span> ($dirty) {
    $dirty <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  OUTER:
    <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $a ( <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $#i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> ) {
        <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $b ( $a <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> $#i ) {
            <span style="color:#66d9ef">if</span> ( $i[$a][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&gt;=</span> $i[$b][<span style="color:#ae81ff">0</span>] ) {
                $i[$a][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> $i[$b][<span style="color:#ae81ff">1</span>];
                splice @i, $b, <span style="color:#ae81ff">1</span>;
                $dirty <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
                <span style="color:#66d9ef">last</span> OUTER;
            }
        }
    }
}
<span style="color:#66d9ef">my</span> @o;
<span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $range (@i) {
    push @o, <span style="color:#e6db74">&#39;[&#39;</span> <span style="color:#f92672">.</span> $range<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">.</span> <span style="color:#e6db74">&#39;, &#39;</span> <span style="color:#f92672">.</span> $range<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">.</span> <span style="color:#e6db74">&#39;]&#39;</span>;
}
<span style="color:#66d9ef">print</span> join( <span style="color:#e6db74">&#39;, &#39;</span>, @o ), <span style="color:#e6db74">&#34;\n&#34;</span>;
</code></pre></div><p>When given the input <code>2 4  3 5  6 8  7 10</code>, it outputs <code>[2,5], [6,8], [10,7]</code>, while I would expect <code>[2,5], [6,10]</code>. The problem is that each interval is passed through <code>sort</code> with the default comparison, which is stringwise, so 10 is lexically less than 7. The fix is simple:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">        push @i, [ sort { $a <span style="color:#e6db74">&lt;=&gt;</span> $b } ( shift @ARGV, shift @ARGV ) ];
</code></pre></div><h2 id="ruben-westerberg1">Ruben Westerberg</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/ruben-westerberg/perl/ch-1.pl">Ruben Westerberg&rsquo;s solution</a> accepts a string input, and pushes all parsed intervals into an array of hash refs, and then sorts them:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> $input <span style="color:#f92672">=</span> join <span style="color:#e6db74">&#34;&#34;</span>, @ARGV;
$input <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;[2,7], [3,9], [10,12], [15,19], [18,22]&#34;</span> <span style="color:#66d9ef">unless</span> @ARGV;
$input <span style="color:#f92672">=~</span> <span style="color:#e6db74">s/\s+//g</span>;
<span style="color:#66d9ef">my</span> @ranges;

<span style="color:#66d9ef">while</span> ( $input <span style="color:#f92672">=~</span><span style="color:#e6db74"> /\[(\d+)\,(\d+)\]/g</span> ) {
    push @ranges, { start <span style="color:#f92672">=&gt;</span> int($1), end <span style="color:#f92672">=&gt;</span> int($2) };
}
@ranges <span style="color:#f92672">=</span> sort { $a<span style="color:#f92672">-&gt;</span>{start} <span style="color:#f92672">&gt;</span> $b<span style="color:#f92672">-&gt;</span>{start} } @ranges;
</code></pre></div><p>After that, Ruben builds up a new <code>@merged</code> array of intervals with an O(n²) nested loop:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> @merged;
<span style="color:#66d9ef">while</span> (@ranges) {
    <span style="color:#66d9ef">my</span> $test <span style="color:#f92672">=</span> shift @ranges;
    @ranges <span style="color:#f92672">=</span> map {
        <span style="color:#66d9ef">do</span> {
            <span style="color:#66d9ef">my</span> $c1 <span style="color:#f92672">=</span> ( $_<span style="color:#f92672">-&gt;</span>{start} <span style="color:#f92672">&lt;=</span> $test<span style="color:#f92672">-&gt;</span>{start} )
              <span style="color:#f92672">&amp;&amp;</span> ( $test<span style="color:#f92672">-&gt;</span>{start} <span style="color:#f92672">&lt;=</span> $_<span style="color:#f92672">-&gt;</span>{end} );
            <span style="color:#66d9ef">my</span> $c2 <span style="color:#f92672">=</span> ( $test<span style="color:#f92672">-&gt;</span>{start} <span style="color:#f92672">&lt;=</span> $_<span style="color:#f92672">-&gt;</span>{start} )
              <span style="color:#f92672">&amp;&amp;</span> ( $_<span style="color:#f92672">-&gt;</span>{start} <span style="color:#f92672">&lt;=</span> $test<span style="color:#f92672">-&gt;</span>{end} );
            <span style="color:#66d9ef">if</span> ( $c1 <span style="color:#f92672">||</span> $c2 ) {
                $test<span style="color:#f92672">-&gt;</span>{start} <span style="color:#f92672">=</span> List::Util::min $_<span style="color:#f92672">-&gt;</span>{start}, $test<span style="color:#f92672">-&gt;</span>{start};
                $test<span style="color:#f92672">-&gt;</span>{end}   <span style="color:#f92672">=</span> List::Util::max $_<span style="color:#f92672">-&gt;</span>{end},   $test<span style="color:#f92672">-&gt;</span>{end};
                ();
            }
            <span style="color:#66d9ef">else</span> {
                $_;
            }
        }
    } @ranges;
    push @merged, $test;
}
printf <span style="color:#e6db74">&#34;Merged Ranges: %s\n&#34;</span>, join <span style="color:#e6db74">&#34;,&#34;</span>,
  map { sprintf( <span style="color:#e6db74">&#34;[%s,%s]&#34;</span>, $_<span style="color:#f92672">-&gt;</span>{start}, $_<span style="color:#f92672">-&gt;</span>{end} ) } @merged;
</code></pre></div><h2 id="ryan-thompson1">Ryan Thompson</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/ryan-thompson/perl/ch-1.pl">My solution</a> sorts and then does an O(n) traversal with <code>reduce</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">use</span> List::Util <span style="color:#e6db74">qw/reduce/</span>;
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">merge_int</span> {
    reduce {
        (@$a <span style="color:#f92672">and</span> $a<span style="color:#f92672">-&gt;</span>[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&gt;=</span> $b<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>]) ?
            $a<span style="color:#f92672">-&gt;</span>[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> [ $a<span style="color:#f92672">-&gt;</span>[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>], $b<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>] ] : push @$a, $b;
        $a;
    } <span style="color:#f92672">[]</span> <span style="color:#f92672">=&gt;</span> sort { $a<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] <span style="color:#e6db74">&lt;=&gt;</span> $b<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] } @_;
}
</code></pre></div><p>Using <code>reduce</code> wasn&rsquo;t strictly necessary, but it felt appropriate, here. The relatively common trick of feeding a first argument to <code>reduce</code> allows me to use <code>reduce</code> to build up a new array (ref).</p>
<p><strong>Blog</strong> › <a href="http://ry.ca/2020/03/merge-intervals/">Merge Intervals</a></p>
<h2 id="saiftynet1">Saif Ahmed</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/saiftynet/perl/ch-1.pl">Saif Ahmed&rsquo;s solution</a> sorts and then iterates through, using <code>splice</code> to merge in place. The <code>merge</code> sub is a simple helper to return the merged result of two intervals:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#75715e"># The mergeIntervals takes a list of intervals, sorts them and merges where possible</span>
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">mergeIntervals</span> {
    <span style="color:#66d9ef">my</span> @toMerge <span style="color:#f92672">=</span>
      sort { $$a[<span style="color:#ae81ff">0</span>] <span style="color:#e6db74">&lt;=&gt;</span> $$b[<span style="color:#ae81ff">0</span>] } @_;    <span style="color:#75715e"># sort intervals on the intervals&#39; start</span>
    <span style="color:#66d9ef">my</span> $pointer <span style="color:#f92672">=</span> <span style="color:#66d9ef">our</span> $merges <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">while</span> ( $pointer <span style="color:#f92672">&lt;</span> $#toMerge ) {  <span style="color:#75715e"># check two adjacent intervals for merging</span>
        splice @toMerge, $pointer, <span style="color:#ae81ff">2</span>,
          merge( $toMerge[$pointer], $toMerge[ $pointer <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> ] );
        $pointer<span style="color:#f92672">++</span> <span style="color:#66d9ef">unless</span> $merges;    <span style="color:#75715e"># unless merging can move to next set</span>
        $merges <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;                  <span style="color:#75715e"># reset merges flag</span>
    }
    <span style="color:#66d9ef">return</span> @toMerge;

    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">merge</span> {    <span style="color:#75715e"># for sorted pair, pair will merge if start of second is</span>
        <span style="color:#66d9ef">my</span> ( $a, $b ) <span style="color:#f92672">=</span>
          @_;      <span style="color:#75715e"># less or equal to end of first. When a merge happens,</span>
                   <span style="color:#75715e"># start is the start of first, and end is the largest</span>
                   <span style="color:#75715e"># of either ends</span>
        <span style="color:#66d9ef">return</span> ( [ $$a[<span style="color:#ae81ff">0</span>], $$a[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&gt;</span> $$b[<span style="color:#ae81ff">1</span>] ? $$a[<span style="color:#ae81ff">1</span>] : $$b[<span style="color:#ae81ff">1</span>] ] )
          <span style="color:#66d9ef">if</span> $$a[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&gt;=</span> $$b[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">and</span> $merges <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;  <span style="color:#75715e"># a merge happens and is flagged</span>
        <span style="color:#66d9ef">return</span> ( $a, $b );    <span style="color:#75715e"># if not merged, returns the pair</span>
    }
}
</code></pre></div><h2 id="sol-demuth1">Sol DeMuth</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/sol-demuth/perl/ch-1.pl">Sol DeMuth&rsquo;s solution</a> does a <code>sort</code> and then an O(n) traversal with an in-place merge thanks to <code>splice</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> @sets <span style="color:#f92672">=</span> (
    [<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">7</span>], [<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">9</span>], [<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">12</span>], [<span style="color:#ae81ff">15</span>,<span style="color:#ae81ff">19</span>], [<span style="color:#ae81ff">18</span>,<span style="color:#ae81ff">22</span>],
);
@sets <span style="color:#f92672">=</span> sort {
    (
        $a<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] <span style="color:#e6db74">&lt;=&gt;</span> $b<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>]
    ) <span style="color:#f92672">||</span> (
        $a<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>] <span style="color:#e6db74">&lt;=&gt;</span> $b<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>]
    )
} @sets;

<span style="color:#66d9ef">my</span> $cur <span style="color:#f92672">=</span> undef;
<span style="color:#66d9ef">my</span> $i   <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e"># cleaner than for loop, IMHO</span>
<span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $nxt (@sets) {
    <span style="color:#66d9ef">if</span> (
           <span style="color:#f92672">!</span>$cur <span style="color:#75715e"># start</span>
        <span style="color:#f92672">||</span> $cur<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&lt;</span> $nxt<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] <span style="color:#75715e"># no overlap, increment</span>
    ) {
        $cur <span style="color:#f92672">=</span> $nxt;
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#75715e"># part overlap, next interval ends after current</span>
        <span style="color:#66d9ef">if</span> ($cur<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&lt;</span> $nxt<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>]) {
            <span style="color:#75715e"># current takes end of next</span>
            $cur<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> $nxt<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>];
        }
        <span style="color:#75715e"># consume next</span>
        splice @sets, $i, <span style="color:#ae81ff">1</span>;
    }
    $i<span style="color:#f92672">++</span>;
}
<span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;Merged:\n&#34;</span> <span style="color:#f92672">.</span> dumpSets(@sets);
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">dumpSets</span> { <span style="color:#75715e"># convenience for printing sets of intervals</span>
    <span style="color:#66d9ef">return</span> join(<span style="color:#e6db74">&#39;, &#39;</span>,
        map { <span style="color:#e6db74">&#39;[&#39;</span> <span style="color:#f92672">.</span> $_<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">.</span> <span style="color:#e6db74">&#39;, &#39;</span> <span style="color:#f92672">.</span> $_<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">.</span> <span style="color:#e6db74">&#39;]&#39;</span> } @_
    ) <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34;\n&#34;</span>;
}
</code></pre></div><p>This O(<em>n</em> log <em>n</em>) solution is clean, and works well.</p>
<h2 id="southpawgeek1">Jen Guerra</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/southpawgeek/perl/ch-1.pl">Jen Guerra&rsquo;s solution</a> features a lot of debug statements and internal documentation which paint a picture of exactly how the merge happens. I&rsquo;ve removed those statements so we can take a higher level look at the algorithm, but please click the solution link if you want to see the original. Here is the <code>merge</code> sub that does it all:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">merge</span> {
    <span style="color:#66d9ef">my</span> $set <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">my</span> @ints <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;@$set&#34;</span> <span style="color:#f92672">=~</span><span style="color:#e6db74"> /(-?\d+)/g</span>;
    <span style="color:#66d9ef">my</span> %no_same_lo;
    <span style="color:#66d9ef">while</span> (@ints) {
        <span style="color:#66d9ef">my</span> $lo <span style="color:#f92672">=</span> shift @ints;
        <span style="color:#66d9ef">my</span> $hi <span style="color:#f92672">=</span> shift @ints;
        ($lo, $hi) <span style="color:#f92672">=</span> ($hi, $lo) <span style="color:#66d9ef">if</span> $lo <span style="color:#f92672">&gt;</span> $hi;
        $no_same_lo{$lo} <span style="color:#f92672">=</span> $hi
            <span style="color:#66d9ef">unless</span> defined($no_same_lo{$lo} <span style="color:#f92672">&amp;&amp;</span> $no_same_lo{$lo} <span style="color:#f92672">&lt;=</span> $hi);
    }
    <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $lo (sort {$a <span style="color:#e6db74">&lt;=&gt;</span> $b} keys %no_same_lo) {
        push @ints, ($lo, $no_same_lo{$lo});
    }
</code></pre></div><p>So, we now have an array of intervals (<code>@ints</code>) that has been <code>sort</code>ed numerically by lower bound. Below, Jen will build up the <code>@merged</code> array with a linear traversal through <code>@ints</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span> @merged;
    <span style="color:#66d9ef">my</span> ($lo, $hi);
    <span style="color:#66d9ef">while</span> (scalar @ints) {
        $lo <span style="color:#f92672">=</span> shift @ints;
        $hi <span style="color:#f92672">=</span> shift @ints;
        <span style="color:#66d9ef">if</span> (scalar @ints) {
            <span style="color:#66d9ef">my</span> $nextlo <span style="color:#f92672">=</span> shift @ints;
            <span style="color:#66d9ef">my</span> $nexthi <span style="color:#f92672">=</span> shift @ints;
            <span style="color:#66d9ef">if</span> ($hi <span style="color:#f92672">&gt;=</span> $nextlo) {
                $nexthi <span style="color:#f92672">=</span> $hi <span style="color:#66d9ef">if</span> $hi <span style="color:#f92672">&gt;</span> $nexthi;
                unshift @ints, ($lo, $nexthi);
                $hi <span style="color:#f92672">=</span> $nexthi;
            } <span style="color:#66d9ef">else</span> {
                push @merged, <span style="color:#e6db74">&#34;[$lo,$hi]&#34;</span>;
                unshift @ints, ($nextlo, $nexthi);
            }
        } <span style="color:#66d9ef">else</span> {
            push @merged, <span style="color:#e6db74">&#34;[$lo,$hi]&#34;</span>;
        }
    }
    say <span style="color:#e6db74">&#34;@merged is the merged set. \n&#34;</span>;
}
</code></pre></div><p>Jen has once again demonstrated an ability to produce a well-crafted and efficient solution. While I omitted the more verbose comments and debug statements to better fit this review format, I did appreciate them!</p>
<h2 id="user-person1">User Person</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/user-person/perl/ch-1.pl">User Person&rsquo;s solution</a> begins with an input and parsing section that builds up the initial <code>@sets</code> of intervals:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">use</span> List::MoreUtils <span style="color:#e6db74">qw( minmax )</span>;
<span style="color:#66d9ef">my</span> $input <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;[2,7], [3,9], [10,12], [15,19], [18,22]&#34;</span>;
$input <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;@ARGV&#34;</span> <span style="color:#66d9ef">if</span> @ARGV;
$input <span style="color:#f92672">=~</span> <span style="color:#e6db74">s{[][, ]+}{ }g</span>;
$input <span style="color:#f92672">=~</span> <span style="color:#e6db74">s{\A\s+|\s+\Z}{}</span>;
<span style="color:#66d9ef">my</span> @sets <span style="color:#f92672">=</span> split <span style="color:#e6db74">m{ }</span>, $input;
<span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;UNMERGED:\n&#34;</span>;
printSets @sets;
</code></pre></div><p><code>printSets</code> (not shown) is a helper that pretty-prints the array of intervals. The <code>mergeUnits</code> sub is another helper, which merges two intervals (given by their index into <code>@sets</code>), with the help of <code>splice</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">mergeUnits</span> {
    <span style="color:#66d9ef">my</span> @indicies <span style="color:#f92672">=</span> @_;
    <span style="color:#66d9ef">my</span> ($min, $max) <span style="color:#f92672">=</span> minmax ( $sets[$indicies[<span style="color:#ae81ff">0</span>]], $sets[$indicies[<span style="color:#ae81ff">1</span>]], $sets[$indicies[<span style="color:#ae81ff">2</span>]], $sets[$indicies[<span style="color:#ae81ff">3</span>]] );
    push @sets, $min;
    push @sets, $max;
    <span style="color:#66d9ef">foreach</span> ( sort { $b <span style="color:#e6db74">&lt;=&gt;</span> $a } @indicies ) {
        splice @sets, $_, <span style="color:#ae81ff">1</span>;
    }
}
</code></pre></div><p>Finally, User Person uses an O(n²) nested loop to compare and merge the intervals:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">OUTER:
<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">my</span> $j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; $j <span style="color:#f92672">&lt;</span> $#sets; $j <span style="color:#f92672">+=</span> <span style="color:#ae81ff">2</span>) {
    <span style="color:#66d9ef">for</span> ( <span style="color:#66d9ef">my</span> $k<span style="color:#f92672">=</span>$j<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>; $k <span style="color:#f92672">&lt;</span> $#sets; $k <span style="color:#f92672">+=</span> <span style="color:#ae81ff">2</span>) {
        <span style="color:#66d9ef">if</span> ( $sets[$k] <span style="color:#f92672">&gt;=</span> $sets[$j] <span style="color:#f92672">and</span> $sets[$k] <span style="color:#f92672">&lt;=</span> $sets[$j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]
                     <span style="color:#f92672">or</span> $sets[$k<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">&gt;=</span> $sets[$j] <span style="color:#f92672">and</span> $sets[$k<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">&lt;=</span> $sets[$j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] ) {
            mergeUnits $j, $j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, $k, $k<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
            $j <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>;            <span style="color:#75715e"># This resets OUTER loop to 0 after its double increment</span>
            <span style="color:#66d9ef">next</span> OUTER;
        }
    }
}
</code></pre></div><p>There is a little bit of optimization, here, to avoid some unnecessary looping.</p>
<h2 id="wanderdoc1">Wanderdoc</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/wanderdoc/perl/ch-1.pl">Wanderdoc&rsquo;s solution</a> is essentially an unrolling algorithm. Wanderdoc creates an array of <a href="https://metacpan.org/pod/Bit::Vector"><code>Bit::Vector</code></a>s in <code>@veclist</code> (one for each interval in the sorted <code>@intervals</code>), and sets the bits in each of them that correspond to the numbers in the interval:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">use</span> Bit::Vector;
<span style="color:#66d9ef">use</span> List::Util <span style="color:#e6db74">qw(max)</span>;
<span style="color:#66d9ef">my</span> @intervals <span style="color:#f92672">=</span> ( [ <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">7</span> ], [ <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">9</span> ], [ <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">12</span> ], [ <span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">19</span> ], [ <span style="color:#ae81ff">18</span>, <span style="color:#ae81ff">22</span> ] );

<span style="color:#75715e"># Pushing of, say, [10, 35] would not otherwise work correctly</span>
@intervals <span style="color:#f92672">=</span> sort { $a<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] <span style="color:#e6db74">&lt;=&gt;</span> $b<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] } @intervals;
<span style="color:#66d9ef">my</span> $max     <span style="color:#f92672">=</span> max( map @$_, @intervals );
<span style="color:#66d9ef">my</span> @veclist <span style="color:#f92672">=</span> Bit::Vector<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">new</span>( $max <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, scalar @intervals );
$veclist[$_]<span style="color:#f92672">-&gt;</span>Interval_Fill( @{ $intervals[$_] } ) <span style="color:#66d9ef">for</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $#veclist;
</code></pre></div><p>An empty result vector is created from an arbitrary member of <code>@veclist</code> with <code>$veclist[0]-&gt;Shadow</code>. Wanderdoc then iterates through <code>@veclist</code> and essentially calculates the union of all vectors by <code>-&gt;Or()</code>ing them together. However, to avoid merging adjacent intervals such as <code>[3,9]</code> and <code>[10,12]</code>, Wanderdoc needs a little extra logic to separate the results:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> @results;
<span style="color:#66d9ef">my</span> $res <span style="color:#f92672">=</span> $veclist[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">-&gt;</span>Shadow();
<span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $v (@veclist) {
    <span style="color:#66d9ef">if</span> ( $res<span style="color:#f92672">-&gt;</span>is_empty() ) {
        $res<span style="color:#f92672">-&gt;</span>Or( $res, $v );
    }
    <span style="color:#66d9ef">else</span> {
        <span style="color:#75715e"># to prevent merging [3,9] and [10,12].</span>
        <span style="color:#66d9ef">if</span> ( $v<span style="color:#f92672">-&gt;</span>Min() <span style="color:#f92672">&lt;</span> $res<span style="color:#f92672">-&gt;</span>Max() ) {
            $res<span style="color:#f92672">-&gt;</span>Or( $res, $v );
        }
        <span style="color:#66d9ef">else</span> {
            <span style="color:#66d9ef">my</span> $res_p <span style="color:#f92672">=</span> $res<span style="color:#f92672">-&gt;</span>Clone();
            push @results, $res_p;
            $res<span style="color:#f92672">-&gt;</span>Empty();
            $res<span style="color:#f92672">-&gt;</span>Or( $res, $v );
        }
    }
}
push @results, $res;
<span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#39;[&#39;</span> <span style="color:#f92672">.</span> $_<span style="color:#f92672">-&gt;</span>to_Enum() <span style="color:#f92672">.</span> <span style="color:#e6db74">&#39;]&#39;</span> <span style="color:#66d9ef">for</span> @results;
</code></pre></div><h2 id="yet-ebreo1">Yet Ebreo</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/yet-ebreo/perl/ch-1.pl">Yet Ebreo&rsquo;s solution</a> starts by <code>sort</code>ing the list of intervals, and then uses an O(n²) nested loop to find the intervals to be merged:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> @skip;
<span style="color:#66d9ef">my</span> @output;
<span style="color:#66d9ef">my</span> @range <span style="color:#f92672">=</span> ([<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">12</span>], [<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">7</span>], [<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">9</span>], [<span style="color:#ae81ff">15</span>,<span style="color:#ae81ff">19</span>], [<span style="color:#ae81ff">18</span>,<span style="color:#ae81ff">22</span>], [<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">3</span>]);
@range <span style="color:#f92672">=</span> sort { @{$a}[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">-</span> @{$b}[<span style="color:#ae81ff">0</span>] } @range;
<span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $n (<span style="color:#ae81ff">0</span><span style="color:#f92672">..~-</span>@range) {
    <span style="color:#75715e">#Store interval in $o and $p then consider $p as $max</span>
    <span style="color:#66d9ef">my</span> ($o,$p) <span style="color:#f92672">=</span> @{$range[$n]};
    <span style="color:#66d9ef">my</span> $max <span style="color:#f92672">=</span> $p;
    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $m ($n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">..~-</span>@range) {
        <span style="color:#75715e">#Check next interval save to $q and $r</span>
        <span style="color:#66d9ef">my</span> ($q,$r) <span style="color:#f92672">=</span> @{$range[$m]};
        <span style="color:#75715e">#then check if $q is in between $o and $p</span>
        <span style="color:#66d9ef">if</span> (($q<span style="color:#f92672">&gt;</span>$o) <span style="color:#f92672">&amp;&amp;</span> ($q<span style="color:#f92672">&lt;=</span>$p)) {
            <span style="color:#75715e">#Consider $r as max if $r &gt; $max</span>
            $max <span style="color:#f92672">=</span> $r <span style="color:#66d9ef">if</span> $r<span style="color:#f92672">&gt;</span>$max;
            <span style="color:#75715e">#Remove interval $m from list (by adding it in @skip array)</span>
            push @skip, $m
        }
    }
    <span style="color:#75715e">#Update output with the new interval if</span>
    <span style="color:#75715e">#$n can not be found in &#34; @skip &#34; using regex</span>
    <span style="color:#e6db74">&#34; @skip &#34;</span> <span style="color:#f92672">!~</span> <span style="color:#e6db74">/ $n /</span> <span style="color:#f92672">&amp;&amp;</span> push @output, [$o,$max];
}
</code></pre></div><h3 id="a-note-on--">A note on <code>~-</code></h3>
<p>One thing that you don&rsquo;t see much outside of code golf is an expression like <code>~-@range</code>. For the uninitiated, this is colloquially known as the &ldquo;inchworm-on-a-stick&rdquo; operator, and has roots that predate Perl. From the context, you might correctly guess that the loop is iterating over the indices of <code>@range</code>, but it may not be immediately obvious <em>why</em> that works:</p>
<p>The <code>~-</code> operators (i.e., unary <code>~</code> and unary <code>-</code>) are together doing a sort of double negation of the scalar value of <code>@foo</code> with two different binary number representations. Let&rsquo;s say <code>@foo</code> has 3 elements, so <code>-@foo == -3</code>. Why does <code>~(-@foo) == ~(-3) == 2</code>?</p>
<p><code>~</code> does a <a href="https://en.wikipedia.org/wiki/Ones%27_complement">ones complement negation</a>, but <code>-</code> (at least on all the CPUs I have that can run Perl) is twos complement. See also <a href="https://perldoc.perl.org/perlop.html#Symbolic-Unary-Operators"><code>perlop</code></a> and <a href="https://perldoc.perl.org/perlnumber.html#Storing-numbers"><code>perlnumber</code></a>.</p>
<pre><code>      Expr   Decimal  Binary
   --------+--------+-----------------------
      @foo |    3   | 0000 ... 0011
     -@foo |   -3   | 1111 ... 1101 (2's c!)
    ~-@foo |    2   | 0000 ... 0010 (1's c!)
</code></pre><p>Personally, I&rsquo;d go with the purpose-built <code>$#foo</code> to get the same result and even save a keystroke, but to each their own! That being said, I&rsquo;ll take almost any excuse to dive into a discussion on integer representations.</p>
<hr>
<hr>
<h1 id="task2">Task #2 - Noble Integer</h1>
<p>Here is Mohammad&rsquo;s description, in part:</p>
<p><em>You are given a list, @L, of three or more random integers between 1 and 50.  A Noble Integer is an integer N in @L, such that there are exactly N integers greater than N in @L. Output any Noble Integer found in @L, or an empty list if none were found.</em></p>
<p>Note that although Mohammad gave me credit for contributing this task, all I really did was suggest some wording changes.</p>
<h2 id="types-of-solutions">Types of solutions</h2>
<h3 id="nested-list-on">Nested List O(n²)</h3>
<p>This approach involves iterating through the list of integers, and then having an inner loop iterate through again to count how many integers are greater than the current integer. It&rsquo;s a straightforward O(n²) solution.</p>
<h3 id="sort-then-loop">Sort, then loop</h3>
<p>By <code>sort</code>ing the list of integers first, you can avoid the inner loop altogether, and subtract the index of the integer from the last array index (<code>$#L</code>) to get the number of integers greater than the current one. For example, if the (sorted) list is <code>1 2 4 8</code>, the array (and its indices) looks like this:</p>
<pre><code>    idx | $L[idx]
    ----+-------
     0  |    1
     1  |    2
     2  |    4
     3  |    8
</code></pre><p>Thus, 2 (<code>$L[1]</code>) is a Noble Integer in this list, because <code>$L[$idx] == $#L - $idx</code>, or <code>2 == 3 - 1</code>. That is the basis of this O(<em>n</em> log <em>n</em>) algorithm.</p>
<h2 id="can-there-be-multiple-noble-integers">Can there be multiple Noble integers?</h2>
<p>Several hackers took the time to answer the question of whether a list can contain multiple Noble integers, either in a code comment, or a blog entry. The short answer is, &ldquo;no&rdquo;.</p>
<p>The slightly longer answer, summarized from my <a href="http://www.ry.ca/2020/03/noble-integers/">blog post</a> is that if there is a Noble integer <em>n</em> in a list <em>L</em>, there are also <em>n</em> integers greater than <em>n,</em> by definition. Now suppose there is a second Noble integer, <em>x,</em> with <em>x</em> &gt; <em>n.</em> That would mean there are at least <em>n</em> + 1 integers greater than <em>n,</em> but there are only <em>n</em> integers greater than <em>n,</em> so there is a contradiction, and, therefore there cannot be more than one Noble integer in a list.</p>
<hr>
<h2 id="alexander-karelas2">Alexander Karelas</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/alexander-karelas/perl/ch-2.pl">Alexander Karelas&rsquo;s solution</a> first sorts the list, and then iterates through it to look for a number where the <code>$i</code>th element of <code>@l</code> equals <code>$i</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> @L <span style="color:#f92672">=</span> (<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>);
<span style="color:#66d9ef">my</span> @l <span style="color:#f92672">=</span> sort { $b <span style="color:#e6db74">&lt;=&gt;</span> $a } @L;
<span style="color:#66d9ef">my</span> $noble;
<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">my</span> $i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; $i <span style="color:#f92672">&lt;</span> @l <span style="color:#f92672">and</span> $l[$i] <span style="color:#f92672">&gt;=</span> $i; $i<span style="color:#f92672">++</span>) {
    $noble <span style="color:#f92672">=</span> $i <span style="color:#66d9ef">if</span> $l[$i] <span style="color:#f92672">==</span> $i;
}
say defined $noble ? <span style="color:#e6db74">&#34;Noble integer is: $noble&#34;</span> : <span style="color:#e6db74">&#34;There is no noble integer in this set&#34;</span>;
</code></pre></div><h2 id="alicia-bielsa2">Alicia Bielsa</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/alicia-bielsa/perl/ch-2.pl">Alicia Bielsa&rsquo;s solution</a> has a <code>findNobleIntegers</code> sub that does exactly what it says:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">findNobleIntegers</span> {
    <span style="color:#66d9ef">my</span> @aIntegers <span style="color:#f92672">=</span> @_;
    <span style="color:#66d9ef">my</span> @aNoble    <span style="color:#f92672">=</span> ();
    <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $integer (@aIntegers) {
        <span style="color:#66d9ef">my</span> $countGreater <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $integerToCompare (@aIntegers) {
            <span style="color:#66d9ef">if</span> ( $integerToCompare <span style="color:#f92672">&gt;</span> $integer ) {
                $countGreater<span style="color:#f92672">++</span>;
            }
        }
        <span style="color:#66d9ef">if</span> ( $integer <span style="color:#f92672">==</span> $countGreater ) {
            push( @aNoble, $integer );
        }
    }
    <span style="color:#66d9ef">return</span> @aNoble;
}
</code></pre></div><p>Alicia&rsquo;s code uses a nested loop to check whether <code>$integer</code> has exactly <code>$integer</code> numbers greater than itself in the list. This approach avoids the <code>sort</code>, but at the cost of O(n²) efficiency. For small lists, there will not be much difference, however.</p>
<h2 id="andrezgz2">Andrezgz</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/andrezgz/perl/ch-2.pl">Andrezgz&rsquo;s solution</a> first sorts the list, and then uses a nested loop to count the number of greater integers:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> $elements <span style="color:#f92672">=</span> shift <span style="color:#f92672">||</span> <span style="color:#ae81ff">3</span>;
<span style="color:#66d9ef">my</span> @L <span style="color:#f92672">=</span> sort {$a <span style="color:#e6db74">&lt;=&gt;</span> $b} map { int(rand(<span style="color:#ae81ff">49</span>)) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> } <span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$elements;
<span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#39;List: &#39;</span> <span style="color:#f92672">.</span> join <span style="color:#e6db74">&#39;,&#39;</span>, @L;
<span style="color:#66d9ef">my</span> @nobles;
<span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $n (@L) {
    <span style="color:#66d9ef">my</span> $greater <span style="color:#f92672">=</span> grep { $_ <span style="color:#f92672">&gt;</span> $n} @L;
    push @nobles, $n <span style="color:#66d9ef">if</span> $greater <span style="color:#f92672">==</span> $n;
}
<span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;\nNoble Integers: &#34;</span>, join <span style="color:#e6db74">&#39;,&#39;</span>, @nobles;
</code></pre></div><h2 id="cheok-yin-fung2">Cheok-Yin Fung</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/cheok-yin-fung/perl/ch-2.pl">Cheok-Yin Fung&rsquo;s solution</a> first sorts the list, and then uses array indices to determine whether a number is Noble or not:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> @L <span style="color:#f92672">=</span> @ARGV; <span style="color:#75715e">#usage: perl ch-2.pl 2 6 1 3</span>
@L <span style="color:#f92672">=</span> sort {$a <span style="color:#e6db74">&lt;=&gt;</span> $b} @L;
<span style="color:#66d9ef">my</span> $i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
<span style="color:#66d9ef">while</span> ($i<span style="color:#f92672">&lt;=</span>$#L) {
    <span style="color:#66d9ef">if</span> ($L[$i] <span style="color:#f92672">==</span> $#L<span style="color:#f92672">-</span>$i ) {<span style="color:#66d9ef">print</span> $L[$i]; exit;}
    $i<span style="color:#f92672">++</span>;
}
<span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;-1&#34;</span>;
</code></pre></div><h2 id="colin-crain2">Colin Crain</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/colin-crain/perl/ch-2.pl">Colin Crain&rsquo;s solution</a>, in Colin&rsquo;s typical style I like so much, includes a rather robust (112 line) comment at the top of the code, which is well worth a read, and a chuckle or two. That comment includes a solid proof for the question of whether a list can have multiple Noble integers or not, with his own <a href="https://en.wikipedia.org/wiki/Color_commentator">colour commentary</a>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> @list <span style="color:#f92672">=</span> make_list();
<span style="color:#66d9ef">my</span> ($noble) <span style="color:#f92672">=</span> grep { validate($_, @list) } @list;
<span style="color:#75715e">## output</span>
say scalar @list, <span style="color:#e6db74">&#34; elements generated&#34;</span>;
say join <span style="color:#e6db74">&#39;, &#39;</span>, @list;
say $noble ? <span style="color:#e6db74">&#34;the number $noble is the Noble Integer&#34;</span>
           : <span style="color:#e6db74">&#34;there is no Noble Integer for this list&#34;</span>;

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">validate</span> {
<span style="color:#75715e">## given a scalar and a list, returns true if the number of list elements greater than the</span>
<span style="color:#75715e">## scalar is equal to the scalar</span>
    <span style="color:#66d9ef">my</span> ($candidate, @list) <span style="color:#f92672">=</span> @_;
    <span style="color:#66d9ef">return</span> scalar( grep { $candidate <span style="color:#f92672">&lt;</span> $_ } @list ) <span style="color:#f92672">==</span> $candidate ? <span style="color:#ae81ff">1</span> : <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>Colin has gone with the O(n²) nested loop approach, as <code>validate</code> is called from the top-level <code>grep</code> on line 2.</p>
<h2 id="cristian-heredia2">Cristina Heredia</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/cristian-heredia/perl/ch-2.pl">Cristina Heredia&rsquo;s solution</a> uses an O(n²) nested loop to find the Noble integer, if it exists:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">analizeArray</span> {
    <span style="color:#66d9ef">for</span> ( <span style="color:#66d9ef">my</span> $j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> ; $j <span style="color:#f92672">&lt;</span> $sizeArray ; $j<span style="color:#f92672">++</span> ) {
        <span style="color:#66d9ef">for</span> ( <span style="color:#66d9ef">my</span> $k <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> ; $k <span style="color:#f92672">&lt;</span> $sizeArray ; $k<span style="color:#f92672">++</span> ) {
            <span style="color:#66d9ef">if</span> ( $j <span style="color:#f92672">==</span> $k ) {
            }
            <span style="color:#66d9ef">elsif</span> ( $array[$j] <span style="color:#f92672">&lt;</span> $array[$k] ) {
                $total<span style="color:#f92672">++</span>;
            }
        }
        <span style="color:#66d9ef">if</span> ( $total <span style="color:#f92672">eq</span> $array[$j] ) {
            $result <span style="color:#f92672">=</span> $result <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34;$array[$j] &#34;</span>;
        }
        $total <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    }
    resultMessage();
}
</code></pre></div><h2 id="dave-cross2">Dave Cross</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/dave-cross/perl/ch-2.pl">Dave Cross&rsquo;s solution</a> O(n²) nested loop is neat and concise:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i (@ARGV) {
    say <span style="color:#e6db74">&#34;$i is a Noble Integer&#34;</span> <span style="color:#66d9ef">if</span> scalar (grep { $_ <span style="color:#f92672">&gt;</span> $i } @ARGV) <span style="color:#f92672">==</span> $i;
}
</code></pre></div><h2 id="dave-jacoby2">Dave Jacoby</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/dave-jacoby/perl/ch-2.pl">Dave Jacoby&rsquo;s solution</a> sorts the list, and then does an O(n²) nested loop to find the Noble integer:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">use</span> feature <span style="color:#e6db74">qw{ postderef say signatures state switch }</span>;
<span style="color:#66d9ef">no</span> warnings
  <span style="color:#e6db74">qw{ experimental::postderef experimental::smartmatch experimental::signatures }</span>;
<span style="color:#66d9ef">use</span> List::Util <span style="color:#e6db74">qw{ uniq }</span>;

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">nobles</span> ( @list ) {
    <span style="color:#66d9ef">my</span> @copy <span style="color:#f92672">=</span> @list;
    @list <span style="color:#f92672">=</span> uniq sort { $a <span style="color:#e6db74">&lt;=&gt;</span> $b } @list;
    <span style="color:#66d9ef">my</span> @output;
    <span style="color:#66d9ef">while</span> (@list) {
        <span style="color:#66d9ef">my</span> $i <span style="color:#f92672">=</span> shift @list;
        <span style="color:#66d9ef">my</span> @i <span style="color:#f92672">=</span> grep { $_ <span style="color:#f92672">==</span> $i } @copy;
        push @output, @i <span style="color:#66d9ef">if</span> $i <span style="color:#f92672">==</span> scalar @list;
    }
    <span style="color:#66d9ef">return</span> @output;
}
</code></pre></div><p><strong>Blog</strong> › <a href="https://jacoby.github.io/2020/03/02/perl-challenge-50.html">Perl Challenge #50</a></p>
<h2 id="duncan-c-white2">Duncan C. White</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/duncan-c-white/perl/ch-2.pl">Duncan C. White&rsquo;s solution</a> starts by finding the unique integers in the given list (in this case, <code>@ARGV</code>):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">use</span> Function::Parameters;
<span style="color:#75715e"># remove duplicate items by turning list into set..</span>
<span style="color:#66d9ef">my</span> %set <span style="color:#f92672">=</span> map { $_ <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">1</span> } @ARGV;
<span style="color:#75715e"># and finding the (distinct) keys of that set..</span>
<span style="color:#66d9ef">my</span> @l <span style="color:#f92672">=</span> keys %set;
<span style="color:#66d9ef">my</span> @noble <span style="color:#f92672">=</span> find_all_noble( @l );
</code></pre></div><p>Then, the <code>find_all_noble</code> function uses a nested loop to find the answer:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">say <span style="color:#e6db74">&#34;noble: $_&#34;</span> <span style="color:#66d9ef">for</span> @noble;
fun find_all_noble( @l ) {
    <span style="color:#66d9ef">my</span> @noble;
    <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $element (@l) {
        <span style="color:#66d9ef">my</span> $ngt <span style="color:#f92672">=</span> grep { $_ <span style="color:#f92672">&gt;</span> $element } @l;
        push @noble, $element <span style="color:#66d9ef">if</span> $element <span style="color:#f92672">==</span> $ngt;
    }
    <span style="color:#66d9ef">return</span> @noble;
}
</code></pre></div><h2 id="e-choroba2">E. Choroba</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/e-choroba/perl/ch-2.pl">E. Choroba&rsquo;s solution</a> sorts the input list and uses the array indices to determine the number of integers greater than <code>$s[$i]</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">noble_integer</span> {
    <span style="color:#66d9ef">my</span> @s <span style="color:#f92672">=</span> sort { $b <span style="color:#e6db74">&lt;=&gt;</span> $a } @_;
    <span style="color:#66d9ef">my</span> $c <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">my</span> @noble;
    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i (<span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $#s) {
        push @noble, $s[$i] <span style="color:#66d9ef">if</span> $c <span style="color:#f92672">==</span> $s[$i];
        <span style="color:#f92672">++</span>$c <span style="color:#66d9ef">if</span> $s[$i] <span style="color:#f92672">!=</span> ($s[$i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#e6db74">//</span> $s[$i] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
    }
    <span style="color:#66d9ef">return</span> @noble
}
</code></pre></div><p>There is also handling of duplicate integers, which is a nice touch. Choroba&rsquo;s blog also correctly speaks to the possibility of multiple Noble integers in a list.</p>
<p><strong>Blog</strong> › <a href="http://blogs.perl.org/users/e_choroba/2020/03/perl-weekly-challenge-050-merge-intervals-and-noble-integer.html">Merge Intervals and Noble Integer</a></p>
<h2 id="ianrifkin2">Ian Rifkin</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/ianrifkin/perl/ch-2.pl">Ian Rifkin&rsquo;s solution</a> sorts and uses array indices to count the number of integers greater than the current one, <code>$L[$pos]</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#75715e"># Solution by Ian Rifkin</span>
<span style="color:#66d9ef">my</span> @L <span style="color:#f92672">=</span> (<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>); <span style="color:#75715e">#List of number inputs</span>
@L <span style="color:#f92672">=</span> sort { $a <span style="color:#e6db74">&lt;=&gt;</span> $b } @L; <span style="color:#75715e">#Sort numerically</span>
<span style="color:#66d9ef">my</span> $length <span style="color:#f92672">=</span> scalar @L;
<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">my</span> $pos <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; $pos <span style="color:#f92672">&lt;</span> $length; $pos<span style="color:#f92672">++</span>) {
    <span style="color:#75715e">#found a noble integer if it&#39;s value is equal to the amount of numbers after it</span>
    say <span style="color:#e6db74">&#34;Noble integer found: $L[$pos]&#34;</span> <span style="color:#66d9ef">if</span> $L[$pos] <span style="color:#f92672">==</span> $length <span style="color:#f92672">-</span> $pos <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
}
</code></pre></div><p>The C-style loop is fine, here, but could also be replaced by a more concise and Perlish <code>for my $pos (0..$#L)</code>. But <a href="https://en.wikipedia.org/wiki/There%27s_more_than_one_way_to_do_it">TIMTOWTDI</a>, of course!</p>
<h2 id="jaldhar-h-vyas2">Jaldhar H. Vyas</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/jaldhar-h-vyas/perl/ch-2.pl">Jaldhar H. Vyas&rsquo;s solution</a> is a concise array-index based implementation:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> @L <span style="color:#f92672">=</span> sort @ARGV;
<span style="color:#66d9ef">my</span> $size <span style="color:#f92672">=</span> scalar @L;
<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">my</span> $n <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; $n <span style="color:#f92672">&lt;</span> $size; $n<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">if</span> ($L[$n] <span style="color:#f92672">==</span> $size <span style="color:#f92672">-</span> $n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) {
        say $L[$n];
    }
}
</code></pre></div><p>Again, <code>for my $n (0..$#L)</code> would be my choice, but that is merely a stylistic choice.</p>
<h2 id="javier-luque2">Javier Luque</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/javier-luque/perl/ch-2.pl">Javier Luque&rsquo;s solution</a> also sorts numerically and uses array indices to his advantage:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#75715e"># Create @L</span>
<span style="color:#66d9ef">my</span> @L <span style="color:#f92672">=</span> sort { $a <span style="color:#e6db74">&lt;=&gt;</span> $b } map { int(rand(<span style="color:#ae81ff">50</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) } ( <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> <span style="color:#ae81ff">50</span> );
<span style="color:#66d9ef">my</span> $i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#66d9ef">my</span> $total <span style="color:#f92672">=</span> scalar(@L);
<span style="color:#75715e"># Output the list</span>
say <span style="color:#e6db74">&#34;List: &#34;</span> <span style="color:#f92672">.</span> join <span style="color:#e6db74">&#39;, &#39;</span>, @L;
<span style="color:#75715e"># Loop through each number</span>
<span style="color:#66d9ef">while</span> ($i <span style="color:#f92672">&lt;</span> $total) {
    <span style="color:#75715e"># Skip duplicates</span>
    <span style="color:#66d9ef">if</span> ($i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span> $total <span style="color:#f92672">&amp;&amp;</span> $L[$i] <span style="color:#f92672">!=</span> $L[$i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]) {
        say <span style="color:#e6db74">&#34;Noble number found: &#34;</span> <span style="color:#f92672">.</span> $L[$i]
            <span style="color:#66d9ef">if</span> ($L[$i] <span style="color:#f92672">==</span> $total <span style="color:#f92672">-</span> $i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
    }
    $i<span style="color:#f92672">++</span>;
}
</code></pre></div><p>Javier also has a good description of why there <em>can</em> be more than one Noble integer per list if duplicates are allowed, on his blog:</p>
<p><strong>Blog</strong> › <a href="https://perlchallenges.wordpress.com/2020/03/02/perl-weekly-challenge-050/">050 – Perl Weekly Challenge</a></p>
<h2 id="laurent-rosenfeld2">Laurent Rosenfeld</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/laurent-rosenfeld/perl/ch-2.pl">Laurent Rosenfeld&rsquo;s solution</a> sorts his <code>@list</code> in <em>reverse</em> numerical order, which reduces the array index calculation to <code>$list[$_] == $_</code>. I love little simplifications like this.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> $list_size <span style="color:#f92672">=</span> int(rand <span style="color:#ae81ff">10</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">3</span>;
<span style="color:#66d9ef">my</span> @list <span style="color:#f92672">=</span> map {int(rand <span style="color:#ae81ff">50</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> } <span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$list_size;
say $list_size, <span style="color:#e6db74">&#34;/&#34;</span>, <span style="color:#e6db74">&#34;@list&#34;</span>;
<span style="color:#75715e"># my @list = (2, 6, 1, 3,5, 8);</span>
@list <span style="color:#f92672">=</span> sort {$b <span style="color:#e6db74">&lt;=&gt;</span> $a} @list; <span style="color:#75715e">#descending sort</span>
say $list_size, <span style="color:#e6db74">&#34; / &#34;</span>, <span style="color:#e6db74">&#34;@list&#34;</span>;
<span style="color:#66d9ef">for</span> (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$#list) {
    say <span style="color:#e6db74">&#34;$list[$_] is noble.&#34;</span> <span style="color:#66d9ef">if</span> $list[$_] <span style="color:#f92672">==</span> $_;
}
</code></pre></div><p><strong>Blog</strong> › <a href="http://blogs.perl.org/users/laurent_r/2020/03/perl-weekly-challenge-merge-inrervals-and-noble-numbers.html">Merge [Intervals] and Noble Numbers</a></p>
<h2 id="mohammad-anwar2">Mohammad S Anwar</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/mohammad-anwar/perl/ch-2.pl">Mohammad S Anwar&rsquo;s solution</a> uses a new version of <a href="https://metacpan.org/pod/List::Util#sample"><code>List::Util</code></a> from CPAN to access the new <code>sample</code> sub introduced in last month&rsquo;s 1.54 release. <code>sample</code> is used here to generate a list of random integers:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">use</span> List::Util <span style="color:#ae81ff">1.54</span> <span style="color:#e6db74">qw(sample)</span>;
<span style="color:#66d9ef">my</span> $COUNT <span style="color:#f92672">=</span> $ARGV[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">||</span> <span style="color:#ae81ff">3</span>;
<span style="color:#66d9ef">my</span> @L <span style="color:#f92672">=</span> sort { $a <span style="color:#e6db74">&lt;=&gt;</span> $b } sample ($COUNT, (<span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> <span style="color:#ae81ff">50</span>));
</code></pre></div><p>I appreciate Mohammad highlighting new features in common modules. I look forward to <code>sample</code> making its way into the core Perl version of <code>List::Util</code>. For my review purposes, since I&rsquo;m stuck offline and have an older <code>List::Util</code>, I had to modify the above code as follows:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#75715e"># Ryan&#39;s hack</span>
<span style="color:#66d9ef">use</span> List::Util <span style="color:#e6db74">qw&lt; uniq &gt;</span>;
<span style="color:#66d9ef">my</span> @L <span style="color:#f92672">=</span> uniq sort { $a <span style="color:#e6db74">&lt;=&gt;</span> $b } map { <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> int rand(<span style="color:#ae81ff">50</span>) } <span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$COUNT;
</code></pre></div><p>(I may end up with less than <code>$COUNT</code> items, but that&rsquo;s not important enough to fix.)</p>
<p>Here is the actual <code>find_noble_number</code> sub, which uses a nested loop for the O(n²) approach:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">find_noble_number</span> {
    <span style="color:#66d9ef">my</span> (@L) <span style="color:#f92672">=</span> @_;
    <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $N (@L) {
        <span style="color:#66d9ef">return</span> $N <span style="color:#66d9ef">if</span> (scalar( grep { $_ <span style="color:#f92672">&gt;</span> $N } @L ) <span style="color:#f92672">==</span> $N);
    }
    <span style="color:#66d9ef">return</span>;
}
</code></pre></div><p><strong>Blog</strong> › <a href="https://perlweeklychallenge.org/blog/weekly-challenge-050/">BLOG: The Weekly Challenge #050</a></p>
<h2 id="phillip-harris2">Phillip Harris</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/phillip-harris/perl/ch-2.pl">Phillip Harris&rsquo;s solution</a> is a concise array-index based loop:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">@L <span style="color:#f92672">=</span> sort { $a <span style="color:#e6db74">&lt;=&gt;</span> $b } ( <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span> );
<span style="color:#66d9ef">for</span> ( $pos <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> ; $pos <span style="color:#f92672">&lt;=</span> $#L ; $pos<span style="color:#f92672">++</span> ) {
    <span style="color:#66d9ef">if</span> ( $L[$pos] <span style="color:#f92672">==</span> $#L <span style="color:#f92672">-</span> $pos ) {
        <span style="color:#66d9ef">print</span> $L[$pos] <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34;\n&#34;</span>;
    }
}
</code></pre></div><h2 id="roger-bell-west2">Roger Bell West</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/roger-bell-west/perl/ch-2.pl">Roger Bell West&rsquo;s solution</a> also uses array indices:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">noble</span> {
    <span style="color:#66d9ef">my</span> @l <span style="color:#f92672">=</span> sort @_;
    <span style="color:#66d9ef">my</span> @r;
    <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $m (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$#l) {
        <span style="color:#66d9ef">if</span> ( $l[$m] <span style="color:#f92672">==</span> $#l <span style="color:#f92672">-</span> $m ) {
            push @r, $l[$m];
        }
    }
    <span style="color:#66d9ef">return</span> @r;
}
</code></pre></div><h2 id="ruben-westerberg2">Ruben Westerberg</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/ruben-westerberg/perl/ch-2.pl">Ruben Westerberg&rsquo;s solution</a> uses array indices, but notably, does so with a slice of his (sorted) input <code>@list</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> @list<span style="color:#f92672">=</span> sort {$a <span style="color:#f92672">&gt;</span> $b} map {int rand <span style="color:#ae81ff">50</span>} <span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$size;
<span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;Sorted Input list: &#34;</span>,
join(<span style="color:#e6db74">&#34;,&#34;</span>, @list),<span style="color:#e6db74">&#34;\n&#34;</span>;
<span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;Noble Integers found: &#34;</span>, join <span style="color:#e6db74">&#34;, &#34;</span>, @list[grep { @list<span style="color:#f92672">-</span>$_<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">==</span> $list[$_] } <span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>@list<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
</code></pre></div><h2 id="ryan-thompson2">Ryan Thompson</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/ryan-thompson/perl/ch-2.pl">My solution</a> sorts and then uses array indices to find the Noble integer:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">noble</span> {
    <span style="color:#66d9ef">my</span> @L <span style="color:#f92672">=</span> sort { $a <span style="color:#e6db74">&lt;=&gt;</span> $b } @_;
    map { $L[$_] } grep { $L[$_] <span style="color:#f92672">==</span> $#L <span style="color:#f92672">-</span> $_ } <span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$#L;
}
</code></pre></div><p><strong>Blog</strong> › <a href="http://ry.ca/2020/03/noble-integers/">Noble Integers</a></p>
<h2 id="saiftynet2">Saif Ahmed</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/saiftynet/perl/ch-2.pl">Saif Ahmed&rsquo;s solution</a> sorts and uses array indices to find the Noble integer, if there is one:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">findNobel</span> {
    @l     <span style="color:#f92672">=</span> sort { $a <span style="color:#e6db74">&lt;=&gt;</span> $b } @_;    <span style="color:#75715e"># sort the list first</span>
    $found <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;                        <span style="color:#75715e"># intialise $found to zero</span>
    <span style="color:#66d9ef">foreach</span> ( <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $#l ) {             <span style="color:#75715e"># look through elements</span>
            <span style="color:#75715e"># when a nobel element is found, report, set $found and exit</span>
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;Found Nobel Number $l[$_] &#34;</span> <span style="color:#f92672">and</span> $found <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">and</span> <span style="color:#66d9ef">last</span>
          <span style="color:#66d9ef">if</span> $l[$_] <span style="color:#f92672">==</span> ( $#l <span style="color:#f92672">-</span> $_ );
    }
    <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;No Nobel numbers&#34;</span> <span style="color:#66d9ef">unless</span> $found;    <span style="color:#75715e"># $found not set if not found</span>
    <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34; in &#34;</span> <span style="color:#f92672">.</span> ( join <span style="color:#e6db74">&#34;,&#34;</span>, @l ), <span style="color:#e6db74">&#34;\n&#34;</span>;     <span style="color:#75715e"># either way, print out the list</span>
}
</code></pre></div><h2 id="sol-demuth2">Sol DeMuth</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/sol-demuth/perl/ch-2.pl">Sol DeMuth&rsquo;s solution</a> uses an O(n²) nested loop, which includes perhaps the most concise rationale I have seen for the existence of a single Noble integer:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $i (sort { $a <span style="color:#e6db74">&lt;=&gt;</span> $b } @L) {
    <span style="color:#66d9ef">if</span> (scalar(grep {$_ <span style="color:#f92672">&gt;</span> $i} @L) <span style="color:#f92672">==</span> $i) {
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;Noble Integer: $i\n&#34;</span>;
        <span style="color:#75715e"># there cannot be multiple in a list because</span>
        <span style="color:#75715e"># the next greater noble integer nullifies the</span>
        <span style="color:#75715e"># the previous smaller noble integer</span>
        <span style="color:#66d9ef">last</span>;
    }
}
</code></pre></div><h2 id="southpawgeek2">Jen Guerra</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/southpawgeek/perl/ch-2.pl">Jen Guerra&rsquo;s solution</a> uses array indices as well:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">noble</span> {
    <span style="color:#66d9ef">my</span> $L <span style="color:#f92672">=</span> shift;
    @{$L} <span style="color:#f92672">=</span> sort {$a <span style="color:#e6db74">&lt;=&gt;</span> $b} @{$L};
    <span style="color:#66d9ef">my</span> $noble <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    say <span style="color:#e6db74">&#39;Given set: &#39;</span>, <span style="color:#e6db74">&#34;@{$L}&#34;</span>;
    <span style="color:#66d9ef">my</span> $last_index <span style="color:#f92672">=</span> scalar @{$L} <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $i (<span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $#{$L}) {
        $noble <span style="color:#f92672">=</span> $_<span style="color:#f92672">-&gt;</span>[$i] <span style="color:#66d9ef">if</span> $_<span style="color:#f92672">-&gt;</span>[$i] <span style="color:#f92672">==</span> $last_index <span style="color:#f92672">-</span> $i;
    }
    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;No Noble integer.&#34;</span> <span style="color:#66d9ef">unless</span> $noble;
    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;$noble is the Noble integer. \n&#34;</span>;
}
</code></pre></div><h2 id="ulrich-rieke2">Ulrich Rieke</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/ulrich-rieke/perl/ch-2.pl">Ulrich Rieke&rsquo;s solution</a> includes a <code>findNobles</code> sub that takes a reference to an array of random integers. It begins by de-duping and sorting the list into <code>@sorted</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">findNobles</span> {
    <span style="color:#66d9ef">my</span> $randoms <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">my</span> %randHash;
    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $elem ( @{$randoms} ) {
        $randHash{$elem}<span style="color:#f92672">++</span>;
    }
    <span style="color:#66d9ef">my</span> @sorted <span style="color:#f92672">=</span> sort { $a <span style="color:#e6db74">&lt;=&gt;</span> $b } keys %randHash;
    <span style="color:#66d9ef">my</span> $len    <span style="color:#f92672">=</span> scalar @sorted;
</code></pre></div><p>The real work then begins, and Ulrich uses array indices to full effect:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span> @nobles;
    <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $i ( <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $len <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> ) {
        <span style="color:#66d9ef">if</span> ( $sorted[$i] <span style="color:#f92672">==</span> $len <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> $i ) {
            push( @nobles, $sorted[$i] );
        }
    }
    <span style="color:#66d9ef">return</span> @nobles;
}
</code></pre></div><h2 id="user-person2">User Person</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/user-person/perl/ch-2.pl">User Person&rsquo;s solution</a> starts by sorting the input into <code>@ints</code>, and then uses a nested loop to find the Noble integer, kept in <code>%seen</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">nobleInt</span> {
    <span style="color:#66d9ef">my</span> @ints <span style="color:#f92672">=</span> sort { $a <span style="color:#e6db74">&lt;=&gt;</span> $b } @_;
    <span style="color:#66d9ef">my</span> %seen <span style="color:#f92672">=</span> ();
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">my</span> $i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; $i <span style="color:#f92672">&lt;=</span> $#ints; <span style="color:#f92672">++</span>$i) {
        <span style="color:#66d9ef">my</span> $count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
      MOV:
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">my</span> $j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; $j <span style="color:#f92672">&lt;=</span> $#ints; <span style="color:#f92672">++</span>$j) {
            <span style="color:#66d9ef">next</span> MOV <span style="color:#66d9ef">if</span> $i <span style="color:#f92672">==</span> $j;
            <span style="color:#f92672">++</span>$count <span style="color:#66d9ef">if</span> $ints[$i] <span style="color:#f92672">&lt;</span> $ints[$j];
        }
        $seen{ $ints[$i] }<span style="color:#f92672">++</span> <span style="color:#66d9ef">if</span> $count <span style="color:#f92672">==</span> $ints[$i];
    }
    <span style="color:#66d9ef">return</span> keys %seen;
}
</code></pre></div><h2 id="wanderdoc2">Wanderdoc</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/wanderdoc/perl/ch-2.pl">Wanderdoc&rsquo;s solution</a> also uses <code>sample</code> from the latest (2020-Feb-02) <code>List::Util</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">use</span> List::Util <span style="color:#e6db74">qw(sample)</span>;
<span style="color:#66d9ef">my</span> $MIN <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
<span style="color:#66d9ef">my</span> $MAX <span style="color:#f92672">=</span> <span style="color:#ae81ff">50</span>;
<span style="color:#66d9ef">my</span> $SAMPLE <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;
<span style="color:#66d9ef">my</span> @range <span style="color:#f92672">=</span> ($MIN <span style="color:#f92672">..</span> $MAX);
noble(<span style="color:#f92672">\</span>@range, $SAMPLE) <span style="color:#66d9ef">for</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> <span style="color:#ae81ff">20</span>;

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">noble</span> {
     <span style="color:#66d9ef">my</span> ($aref, $n) <span style="color:#f92672">=</span> @_;
     <span style="color:#66d9ef">my</span> @list <span style="color:#f92672">=</span> sort {$a <span style="color:#e6db74">&lt;=&gt;</span> $b} sample($n, @$aref);
     <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $int ( @list ) {
          <span style="color:#66d9ef">my</span> $count <span style="color:#f92672">=</span> grep $_ <span style="color:#f92672">&gt;</span> $int, @list;
          <span style="color:#66d9ef">if</span> ( $int <span style="color:#f92672">==</span> $count ) {
               <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;1$/&#34;</span>; <span style="color:#75715e"># &#34;1: $int $count$/&#34;;</span>
               <span style="color:#66d9ef">return</span>;
          }
     }
     <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;-1$/&#34;</span>;
}
</code></pre></div><p>Wanderdoc&rsquo;s nested loop solution works well. Note that Wanderdoc chose to effectively return a truth value instead of the actual Noble integer (1 if there was a Noble integer, -1 if there was not.)</p>
<h2 id="yet-ebreo2">Yet Ebreo</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-050/yet-ebreo/perl/ch-2.pl">Yet Ebreo&rsquo;s solution</a> uses <code>$sort</code> and an array index-based solution:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> @list <span style="color:#f92672">=</span> sort {$a <span style="color:#f92672">-</span> $b } split <span style="color:#e6db74">&#34; &#34;</span>,$ARGV[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">||</span> <span style="color:#e6db74">&#34;2 6 1 3&#34;</span>;
<span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i (<span style="color:#ae81ff">0</span><span style="color:#f92672">..~-</span>@list) {
    say $list[$i] <span style="color:#66d9ef">if</span> <span style="color:#f92672">~-</span>@list<span style="color:#f92672">-</span>$i <span style="color:#f92672">==</span> $list[$i]
}
</code></pre></div><hr>
<hr>
<h2 id="blogs">See Also</h2>
<h3 id="blogs-this-week">Blogs this week:</h3>
<p><strong>Dave Jacoby</strong> › <a href="https://jacoby.github.io/2020/03/02/perl-challenge-50.html">Perl Challenge #50</a></p>
<p><strong>E. Choroba</strong> › <a href="http://blogs.perl.org/users/e_choroba/2020/03/perl-weekly-challenge-050-merge-intervals-and-noble-integer.html">Merge Intervals and Noble Integer</a></p>
<p><strong>Javier Luque</strong> › <a href="https://perlchallenges.wordpress.com/2020/03/02/perl-weekly-challenge-050/">050 – Perl Weekly Challenge</a></p>
<p><strong>Laurent Rosenfeld</strong> › <a href="http://blogs.perl.org/users/laurent_r/2020/03/perl-weekly-challenge-merge-inrervals-and-noble-numbers.html">Merge Inrervals and Noble Numbers</a></p>
<p><strong>Luca Ferrari</strong> › <a href="https://fluca1978.github.io/2020/03/02/PerlWeeklyChallenge50.html#task1">overlapping ranges and nobel numbers</a></p>
<p><strong>Mohammad S Anwar</strong> › <a href="https://perlweeklychallenge.org/blog/weekly-challenge-050/">The Weekly Challenge #050</a></p>
<p><strong>Ryan Thompson</strong> › <a href="http://ry.ca/2020/03/merge-intervals/">Merge Intervals</a> | <a href="http://ry.ca/2020/03/noble-integers/">Noble Integers</a></p>

                </div>
            </div>
        </div>
    </div>
</section>


<!-- Call To Action Section Start -->
<section id="call-to-action">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2 class="title wow fadeInDown" data-wow-delay=".3s" data-wow-duration="500ms">SO WHAT DO YOU THINK ?</h2>
                    <p class="wow fadeInDown" data-wow-delay=".5s" data-wow-duration="500ms">If you have any suggestions or ideas then please do share with us.</p>
                    <a href="mailto:mohammad.anwar@yahoo.com" class="btn btn-default btn-contact wow fadeInDown" data-wow-delay=".7s" data-wow-duration="500ms">Contact with me</a>
                </div>
            </div>

        </div>
    </div>
</section>
<!-- Call To Action Section End -->



<!-- Footer Section Start -->
<footer id="footer">
    <div class="container">
        <div class="row content-justify-between">
            <div class="col-md-8 col-12 text-center text-lg-left text-md-left">
                <p class="copyright">Copyright:
                    <span>
                        2019 - 2025
                    </span> The Weekly Challenge. Theme Design and Developed by
                    <a href="http://www.Themefisher.com" rel="noreferrer" rel="noreferrer" target="_blank">Themefisher</a>.
                </p>
            </div>
            <div class="col-md-4 col-12">
                <!-- Social Media -->
                <ul class="social text-center text-md-right text-lg-right">
                    <li>
                        <a href="https://twitter.com/PerlWChallenge" class="twitter" rel="noreferrer" target="_blank" title="Follow us">
                            <i class="ion-social-twitter"></i>
                        </a>
                    </li>
                    <li>
                        <a href="/rss.xml" class="rss" target="_blank" title="RSS Feed">
                            <i class="ion-social-rss"></i>
                        </a>
                    </li>
                </ul>
            </div>
        </div>
    </div>
</footer>
<!-- footer section end -->

<!-- jquery -->
<script src="https://theweeklychallenge.org/plugins/jquery/jquery.min.js"></script>
<!-- Form Validation -->
<script src="https://theweeklychallenge.org/plugins/form-validation/jquery.form.min.js"></script>
<script src="https://theweeklychallenge.org/plugins/form-validation/jquery.validate.min.js"></script>
<!-- slick slider -->
<script src="https://theweeklychallenge.org/plugins/slick/slick.min.js"></script>
<!-- bootstrap js -->
<script src="https://theweeklychallenge.org/plugins/bootstrap/bootstrap.min.js"></script>
<!-- chart js -->
<script src="https://theweeklychallenge.org/plugins/chart/highstock.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/drilldown.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/data.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/chart.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/pwc-challenge.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/gc-challenge.js"></script>
<!-- wow js -->
<script src="https://theweeklychallenge.org/plugins/wow-js/wow.min.js"></script>
<!-- slider js -->
<script src="https://theweeklychallenge.org/plugins/slider/slider.js"></script>
<!-- Fancybox -->
<script src="https://theweeklychallenge.org/plugins/facncybox/jquery.fancybox.js"></script>
<!-- template main js -->

<script src="https://theweeklychallenge.org/js/script.min.js"></script>
<!-- google analitycs -->

<script async src="https://www.googletagmanager.com/gtag/js?id=G-CJTPYM9SB8"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-CJTPYM9SB8');
</script>
</body>

</html>

