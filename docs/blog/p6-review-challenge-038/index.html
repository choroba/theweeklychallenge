<!DOCTYPE html>
<html class="no-js" lang="en-us">
<head>
    <!-- Basic Page Needs -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:title"       content="The Weekly Challenge: Laurent Rosenfeld Weekly Review: Challenge - 038"/>
    <meta property="og:type"        content="website"/>
    <meta property="og:url"         content="https://theweeklychallenge.org/blog/p6-review-challenge-038/"/>
    <meta property="og:image"       content="https://theweeklychallenge.org/images/blog/p6-review-challenge-038.jpg"/>
    <meta property="og:description" content="Laurent Rosenfeld Weekly Review: Challenge - #038."/>
    <meta name="twitter:card"       content="summary" />
    <meta name="twitter:image"      content="https://theweeklychallenge.org/images/blog/p6-review-challenge-038.jpg"/>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <meta name="description" content="Laurent Rosenfeld Weekly Review: Challenge - #038.">
    <meta name="author" content="The Weekly Challenge Team">
    <meta name="generator" content="Hugo 0.67.0-DEV" />

    <link rel="me" href="https://fosstodon.org/@manwar">
    <link rel="canonical" href="https://theweeklychallenge.org/blog/p6-review-challenge-038/" />

    <!-- Mobile Specific Metas -->
    <meta name="format-detection" content="telephone=no">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Laurent Rosenfeld Weekly Review: Challenge - 038</title>
    <link rel="icon" href="https://theweeklychallenge.org/images/favicon.ico">

    
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css"/>

    <!-- Twitter Bootstrs CSS -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/bootstrap/bootstrap.min.css">
    <!-- Ionicons Fonts Css -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/ionicons/ionicons.min.css">
    <!-- animate css -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/animate-css/animate.css">
    <!-- Hero area slider css-->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/slider/slider.css">
    <!-- slick slider -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/slick/slick.css">
    <!-- Fancybox -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/facncybox/jquery.fancybox.css">
    <!-- hover -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/hover/hover-min.css">
    <!-- Google fonts -->
    <link href='https://fonts.googleapis.com/css?family=Source Code Pro' rel='stylesheet'>
    <!-- template main css file -->
    
    <link rel="stylesheet" href="https://theweeklychallenge.org/css/style.min.css" integrity="" media="screen">
    <link rel="stylesheet" href="https://theweeklychallenge.org/css/main.css">

    <style>
        #goTopButton {
            display: none;          
            position: fixed;        
            bottom: 20px;           
            right: 30px;            
            z-index: 99;            
            border: none;           
            outline: none;          
            background-color: red;  
            color: white;           
            cursor: pointer;        
            padding: 15px;          
            border-radius: 10px;    
            font-size: 18px;        
        }

        #goTopButton:hover {
              background-color: #555;
        }
    </style>


</head>

<body>

<button onclick="goTop()" id="goTopButton" title="Go to top">Top</button>

<script>

    topButton = document.getElementById("goTopButton");

    
    window.onscroll = function() { scrollFunction() };

    function scrollFunction() {
        if (document.body.scrollTop > 40 || document.documentElement.scrollTop > 40) {
            topButton.style.display = "block";
        } else {
            topButton.style.display = "none";
        }
    }

    
    function goTop() {
        document.body.scrollTop = 0; 
        document.documentElement.scrollTop = 0; 
    }

</script>

<section class="top-bar animated-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-12">
                <nav class="navbar navbar-expand-lg navbar-light bg-light">
                    <a class="navbar-brand" href="https://theweeklychallenge.org/">
                        <img src="https://theweeklychallenge.org/images/logo.svg" alt="logo">
                    </a>
                    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navgation" aria-controls="navigation"
                        aria-expanded="false" aria-label="Toggle navigation">
                        <span class="navbar-toggler-icon"></span>
                    </button>

                    <div class="collapse navbar-collapse" id="navigation">
                        <ul class="navbar-nav ml-auto">
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/">Home</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/about">About</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/chart">Chart</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/champions">Champions</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/team">Team</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/challenges">Challenges</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/p5-reviews">Perl/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/p6-reviews">Raku/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/recaps">Recaps</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/blogs">Blogs</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/faq">FAQ</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/contact">Contact</a>
                            </li>
                            
                        </ul>
                    </div>
                </nav>
            </div>
        </div>
    </div>
</section>


<section class="global-page-header">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2>Laurent Rosenfeld Weekly Review: Challenge - 038</h2>
                    <div class="portfolio-meta">
                        <span>Sunday, Dec 22, 2019</span>|
                        <span> Tags:
                            Raku
                        </span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

<section class="single-post">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                
                <div style="text-align: center" class="post-img">
                    <img class="img-fluid" alt="" src="https://theweeklychallenge.org/images/blog/p6-review-challenge-038.jpg">
                </div>
                
                <div style="text-align: justify" class="post-content">
                    <hr>
<h1 id="raku-solutions-weekly-review">Raku Solutions Weekly Review</h1>
<hr>
<h2 id="task-1-date-finder">Task #1: Date Finder</h2>
<p>This is derived in part from my <a href="http://blogs.perl.org/users/laurent_r/2019/12/perl-weekly-challenge-38-date-finder-and-word-game.html">blog post</a> made in answer to the <a href="https://perlweeklychallenge.org/blog/perl-weekly-challenge-038/">Week 38 of the Perl Weekly Challenge</a> organized by  <a href="http://blogs.perl.org/users/mohammad_s_anwar/">Mohammad S. Anwar</a> as well as answers made by others to the same challenge.</p>
<p>The challenge reads as follows:</p>
<p><em>Create a script to accept a 7 digits number, where the first number can only be 1 or 2. The second and third digits can be anything 0-9. The fourth and fifth digits corresponds to the month i.e. 01,02,03…,11,12. And the last 2 digits represents the days in the month i.e. 01,02,03….29,30,31. Your script should validate if the given number is valid as per the rule and then convert into human readable format date.</em></p>
<p><em>Rules:</em></p>
<p><em>1) If 1st digit is 1, then prepend 20 otherwise 19 to the 2nd and 3rd digits to make it 4-digits year.</em></p>
<p><em>2) The 4th and 5th digits together should be a valid month.</em></p>
<p><em>3) The 6th and 7th digits together should be a valid day for the above month.</em></p>
<p><em>For example, the given number is 2230120, it should print 1923-01-20.</em></p>
<h2 id="my-solutions">My Solutions</h2>
<p>This time, rather than concentrating on a test suite, I decided to focus on trying to provide useful warnings and error messages when the input value is not valid, which led me to test the input data piece by piece. The following program is basically a port to Raku of the program I had initially written in Perl 5 for the same task:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">use</span> v6;

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">MAIN</span> ($in where * ~~ /^\d ** 7$/ = &#39;2230120&#39;) {
    <span style="color:#66d9ef">my</span> ($y1, $y2, $m, $d) <span style="color:#f92672">=</span> ($in <span style="color:#f92672">~~</span> <span style="color:#e6db74">/^(\d)(\d\d)(\d\d)(\d\d)/</span>)[<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">3</span>];
    die <span style="color:#e6db74">&#34;First digit should be 1 or 2\n&#34;</span> <span style="color:#66d9ef">if</span> $y1 <span style="color:#f92672">!~~</span> <span style="color:#e6db74">/&lt;[12]&gt;/</span>;
    <span style="color:#66d9ef">my</span> $year <span style="color:#f92672">=</span> $y1 <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> ?? <span style="color:#e6db74">&#34;20$y2&#34;</span> <span style="color:#f92672">!!</span> <span style="color:#e6db74">&#34;19$y2&#34;</span>;
    die <span style="color:#e6db74">&#34;Digits 4 and 5 should be a valid month number\n&#34;</span> <span style="color:#66d9ef">unless</span> $m <span style="color:#f92672">~~</span> <span style="color:#e6db74">/(0 &lt;[1..9]&gt;) | (1 &lt;[012]&gt;)/</span>;
    die <span style="color:#e6db74">&#34;Digits 6 and 7 should be a valid day in month\n&#34;</span> <span style="color:#66d9ef">unless</span> $d <span style="color:#f92672">~~</span> <span style="color:#e6db74">/(&lt;[012]&gt; \d) | (3 &lt;[01]&gt;)/</span>;
    try {
        <span style="color:#66d9ef">my</span> $test <span style="color:#f92672">=</span> Date<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>($year, $m, $d);
    }
    die <span style="color:#e6db74">&#34;$in is equivalent to $year-$m-$d, which is an invalid date\n&#34;</span> <span style="color:#66d9ef">if</span> $!;
    say <span style="color:#e6db74">&#34;$in is equivalent to $year-$m-$d.&#34;</span>;
}
</code></pre></div><p>Running it with the default value produces the following output:</p>
<pre><code>$ perl6 date_finder.p6
2230120 is equivalent to 1923-01-20.
</code></pre>
<p>This is the output with a correct argument:</p>
<pre><code>$ perl6 date_finder.p6 1191210
1191210 is equivalent to 2019-12-10.
</code></pre>
<p>And with an invalid argument:</p>
<pre><code>$ perl6 date_finder.p6 1191310
Digits 4 and 5 should be a valid month number

  in sub MAIN at date_finder.p6 line 7
  in block &lt;unit&gt; at date_finder.p6 line 1
</code></pre>
<p>We first validate that each data piece. For example, I&rsquo;ve decided that the first digit should be 1 or 2 (although the requirement is not explicit about the possible second value). Then, digits 4 and 5 should be a valid month number, so it should be anything between <code>01</code> ad <code>12</code> and digits 6 and 7 should be a valid day within a month. After these checks, the program attempts to create a <code>Date</code> object within a <a href="https://docs.raku.org/language/exceptions#index-entry-try_blocks">try block</a> and will die with the appropriate error message if the date is not valid (i.e. if an exception is caught into the <code>$!</code> error variable). The initial tests are not strictly necessary, as the creation of the <code>Date</code> object construction will catch any date error, but they make it possible to provide the user with a more explicit message about the input error. Having said that, I should add that the validation of the data pieces is not as exhaustive as it could be (for example <code>00</code> would pass the day digit test), but I didn&rsquo;t care too much about it, since the <code>try</code> block will catch any remaining error:</p>
<pre><code>$ perl6 date_finder.p6 2230100
2230100 is equivalent to 1923-01-00, which is an invalid date
</code></pre>
<p>Rather than having the relatively complicated regexes above for checking the month and day digits, we have tried to use <code>subsets</code>, for example:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6">subset Day of Str where <span style="color:#f92672">*</span> <span style="color:#f92672">eq</span> (<span style="color:#e6db74">&#34;01&#34;</span> <span style="color:#f92672">..</span> <span style="color:#e6db74">&#34;31&#34;</span>)<span style="color:#f92672">.</span>any;
subset Month of Str where <span style="color:#f92672">*</span> <span style="color:#f92672">eq</span> (<span style="color:#e6db74">&#34;01&#34;</span> <span style="color:#f92672">..</span> <span style="color:#e6db74">&#34;12&#34;</span>)<span style="color:#f92672">.</span>any;
</code></pre></div><p>But this turned out to be somewhat inconvenient, as it leads easily to pesky type check errors.</p>
<p>Another way to do it would be to use a grammar, for example:</p>
<pre><code>use v6;

grammar My-custom-date {
    token TOP { &lt;y1&gt; &lt;y2&gt; &lt;m&gt; &lt;d&gt; }
    token y1  { &lt;[12]&gt; }
    token y2  { \d ** 2}
    token m   { 0 &lt;[1..9]&gt; | 1&lt;[012]&gt; }
    token d   { 0 &lt;[1..9]&gt; | &lt;[12]&gt; \d | 3&lt;[01]&gt; }
}

sub MAIN ($in where * ~~ /^\d ** 7$/ = '2230120') {
    my $matched  = so My-custom-date.parse($in);
    say &quot;Invalid input value $in&quot; and exit unless $matched;
    my $year = $&lt;y1&gt; == 1 ?? &quot;20$&lt;y2&gt;&quot; !! &quot;19$&lt;y2&gt;&quot;;
    try {
        my $test = Date.new($year, $&lt;m&gt;, $&lt;d&gt;);
    }
    say &quot;ERROR: $in is equivalent to $year-$&lt;m&gt;-$&lt;d&gt;, which is an invalid date\n&quot; and exit if $!;
    say &quot;$in is equivalent to $year-$&lt;m&gt;-$&lt;d&gt;.&quot;;
}
</code></pre>
<p>But, in this case, the advantage of using a grammar is not obvious, except for the fact the parsing is possibly slightly clearer. It might even be argued that using a grammar for such a simple case is sort of a technological overkill. The example may still provide some guidance with a very simple example to anyone beginning with grammars.</p>
<p>These are some sample runs:</p>
<pre><code>$ perl6 date_finder.p6
2230120 is equivalent to 1923-01-20.

$ perl6 date_finder.p6 2230228
2230228 is equivalent to 1923-02-28.

$ perl6 date_finder.p6 2230229
Use of Nil in string context
ERROR: 2230229 is equivalent to 1923--, which is an invalid date

  in block  at date_finder.p6 line 17
Use of Nil in string context
  in block  at date_finder.p6 line 17
</code></pre>
<h2 id="alternative-solutions">Alternative Solutions</h2>
<p>TIMTOWTDI. Even for such a relatively simple task, the challengers have implemented the task in many different ways. For parsing the input string, people have used standard regexes, named captures, named rules, grammars (including even a grammar with an actions class), the <code>substr</code> built-in function and even the <code>polymod</code> method. Similarly, for catching an exception when creating a <code>date</code> object, challengers have used try block (with or without a <code>CATCH</code> clause within it), try prefix statements and bare <code>CATCH</code> blocks. There is really more than one way to do it in Raku.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-038/arne-sommer/perl6/ch-1.p6">Arne Sommer</a> used <a href="https://docs.raku.org/language/regexes#index-entry-regex__Named_captures-Named_captures">named captures</a> to collect the input data pieces and a <code>try</code> statement prefix followed by a <code>Date</code> object creation to perform date validation:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">if</span> $date <span style="color:#f92672">~~</span> <span style="color:#f92672">/^</span>
    $<span style="color:#960050;background-color:#1e0010">&lt;</span>century<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> (<span style="color:#e6db74">&lt;[12]&gt;</span>)
    $<span style="color:#960050;background-color:#1e0010">&lt;</span>year<span style="color:#f92672">&gt;</span>    <span style="color:#f92672">=</span> (<span style="color:#e6db74">&lt;[0..9]&gt;&lt;[0..9]&gt;</span>)
    $<span style="color:#960050;background-color:#1e0010">&lt;</span>month<span style="color:#f92672">&gt;</span>   <span style="color:#f92672">=</span> (<span style="color:#e6db74">&lt;[01]&gt;&lt;[0..9]&gt;</span>)
    $<span style="color:#960050;background-color:#1e0010">&lt;</span>day<span style="color:#f92672">&gt;</span>     <span style="color:#f92672">=</span> (<span style="color:#e6db74">&lt;[0123]&gt;&lt;[0..9]&gt;</span>)
    $/
{
    <span style="color:#66d9ef">my</span> $datestring <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;{ $&lt;century&gt; == 1 ?? &#39;20&#39; !! &#39;19&#39; }{ $&lt;year&gt; }-{ $&lt;month&gt; }-{ $&lt;day&gt; }&#34;</span>;

    <span style="color:#66d9ef">if</span> try Date<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>($datestring)
    {
        say $datestring;
        exit;
    }
}
say <span style="color:#e6db74">&#34;Not a valid date.&#34;</span>;
</code></pre></div><p>Note that Arne provided several other implementations, together with a detailed test suite, in his interesting <a href="https://raku-musings.com/date-word.html">blog post</a>.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-038/daniel-mita/perl6/ch-1.p6">Daniel Mita</a> used a named rule:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">my</span> token date<span style="color:#f92672">-</span>number {
  <span style="color:#f92672">^</span>
  ( ( <span style="color:#e6db74">&lt;[12]&gt;</span> ) ( <span style="color:#e6db74">&lt;[0..9]&gt;</span> <span style="color:#f92672">**</span> <span style="color:#ae81ff">2</span> ) )
  ( <span style="color:#e6db74">&lt;[0..9]&gt;</span> <span style="color:#f92672">**</span> <span style="color:#ae81ff">2</span> ) <span style="color:#f92672">**</span> <span style="color:#ae81ff">2</span>
  $
<span style="color:#960050;background-color:#1e0010">}</span>
</code></pre></div><p>to parse the input data, and then used the <a href="https://docs.raku.org/routine/make">make</a> and <a href="https://docs.raku.org/routine/made">made</a> methods of the Raku <a href="https://docs.raku.org/type/Match">Match</a> class to handle the necessary transformations:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">MAIN</span>(
  $number where * ~~ &amp;date-number, #= 7 digit number starting with 1 or 2 followed by YYMMDD
  --&gt; Nil
) {
  given $0[<span style="color:#ae81ff">0</span>] {
    when <span style="color:#ae81ff">1</span> { <span style="color:#f92672">.</span>make(<span style="color:#ae81ff">19</span>) }
    when <span style="color:#ae81ff">2</span> { <span style="color:#f92672">.</span>make(<span style="color:#ae81ff">20</span>) }
  }
  Date<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(
    year  <span style="color:#f92672">=&gt;</span> $0[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>made <span style="color:#f92672">~</span> $0[<span style="color:#ae81ff">1</span>],
    month <span style="color:#f92672">=&gt;</span> $1[<span style="color:#ae81ff">0</span>],
    day   <span style="color:#f92672">=&gt;</span> $1[<span style="color:#ae81ff">1</span>],
  )<span style="color:#f92672">.</span>say;
}
</code></pre></div><p>So far, I had always used the <code>make</code> and <code>made</code> methods solely in the context of grammars, and had just not realized that it could be used on any match object. Quite an interesting discovery for me. Thank you, Daniel.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-038/kevin-colyer/perl6/ch-1.p6">Kevin Colyer</a> wrote a <code>validate</code> subroutine to check the input data, and constructed a <code>DateTime</code> object within a <code>try</code> block with a <code>CATCH</code> clause to validate the date:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">validate</span>($d where *&gt;0) {
    <span style="color:#66d9ef">my</span> $s<span style="color:#f92672">=</span>$d<span style="color:#f92672">.</span>Str;
    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Input must be only 7 digits in length&#34;</span> <span style="color:#66d9ef">if</span> $d<span style="color:#f92672">.</span>chars<span style="color:#f92672">!==</span><span style="color:#ae81ff">7</span>;
    <span style="color:#66d9ef">my</span> ($day,$month,$year,$mill) <span style="color:#f92672">=</span> $d<span style="color:#f92672">.</span>polymod(<span style="color:#ae81ff">100</span>,<span style="color:#ae81ff">100</span>,<span style="color:#ae81ff">100</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;First digit must be either 1 or 2&#34;</span> <span style="color:#66d9ef">if</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&gt;</span> $mill <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">2</span>;
    $year<span style="color:#f92672">+=</span>$mill<span style="color:#f92672">==</span><span style="color:#ae81ff">1</span> ?? <span style="color:#ae81ff">2000</span> <span style="color:#f92672">!!</span> <span style="color:#ae81ff">1900</span> ;
    <span style="color:#66d9ef">my</span> $date;
    try     { $date <span style="color:#f92672">=</span> DateTime<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(year <span style="color:#f92672">=&gt;</span> $year, month <span style="color:#f92672">=&gt;</span> $month, day <span style="color:#f92672">=&gt;</span> $day);
        CATCH   { <span style="color:#66d9ef">return</span> <span style="color:#f92672">.</span>Str }
    };
    <span style="color:#66d9ef">return</span> $date<span style="color:#f92672">.</span>Date;
}
</code></pre></div><p>I find that using the <a href="https://docs.raku.org/routine/polymod">polymod</a> method to split the input into data pieces is a quite interesting idea which I did not think about. Kevin also made a small test suite to test the <code>validate</code> subroutine.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-038/noud/perl6/ch-1.p6">Noud</a> used a grammar with a <code>ConvDate</code> actions class to handle the input data:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl">grammar DATE {
    token TOP { <span style="color:#e6db74">&lt;century&gt;</span> <span style="color:#e6db74">&lt;year&gt;</span> <span style="color:#e6db74">&lt;month&gt;</span> <span style="color:#e6db74">&lt;day&gt;</span> }
    regex century { <span style="color:#ae81ff">1</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">2</span> }
    regex year { <span style="color:#e6db74">&lt;digit&gt;</span><span style="color:#f92672">**</span><span style="color:#ae81ff">2</span> }
    regex month { <span style="color:#e6db74">&lt;digit&gt;</span><span style="color:#f92672">**</span><span style="color:#ae81ff">2</span> }
    regex day { <span style="color:#e6db74">&lt;digit&gt;</span><span style="color:#f92672">**</span><span style="color:#ae81ff">2</span> }
}
class ConvDate {
    method TOP ($/) { make (<span style="color:#66d9ef">if</span> ($<span style="color:#960050;background-color:#1e0010">&lt;</span>century<span style="color:#f92672">&gt;</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) { <span style="color:#ae81ff">20</span> } <span style="color:#66d9ef">else</span> { <span style="color:#ae81ff">19</span> }) <span style="color:#f92672">~</span> $<span style="color:#960050;background-color:#1e0010">&lt;</span>year<span style="color:#f92672">&gt;</span>
                      <span style="color:#f92672">~</span> <span style="color:#e6db74">&#39;-&#39;</span> <span style="color:#f92672">~</span> $<span style="color:#960050;background-color:#1e0010">&lt;</span>month<span style="color:#f92672">&gt;</span> <span style="color:#f92672">~</span> <span style="color:#e6db74">&#39;-&#39;</span> <span style="color:#f92672">~</span> $<span style="color:#960050;background-color:#1e0010">&lt;</span>day<span style="color:#f92672">&gt;</span>; }
}
say DATE<span style="color:#f92672">.</span>parse(<span style="color:#ae81ff">2230120</span>, actions <span style="color:#f92672">=&gt;</span> ConvDate)<span style="color:#f92672">.</span>made;
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-038/simon-proctor/perl6/ch-1.p6">Simon Proctor</a> used named captures within a constant regex and also was able to use a subset without encountering the problems I mentioned above. He then constructed a <code>Date</code> object and used a <code>CATCH</code> block to catch any error.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6">constant $DATE<span style="color:#f92672">-</span>MATCH <span style="color:#f92672">=</span> rx<span style="color:#e6db74">/^ $&lt;century&gt;=(&lt;[12]&gt;) $&lt;year&gt;=(&lt;[0..9]&gt;**2) $&lt;month&gt;=(&#34;01&#34;|&#34;02&#34;|&#34;03&#34;|&#34;04&#34;|&#34;05&#34;|&#34;06&#34;|&#34;07&#34;|&#34;08&#34;|&#34;09&#34;|&#34;10&#34;|&#34;11&#34;|&#34;12&#34;) $&lt;day&gt;=(&lt;[0..3]&gt;&lt;[0..9]&gt;) $/</span>;
subset PossData of Str where <span style="color:#f92672">*</span> <span style="color:#f92672">~~</span> $DATE<span style="color:#f92672">-</span>MATCH;
multi <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">MAIN</span>($s) is hidden-from-USAGE {
    say <span style="color:#e6db74">&#34;{$s} doesn&#39;t match the valid string condition\n$*USAGE&#34;</span>;
}
<span style="color:#75715e">#| Parse the data string format</span>
multi <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">MAIN</span>(
    PossData $date #= Date in the format (1/2 2000/1900), year, month, day
) {
    <span style="color:#66d9ef">my</span> $match <span style="color:#f92672">=</span> ( $date <span style="color:#f92672">~~</span> $DATE<span style="color:#f92672">-</span>MATCH );
    <span style="color:#66d9ef">my</span> $result;
    {
        $result <span style="color:#f92672">=</span> Date<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>( :year( $match<span style="color:#f92672">.</span><span style="color:#e6db74">&lt;year&gt;</span> <span style="color:#f92672">+</span> ( $match<span style="color:#f92672">.</span><span style="color:#e6db74">&lt;century&gt;</span> <span style="color:#f92672">~~</span> <span style="color:#ae81ff">1</span> ?? <span style="color:#ae81ff">2000</span> <span style="color:#f92672">!!</span> <span style="color:#ae81ff">1900</span> ) ), :month( $match<span style="color:#e6db74">&lt;month&gt;</span> ), :day( $match<span style="color:#e6db74">&lt;day&gt;</span> ) );
        CATCH {
            default {
                say <span style="color:#e6db74">&#34;{$date} is not a valid date\n$*USAGE&#34;</span>;
                exit;
            }
        }
    }
    say $result;
}
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-038/javier-luque/perl6/ch-1.p6">Javier Luque</a> used a regex to parse the input data and constructed a <code>Date</code>  object within a <code>try</code> block with a <code>CATCH</code> block to validate the date:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">parse</span>-date(Int $date) {
    <span style="color:#75715e"># Regex to test date format</span>
    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Invalid date format&#34;</span>
        <span style="color:#66d9ef">unless</span> ($date <span style="color:#f92672">~~</span> <span style="color:#f92672">/</span>
            <span style="color:#f92672">^^</span>            <span style="color:#75715e"># Start of string</span>
            (<span style="color:#e6db74">&lt;[12]&gt;</span>)      <span style="color:#75715e"># 1 or 2</span>
            (<span style="color:#f92672">\</span>d<span style="color:#f92672">\</span>d)        <span style="color:#75715e"># year 00-99</span>
            (<span style="color:#ae81ff">0</span><span style="color:#e6db74">&lt;[1..9]&gt;</span> <span style="color:#f92672">||</span> <span style="color:#75715e"># month 1-12</span>
             <span style="color:#ae81ff">1</span><span style="color:#e6db74">&lt;[0..2]&gt;</span>)
            (<span style="color:#ae81ff">0</span><span style="color:#e6db74">&lt;[1..9]&gt;</span> <span style="color:#f92672">||</span> <span style="color:#75715e"># day 1-31</span>
             <span style="color:#e6db74">&lt;[1..2]&gt;</span><span style="color:#f92672">\</span>d<span style="color:#f92672">||</span>
             <span style="color:#ae81ff">3</span><span style="color:#e6db74">&lt;[01]&gt;</span>)
            $$            <span style="color:#75715e"># End of string</span>
        <span style="color:#f92672">/</span>);

    <span style="color:#75715e"># The date string</span>
    <span style="color:#66d9ef">my</span> $date_string <span style="color:#f92672">=</span>
        ( ($0 <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) ?? <span style="color:#e6db74">&#39;20&#39;</span> <span style="color:#f92672">~</span> $1  <span style="color:#f92672">!!</span> <span style="color:#e6db74">&#39;19&#39;</span> <span style="color:#f92672">~</span> $1 )
        <span style="color:#f92672">~</span> <span style="color:#e6db74">&#39;-&#39;</span> <span style="color:#f92672">~</span> $2 <span style="color:#f92672">~</span> <span style="color:#e6db74">&#39;-&#39;</span> <span style="color:#f92672">~</span> $3;

    <span style="color:#75715e"># Make sure the date is valid</span>
    <span style="color:#75715e"># even if it passed the format check</span>
    try {
        <span style="color:#66d9ef">my</span> $date_check <span style="color:#f92672">=</span> Date<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>($date_string);

        CATCH {
            <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Invalid date&#34;</span>;
        }
    }

    <span style="color:#66d9ef">return</span> $date_string;
}
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-038/roger-bell-west/perl6/ch-1.p6">Roger Bell West</a> used a series of regexes to check the input data and then constructed a <code>Date</code> object within a <code>CATCH</code> block to validate the date:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">for</span> @<span style="color:#960050;background-color:#1e0010">*</span>ARGS <span style="color:#f92672">-&gt;</span> $dc {
  <span style="color:#66d9ef">unless</span> ($dc<span style="color:#f92672">.</span>chars<span style="color:#f92672">==</span><span style="color:#ae81ff">7</span>) {
    warn <span style="color:#e6db74">&#34;$dc is wrong length\n&#34;</span>;
    <span style="color:#66d9ef">next</span>;
  }
  <span style="color:#66d9ef">unless</span> ($dc <span style="color:#f92672">~~</span> <span style="color:#e6db74">/^&lt;[0..9]&gt;+$/</span>) {
    warn <span style="color:#e6db74">&#34;$dc has non-digit characters\n&#34;</span>;
    <span style="color:#66d9ef">next</span>;
  }
  $dc <span style="color:#f92672">~~</span> <span style="color:#e6db74">/^(.)(..)(..)(..)$/</span>;
  <span style="color:#66d9ef">my</span> ($cen,$year,$month,$day)<span style="color:#f92672">=</span>($0,$1,$2,$3);
  <span style="color:#66d9ef">if</span> ($cen<span style="color:#f92672">==</span><span style="color:#ae81ff">2</span>) {
    $year<span style="color:#f92672">+=</span><span style="color:#ae81ff">1900</span>;
  } <span style="color:#66d9ef">elsif</span> ($cen<span style="color:#f92672">==</span><span style="color:#ae81ff">1</span>) {
    $year<span style="color:#f92672">+=</span><span style="color:#ae81ff">2000</span>;
  } <span style="color:#66d9ef">else</span> {
    warn <span style="color:#e6db74">&#34;$dc has invalid century digit $cen\n&#34;</span>;
    <span style="color:#66d9ef">next</span>;
  }
  <span style="color:#66d9ef">if</span> ($month <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> $month <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">12</span>) {
    warn <span style="color:#e6db74">&#34;$dc has invalid month $month\n&#34;</span>;
    <span style="color:#66d9ef">next</span>;
  }
  <span style="color:#66d9ef">my</span> $d;
  CATCH {
    $d<span style="color:#f92672">=</span>Date<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>($year,$month,$day);
  }
  <span style="color:#66d9ef">unless</span> (defined $d) {
    warn <span style="color:#e6db74">&#34;$dc has invalid day $day\n&#34;</span>;
    <span style="color:#66d9ef">next</span>;
  }
  say $d<span style="color:#f92672">.</span>yyyy<span style="color:#f92672">-</span>mm<span style="color:#f92672">-</span>dd;
}
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-038/ruben-westerberg/perl6/ch-1.p6">Ruben Westerberg</a> used a quite interesting method to construct his regexes:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">my</span> $m<span style="color:#f92672">=</span>(<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span><span style="color:#ae81ff">12</span>)<span style="color:#f92672">&gt;&gt;.</span>fmt(<span style="color:#e6db74">&#34;%02d&#34;</span>)<span style="color:#f92672">.</span>join(<span style="color:#e6db74">&#34;|&#34;</span>);
</code></pre></div><p>Just in case you don&rsquo;t get it, the value of <code>$m</code> is now:</p>
<pre><code>01|02|03|04|05|06|07|08|09|10|11|12
</code></pre>
<p>He also used the same method for building a regex for days in the <code>01..31</code> range. Ruben&rsquo;s program is fairly compact:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">my</span> $m<span style="color:#f92672">=</span>(<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span><span style="color:#ae81ff">12</span>)<span style="color:#f92672">&gt;&gt;.</span>fmt(<span style="color:#e6db74">&#34;%02d&#34;</span>)<span style="color:#f92672">.</span>join(<span style="color:#e6db74">&#34;|&#34;</span>);
<span style="color:#66d9ef">my</span> $d<span style="color:#f92672">=</span>(<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span><span style="color:#ae81ff">31</span>)<span style="color:#f92672">&gt;&gt;.</span>fmt(<span style="color:#e6db74">&#34;%02d&#34;</span>)<span style="color:#f92672">.</span>join(<span style="color:#e6db74">&#34;|&#34;</span>);

<span style="color:#66d9ef">for</span> @<span style="color:#960050;background-color:#1e0010">*</span>ARGS {
    <span style="color:#66d9ef">if</span> <span style="color:#e6db74">/(1|2)(&lt;[0..9]&gt;**2)(&lt;$m&gt;)(&lt;$d&gt;)/</span> {
        put <span style="color:#e6db74">&#34;Input $_ OK&#34;</span>;
        put ($0<span style="color:#f92672">==</span><span style="color:#ae81ff">1</span>??<span style="color:#e6db74">&#34;20$1&#34;</span><span style="color:#f92672">!!</span><span style="color:#e6db74">&#34;19$1&#34;</span>,$2,$3)<span style="color:#f92672">.</span>join(<span style="color:#e6db74">&#34;-&#34;</span>);
        <span style="color:#66d9ef">next</span>;
    }
    <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;Input $_ invalid&#34;</span>;
}
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-038/ryan-thompson/perl6/ch-1.p6">Ryan Thompson</a> rolled out manually the whole validation process:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">MAIN</span>( Int $date ) {
    $date <span style="color:#f92672">~~</span> <span style="color:#f92672">/^</span>
        $<span style="color:#960050;background-color:#1e0010">&lt;</span>cent<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> [ <span style="color:#e6db74">&lt;[12]&gt;</span> ]                         <span style="color:#75715e"># Century (1:1900,2:2000)</span>
        $<span style="color:#960050;background-color:#1e0010">&lt;</span>yy<span style="color:#f92672">&gt;</span>   <span style="color:#f92672">=</span> [ <span style="color:#f92672">\</span>d <span style="color:#f92672">\</span>d  ]                         <span style="color:#75715e"># Year    (2-digit)</span>
        $<span style="color:#960050;background-color:#1e0010">&lt;</span>mm<span style="color:#f92672">&gt;</span>   <span style="color:#f92672">=</span> [ <span style="color:#ae81ff">0</span><span style="color:#e6db74">&lt;[1..9]&gt;</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">1</span><span style="color:#e6db74">&lt;[012]&gt;</span> ]           <span style="color:#75715e"># Month   (01..12)</span>
        $<span style="color:#960050;background-color:#1e0010">&lt;</span>dd<span style="color:#f92672">&gt;</span>   <span style="color:#f92672">=</span> [ <span style="color:#ae81ff">0</span><span style="color:#e6db74">&lt;[1..9]&gt;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&lt;[12]&gt;</span><span style="color:#f92672">\</span>d <span style="color:#f92672">|</span> <span style="color:#ae81ff">3</span><span style="color:#e6db74">&lt;[01]&gt;</span> ] <span style="color:#75715e"># Day     (01..31)</span>
    $/ <span style="color:#f92672">or</span> die <span style="color:#e6db74">&#34;Usage: $*PROGRAM Cyymmdd&#34;</span>;

    <span style="color:#66d9ef">my</span> Int $yyyy <span style="color:#f92672">=</span> ($<span style="color:#960050;background-color:#1e0010">&lt;</span>cent<span style="color:#f92672">&gt;</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">18</span> <span style="color:#f92672">~</span> $<span style="color:#960050;background-color:#1e0010">&lt;</span>yy<span style="color:#f92672">&gt;</span>)<span style="color:#f92672">.</span>Int;

    die <span style="color:#e6db74">&#34;$yyyy-$&lt;mm&gt; does not have $&lt;dd&gt; days&#34;</span>
        <span style="color:#66d9ef">if</span> days<span style="color:#f92672">-</span>in($yyyy, $<span style="color:#960050;background-color:#1e0010">&lt;</span>mm<span style="color:#f92672">&gt;.</span>Int) <span style="color:#f92672">&lt;</span> $<span style="color:#960050;background-color:#1e0010">&lt;</span>dd<span style="color:#f92672">&gt;</span>;

    say <span style="color:#e6db74">&#34;$yyyy-$&lt;mm&gt;-$&lt;dd&gt;&#34;</span>;

}

<span style="color:#75715e"># Return the number of days in the given month (with year specified so</span>
<span style="color:#75715e"># we can check if it is a leap year)</span>
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">days</span>-in( Int $y, Int $m ) {
    <span style="color:#66d9ef">my</span> @days <span style="color:#f92672">=</span> (<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">31</span>, <span style="color:#ae81ff">28</span>, <span style="color:#ae81ff">31</span>, <span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">31</span>, <span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">31</span>, <span style="color:#ae81ff">31</span>, <span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">31</span>, <span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">31</span>);
    @days[<span style="color:#ae81ff">2</span>]<span style="color:#f92672">++</span> <span style="color:#66d9ef">if</span> leap<span style="color:#f92672">-</span>year($y);
    @days[$m];
}
</code></pre></div><p>I skipped the code of the <code>leap-year</code>subroutine (probably copied from Ryan&rsquo;s Perl 5 implementation of the same task), since it could be replaced with the <a href="https://docs.raku.org/routine/is-leap-year">is-leap-year</a> built-in function provided by Raku.</p>
<h2 id="task-2-a-scrabble-like-word-game">Task #2: A Scrabble-Like Word Game</h2>
<p>This is derived in part from my <a href="http://blogs.perl.org/users/laurent_r/2019/12/perl-weekly-challenge-38-date-finder-and-word-game.html">blog post</a> made in answer to the <a href="https://perlweeklychallenge.org/blog/perl-weekly-challenge-038/">Week 38 of the Perl Weekly Challenge</a> organized by  <a href="http://blogs.perl.org/users/mohammad_s_anwar/">Mohammad S. Anwar</a> as well as answers made by others to the same challenge.</p>
<p>The challenge reads as follows:</p>
<p><em>Lets assume we have tiles as listed below, with an alphabet (A..Z) printed on them. Each tile has a value, e.g. A (1 point), B (4 points) etc. You are allowed to draw 7 tiles from the lot randomly. Then try to form a word using the 7 tiles with maximum points altogether. You don’t have to use all the 7 tiles to make a word. You should try to use as many tiles as possible to get the maximum points.</em></p>
<p><em>For example, A (x8) means there are 8 tiles with letter A.</em></p>
<pre><code>1 point

    A (x8), G (x3), I (x5), S (x7), U (x5), X (x2), Z (x5)

2 points

    E (x9), J (x3), L (x3), R (x3), V (x3), Y (x5)

3 points

    F (x3), D (x3), P (x5), W (x5)

4 points

    B (x5), N (x4)

5 points

    T (x5), O (x3), H (x3), M (x4), C (x4)

10 points

    K (x2), Q (x2)
</code></pre>
<p>So, the game is essentially similar to Scrabble, except that there is no game board.</p>
<h2 id="my-solution">My Solution</h2>
<p>I don&rsquo;t see any way to solve correctly this task without a brute-force approach, i.e. trying all possibilities to find the best score.</p>
<p>Just as for some previous challenges, I will use a <code>words.txt</code> file containing 113,809 lower-case English words usually accepted for crossword puzzles and other word games. The <code>words.txt</code> file can be found <a href="https://github.com/LaurentRosenfeld/thinkperl6/tree/master/Supplementary">on my Github repository</a>. The original list was contributed to the public domain by Internet activist Grady Ward in the context of the <a href="https://en.wikipedia.org/wiki/Moby_Project">Moby Project</a>. This word list is also mirrored at <a href="https://www.gutenberg.org/files/3201/files/">Project Gutenberg</a>.</p>
<p>For the purpose of testing the programs below, the <code>words.txt</code> file is located in my current directory.</p>
<p>The solution is essentially as follows: read the file of authorized words, normalize the words by putting their letters in alphabetical order and store in a <code>%word-list</code> hash the normalized versions as a key, and the original word as a value.</p>
<p>Store the available letter tiles in a <code>Bag</code>. Then pick seven tiles (or any other number) from the bag, use the <code>combinations</code> method to produce all tile combinations from the drawn letters, sort each combination alphabetically and look up for the result in the hash. If the result is found, compute its score and retain the word with the highest score so far. At the end, print the word with the highest score.</p>
<pre><code>use v6;

constant %tile-values =
    A =&gt; 1, B =&gt; 4, C =&gt; 5, D =&gt; 3, E =&gt; 2,
    F =&gt; 3, G =&gt; 1, H =&gt; 5, I =&gt; 1, J =&gt; 2,
    K =&gt; 10, L =&gt; 2, M =&gt; 5, N =&gt; 4, O =&gt; 5,
    P =&gt; 3, Q =&gt; 10, R =&gt; 2, S =&gt; 1, T =&gt; 5,
    U =&gt; 1, V =&gt; 2, W =&gt; 3, X =&gt; 1, Y =&gt; 2, Z =&gt; 1;

constant %tile-count =
    A =&gt; 8, B =&gt; 5, C =&gt; 4, D =&gt; 3, E =&gt; 9,
    F =&gt; 3, G =&gt; 3, H =&gt; 3, I =&gt; 5, J =&gt; 3,
    K =&gt; 2, L =&gt; 3, M =&gt; 4, N =&gt; 4, O =&gt; 3,
    P =&gt; 5, Q =&gt; 2, R =&gt; 3, S =&gt; 7, T =&gt; 5,
    U =&gt; 5, V =&gt; 3, W =&gt; 5, X =&gt; 2, Y =&gt; 5, Z =&gt; 5;

my $tile-bag = (map {$_ xx %tile-count{$_}}, keys %tile-count).Bag;

sub MAIN (Int $count = 7) {
    my %word-list;
    for &quot;words.txt&quot;.IO.lines -&gt; $line {
        next if $line.chars &gt; $count;
        my $ordered = $line.uc.comb.sort.join(&quot;&quot;);
        my $line-value = [+] $ordered.comb.map({%tile-values{$_}});
        %word-list{$ordered}&lt;word&gt; = $line;
        # Note we will keep only one word for anagrams, but
        # that's OK since anagrams have the same value
        %word-list{$ordered}&lt;value&gt; = $line-value;
    }
    for 1..10 {
        my @picked-tiles = $tile-bag.pick($count);
        my $max-combination = &quot;&quot;;
        my $max-value = 0;
        for @picked-tiles.combinations -&gt; $candidate {
            my $ordered = $candidate.sort.join(&quot;&quot;);
            next unless %word-list{$ordered}:exists;
            if %word-list{$ordered}&lt;value&gt; &gt; $max-value {
                $max-value = %word-list{$ordered}&lt;value&gt;;
                $max-combination = $ordered;
            }
        }
        say &quot;The best candidate for list &quot;, @picked-tiles.join(&quot;&quot;), &quot; is:&quot;;
        say &quot;    No word found!&quot; and next unless $max-value;
        say &quot;    %word-list{$max-combination}&lt;word&gt; (score: $max-value)&quot;;
    }
}
</code></pre>
<p>Note that the program is not very fast (2 to 3 seconds for 7 tiles), but that&rsquo;s mainly due to time required to read the 113k-word list and store the words into a hash. One the hash is populated, finding the best solution is quite fast. This is the reason for which I decided to run the solution-finding part ten times once the hash is populated. If I were going to make a real-life solution for the challenge, I would store the hash in a file, as I have shown previously, notably on the <a href="http://blogs.perl.org/users/laurent_r/2019/05/perl-weekly-challenge-7-niven-numbers-and-word-ladders.html">word ladder challenge</a> in May of this year.</p>
<p>This is an example run:</p>
<pre><code>$ time perl6  scrabble.p6 7
The best candidate for list MESWAAG is:
    wames (score: 12)
The best candidate for list XPSPBAG is:
    paps (score: 8)
The best candidate for list KISCPAC is:
    spick (score: 20)
The best candidate for list BMRPSPU is:
    bumps (score: 14)
The best candidate for list LZRYVBY is:
    byrl (score: 10)
The best candidate for list KHEBLZP is:
    kelp (score: 17)
The best candidate for list FHIOUHI is:
    foh (score: 13)
The best candidate for list VXAWSJH is:
    wash (score: 10)
The best candidate for list LIXMPGZ is:
    limp (score: 11)
The best candidate for list AJSFBOF is:
    boffs (score: 16)

real    0m2,751s
user    0m0,000s
sys     0m0,031s
</code></pre>
<p>I know that some words found above may seem funny or uncommon, but they belong to the <code>words.txt</code> file that is one of the official sources of words for word games.</p>
<h2 id="alternative-solutions-1">Alternative Solutions</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-038/arne-sommer/perl6/ch-2.p6">Arno Sommer</a> populated a <code>%value</code> hash and a <code>%count</code> hash with, respectively, the letter values and the time count. He then populated a <code>%dict</code> hash with the uppercase versions of the words of his word file. The program then generates an array of combinations of the picked tiles and keeps the combinations that exists in the dictionary, and finally look the the most valuable combination.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">get</span>-dictionary ($file where $file.IO.r)
{
  <span style="color:#66d9ef">return</span> $file<span style="color:#f92672">.</span>IO<span style="color:#f92672">.</span>lines<span style="color:#f92672">.</span>grep(<span style="color:#f92672">*</span> <span style="color:#f92672">!~~</span> <span style="color:#e6db74">/\W/</span>)<span style="color:#f92672">&gt;&gt;.</span>uc<span style="color:#f92672">.</span>Set;
}
<span style="color:#66d9ef">my</span> %dict <span style="color:#f92672">=</span> get<span style="color:#f92672">-</span>dictionary($dictionary);
<span style="color:#66d9ef">my</span> @letters <span style="color:#f92672">=</span> %value<span style="color:#f92672">.</span>keys<span style="color:#f92672">.</span>map({ $_ xx %count{$_} })<span style="color:#f92672">.</span>sort<span style="color:#f92672">.</span>flat;
<span style="color:#66d9ef">my</span> @legal<span style="color:#f92672">-</span>words <span style="color:#f92672">=</span> @letters<span style="color:#f92672">.</span>combinations(<span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> $length)<span style="color:#f92672">&gt;&gt;.</span>join<span style="color:#f92672">.</span>unique<span style="color:#f92672">.</span>grep({ %dict{$_} });
<span style="color:#66d9ef">my</span> %candidates;
<span style="color:#66d9ef">for</span> @legal<span style="color:#f92672">-</span>words <span style="color:#f92672">-&gt;</span> $word
{
  %candidates{$word} <span style="color:#f92672">=</span> $word<span style="color:#f92672">.</span>comb<span style="color:#f92672">.</span>map({ %value{$_} })<span style="color:#f92672">.</span>sum;
}
<span style="color:#66d9ef">my</span> $max<span style="color:#f92672">-</span>val <span style="color:#f92672">=</span> %candidates<span style="color:#f92672">.</span>values<span style="color:#f92672">.</span>max;

say <span style="color:#e6db74">&#34;Most valuable word(s) at $max-val points:&#34;</span>;
say %candidates<span style="color:#f92672">.</span>keys<span style="color:#f92672">.</span>grep({ %candidates{$_} <span style="color:#f92672">==</span> $max<span style="color:#f92672">-</span>val })<span style="color:#f92672">.</span>sort<span style="color:#f92672">.</span>join(<span style="color:#e6db74">&#34;, &#34;</span>), <span style="color:#e6db74">&#34;.&#34;</span>;
</code></pre></div><p>I may misunderstand something, but some code lines seem to be missing from Arne&rsquo;s code on the GitHub repository, at least the one where the tiles are picked from the tiles bag. Also, I&rsquo;m afraid this program misses some candidates: to me, either you must order the letters of words inserted in the <code>%dict</code> hash, or you must use the <code>permutations</code> method rather than the <code>combinations</code> method (using bags is another solution). Note, however, that Arne&rsquo;s <a href="https://raku-musings.com/date-word.html">blog post</a> has much more than this code sample, so look at it.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-038/daniel-mita/perl6/ch-2.p6">Daniel Mita</a> created a <code>%value</code> hash and a <code>%tiles</code> bag to store, respectively, the letter values and the time count. His program then picks some tiles, loads them in a bag, and reads the words file and keeps the words which are contained in or equal to the bag of picked letters. Finally, it sorts the candidates by value to find the most valuable one:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">MAIN</span> (
  Int $amount where * &gt; 0 = 7, #= Number of tiles to pick (default: 7)
  --&gt; Nil
) {
  given %tiles<span style="color:#f92672">.</span>pick($amount)<span style="color:#f92672">.</span>Bag <span style="color:#f92672">-&gt;</span> %picked {
    <span style="color:#e6db74">&#34;Tiles: %picked.kxxv.join()&#34;</span><span style="color:#f92672">.</span>say;
    <span style="color:#75715e"># source: https://www.wordgamedictionary.com/sowpods/download/sowpods.txt</span>
    <span style="color:#e6db74">&#34;Winner: $_.key() for $_.value()&#34;</span><span style="color:#f92672">.</span>say with
      $<span style="color:#960050;background-color:#1e0010">?</span>FILE<span style="color:#f92672">.</span>IO<span style="color:#f92672">.</span>parent<span style="color:#f92672">.</span>add(<span style="color:#e6db74">&#39;sowpods.txt&#39;</span>)<span style="color:#f92672">.</span>slurp<span style="color:#f92672">.</span>uc<span style="color:#f92672">.</span>words
      <span style="color:#f92672">.</span>grep({ <span style="color:#f92672">.</span>chars <span style="color:#960050;background-color:#1e0010">≤</span> $amount <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">.</span>comb <span style="color:#960050;background-color:#1e0010">⊆</span> %picked })
      <span style="color:#f92672">.</span>map(<span style="color:#66d9ef">sub</span> {
        given $<span style="color:#960050;background-color:#1e0010">^</span>a <span style="color:#f92672">=&gt;</span> $a<span style="color:#f92672">.</span>comb<span style="color:#f92672">.</span>map({ %values{$_} })<span style="color:#f92672">.</span>sum {
          sprintf(<span style="color:#e6db74">&#34;%-{$amount}s: %u&#34;</span>, <span style="color:#f92672">|.</span>kv)<span style="color:#f92672">.</span>say;
          <span style="color:#f92672">.</span><span style="color:#66d9ef">return</span>;
        }
      })<span style="color:#f92672">.</span>sort({
        given $<span style="color:#960050;background-color:#1e0010">^</span>b<span style="color:#f92672">.</span>value <span style="color:#e6db74">&lt;=&gt;</span> $<span style="color:#960050;background-color:#1e0010">^</span>a<span style="color:#f92672">.</span>value {
          when Same { $a<span style="color:#f92672">.</span>key<span style="color:#f92672">.</span>chars <span style="color:#e6db74">&lt;=&gt;</span> $b<span style="color:#f92672">.</span>key<span style="color:#f92672">.</span>chars }
          default { $_ }
        }
      })<span style="color:#f92672">.</span>first;
  }
}
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-038/kevin-colyer/perl6/ch-2.p6">Kevin Colyer</a> wrote a fairly long program doing all kinds of interesting things, but I&rsquo;ll quote only the subroutine doing the most important work. Kevin&rsquo;s program first populates a <code>%points</code> hash and a <code>%tilebag</code> BagHash with letter values and tile counts. His program then loads the word list into a <code>%wordlist</code> hash where the keys are strings containing the words&rsquo; sorted letters and the values the original word and the score. Kevin&rsquo;s program then uses the <code>drawTiles</code> subroutine which uses the <code>roll</code> method to select some tiles (using the <code>pick</code> method would have been easier). His program then sorts the picked letters, generates combinations and looks up the hash of presorted words:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">makeWords</span>(@tiles) {
    <span style="color:#66d9ef">my</span> @result <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>, <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> @tiles<span style="color:#f92672">.</span>combinations <span style="color:#f92672">-&gt;</span> @cand {
        <span style="color:#66d9ef">next</span> <span style="color:#66d9ef">if</span> @cand<span style="color:#f92672">.</span>elems <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span>;
        <span style="color:#66d9ef">my</span> $cand<span style="color:#f92672">=</span>@cand<span style="color:#f92672">.</span>sort<span style="color:#f92672">.</span>join;
        <span style="color:#66d9ef">next</span> <span style="color:#66d9ef">unless</span> %wordlist{$cand}:exists;
        <span style="color:#66d9ef">my</span> ($s,$w)<span style="color:#f92672">=</span> %wordlist{$cand};
        <span style="color:#66d9ef">if</span> $s <span style="color:#f92672">&gt;</span> @result[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">and</span> $cand<span style="color:#f92672">.</span>chars <span style="color:#f92672">=&gt;</span> @result[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>chars {
            @result[<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>]<span style="color:#f92672">=</span>$w,$s;
        };
    }
    <span style="color:#66d9ef">return</span> @result;
}
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-038/noud/perl6/ch-2.p6">Noud</a> first populated a <code>%points</code> hash and a <code>%num_tiles</code> hash with letter values  and tile counts. Noud&rsquo;s program then reads sequentially the word file and retains all the words whose letters are a subset of Bag containing the picked letters. This is Noud&rsquo;s subroutine doing the bulk of the work:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">get_best_word</span>(%picked) {
    <span style="color:#66d9ef">my</span> @picked_words;
    <span style="color:#66d9ef">for</span> <span style="color:#e6db74">&#34;/usr/share/dict/words&#34;</span><span style="color:#f92672">.</span>IO<span style="color:#f92672">.</span>slurp<span style="color:#f92672">.</span>uc<span style="color:#f92672">.</span>words <span style="color:#f92672">-&gt;</span> $word {
        <span style="color:#66d9ef">if</span> ($word<span style="color:#f92672">.</span>comb <span style="color:#960050;background-color:#1e0010">⊆</span> %picked) {
            @picked_words<span style="color:#f92672">.</span>push(((%points{$_} <span style="color:#66d9ef">for</span> $word<span style="color:#f92672">.</span>comb)<span style="color:#f92672">.</span>sum, $word));
        }
    }

    sort(@picked_words)[<span style="color:#f92672">*-</span><span style="color:#ae81ff">1</span>];
}
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-038/simon-proctor/perl6/ch-2.p6">Simon Proctor</a> first populated a constant <code>%SCORES</code> hash with the letter values and a constant <code>$BAG</code> Bag with the tile counts. He also built a <code>Tile</code> class providing a number of utility methods. He then picked some letters and inserted them in the <code>$match-bag</code> Bag. The bulk of the work is done in the <code>MAIN</code> subroutine:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">MAIN</span>(
    Int() $tile-count = 7 #= Number of tiles to draw from the bag (Default 7)
) {
     <span style="color:#66d9ef">my</span> @tiles <span style="color:#f92672">=</span> $BAG<span style="color:#f92672">.</span>pick( $tile<span style="color:#f92672">-</span>count );
     say <span style="color:#e6db74">&#34;Tiles drawn {join(&#34;</span>,<span style="color:#e6db74">&#34;, @tiles)} max possible score {[+] @tiles}&#34;</span>;
     <span style="color:#66d9ef">my</span> $match<span style="color:#f92672">-</span>bag <span style="color:#f92672">=</span> Bag<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>( @tiles );
     <span style="color:#66d9ef">my</span> $data<span style="color:#f92672">-</span>channel <span style="color:#f92672">=</span> Channel<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>;
     <span style="color:#66d9ef">my</span> @p;
     @p<span style="color:#f92672">.</span>push( start check<span style="color:#f92672">-</span>words( $data<span style="color:#f92672">-</span>channel, $match<span style="color:#f92672">-</span>bag ) ) <span style="color:#66d9ef">for</span> <span style="color:#f92672">^</span><span style="color:#ae81ff">3</span>;
     $data<span style="color:#f92672">-</span>channel<span style="color:#f92672">.</span>send($_) <span style="color:#66d9ef">for</span> <span style="color:#e6db74">&#34;/etc/dictionaries-common/words&#34;</span><span style="color:#f92672">.</span>IO<span style="color:#f92672">.</span>lines<span style="color:#f92672">.</span>grep(<span style="color:#f92672">*.</span>codes <span style="color:#f92672">&lt;=</span> $tile<span style="color:#f92672">-</span>count);
     $data<span style="color:#f92672">-</span>channel<span style="color:#f92672">.</span>close;
     await @p;
     <span style="color:#66d9ef">my</span> $result <span style="color:#f92672">=</span> @p<span style="color:#f92672">.</span>sort( { $<span style="color:#960050;background-color:#1e0010">^</span>b<span style="color:#f92672">.</span>result<span style="color:#f92672">.</span>value <span style="color:#f92672">cmp</span> $<span style="color:#960050;background-color:#1e0010">^</span>a<span style="color:#f92672">.</span>result<span style="color:#f92672">.</span>value } )<span style="color:#f92672">.</span>head<span style="color:#f92672">.</span>result;
     $result<span style="color:#f92672">.</span>value ?? say <span style="color:#e6db74">&#34;{$result.key} scores {$result.value}&#34;</span> <span style="color:#f92672">!!</span> say <span style="color:#e6db74">&#34;I couldn&#39;t find a word&#34;</span>;
}
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">check</span>-words( Channel $input, Bag $match-bag ) {
    <span style="color:#66d9ef">my</span> $result <span style="color:#f92672">=</span> ( <span style="color:#e6db74">&#34;&#34;</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">0</span> );
    react {
        whenever $input <span style="color:#f92672">-&gt;</span> $word {
            <span style="color:#66d9ef">my</span> $checked <span style="color:#f92672">=</span> valid<span style="color:#f92672">-</span>word( $word, $match<span style="color:#f92672">-</span>bag );
            <span style="color:#66d9ef">my</span> $score <span style="color:#f92672">=</span> [<span style="color:#f92672">+</span>] $checked<span style="color:#f92672">.</span>kxxv;
            <span style="color:#66d9ef">if</span> $score <span style="color:#f92672">&gt;</span> $result<span style="color:#f92672">.</span>value {
                $result <span style="color:#f92672">=</span> ( $word <span style="color:#f92672">=&gt;</span> $score );
            }
        }
    }
    <span style="color:#66d9ef">return</span> $result;
}
</code></pre></div><p>Note that Simon is using channels for parallel processing. In my tests, it took 2.7 seconds to process 10 letter selections (most of which presumably to load the word dictionary), so I&rsquo;m not sure we really need parallel processing here, but it is always very interesting to look at these possibilities (I must admit that I haven&rsquo;t really worked with them over the last two or three years and that I don&rsquo;t really remember how to use them).</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-038/javier-luque/perl6/ch-2.p6">Javier Luque</a> first populated a <code>%tile_metadata</code> hash containing both the values and time counts. Most of the work is done in the following subroutine using the <code>permutations</code> method::</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">find</span>-best-word(@tiles) {
    <span style="color:#66d9ef">my</span> $top_score <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">my</span> $top_word;

    <span style="color:#66d9ef">my</span> @combos <span style="color:#f92672">=</span> @tiles<span style="color:#f92672">.</span>combinations: <span style="color:#ae81ff">1</span><span style="color:#f92672">..</span><span style="color:#ae81ff">7</span>;
    <span style="color:#66d9ef">for</span> @combos <span style="color:#f92672">-&gt;</span> $combo {
        <span style="color:#66d9ef">for</span> $combo<span style="color:#f92672">.</span>permutations <span style="color:#f92672">-&gt;</span> $perms {
            <span style="color:#66d9ef">my</span> $word <span style="color:#f92672">=</span> $perms<span style="color:#f92672">.</span>join;

            <span style="color:#66d9ef">if</span> %valid_words<span style="color:#f92672">.</span>{$word} {
                <span style="color:#66d9ef">my</span> $score <span style="color:#f92672">=</span> calculate<span style="color:#f92672">-</span>score($word);

                <span style="color:#75715e"># If this is the best word store it</span>
                <span style="color:#66d9ef">if</span> ($score <span style="color:#f92672">&gt;</span> $top_score) {
                    $top_score <span style="color:#f92672">=</span> $score;
                    $top_word  <span style="color:#f92672">=</span> $word;
                }
            }
        };
    }

    <span style="color:#66d9ef">return</span> $top_word, $top_score;
}
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-038/roger-bell-west/perl6/ch-2.p6">Roger Bell West</a> first populated a <code>%tilecount</code> and a <code>tilevalue</code> hashes. He then used the <code>grab</code> method (which I did not know about before) to pick the wanted number of tiles from the <code>%tilecount</code> hash. Then, he populated a <code>%w</code> hash with uppercase versions of the words in the word list having less characters that the wanted number of tiles. Finally, his program computes all permutations of the picked letters and tries them against <code>%w</code> word hash, and looks for the best score:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">for</span> @bag<span style="color:#f92672">.</span>permutations <span style="color:#f92672">-&gt;</span> $n {
  <span style="color:#66d9ef">my</span> @candidate<span style="color:#f92672">=</span>$n<span style="color:#f92672">.</span>list;
  <span style="color:#66d9ef">while</span> (@candidate) {
    <span style="color:#66d9ef">my</span> $candidate<span style="color:#f92672">=</span>join(<span style="color:#e6db74">&#39;&#39;</span>,@candidate);
    <span style="color:#66d9ef">if</span> (%tried{$candidate}:exists) {
      <span style="color:#66d9ef">last</span>;
    }
    %tried{$candidate}<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">if</span> (%w{$candidate}:exists) {
      <span style="color:#66d9ef">my</span> $score<span style="color:#f92672">=</span>sum(map {%tilevalue{$_}}, @candidate);
      <span style="color:#66d9ef">if</span> ($score <span style="color:#f92672">&gt;</span> $maxscore) {
        @maxcandidate<span style="color:#f92672">=</span>();
        $maxscore<span style="color:#f92672">=</span>$score;
      }
      <span style="color:#66d9ef">if</span> ($score <span style="color:#f92672">==</span> $maxscore) {
        @maxcandidate<span style="color:#f92672">.</span>push($candidate);
      }
      <span style="color:#66d9ef">last</span>;
    }
    @candidate<span style="color:#f92672">.</span>pop;
  }
}

<span style="color:#66d9ef">print</span> join(<span style="color:#e6db74">&#39;&#39;</span>,sort @bag),<span style="color:#e6db74">&#34;\n&#34;</span>;
<span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;$maxscore: &#34;</span>,join(<span style="color:#e6db74">&#39; &#39;</span>,sort @maxcandidate),<span style="color:#e6db74">&#34;\n&#34;</span>;
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-038/ruben-westerberg/perl6/ch-2.p6">Ruben Westerberg</a> also populated various data structures for letter values and letter counts, but did it in an impressively compact way:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">my</span> @l<span style="color:#f92672">=</span>comb <span style="color:#e6db74">&#34;&#34;</span>, <span style="color:#e6db74">&#34;AGISUXZEJLRVYFDPWBNTOHMCKQ&#34;</span>;
<span style="color:#66d9ef">my</span> @c<span style="color:#f92672">=</span>(<span style="color:#ae81ff">8</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">7</span>,<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">9</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">2</span>);
<span style="color:#66d9ef">my</span> @v<span style="color:#f92672">=</span>((<span style="color:#ae81ff">1</span>) xx <span style="color:#ae81ff">7</span>, (<span style="color:#ae81ff">2</span>) xx <span style="color:#ae81ff">6</span>,(<span style="color:#ae81ff">3</span>) xx <span style="color:#ae81ff">4</span>,(<span style="color:#ae81ff">4</span>) xx <span style="color:#ae81ff">2</span>,(<span style="color:#ae81ff">5</span>) xx <span style="color:#ae81ff">5</span>,(<span style="color:#ae81ff">10</span>) xx <span style="color:#ae81ff">2</span>)<span style="color:#f92672">.</span>flat;

<span style="color:#66d9ef">my</span> BagHash $tileBag<span style="color:#f92672">.=</span><span style="color:#66d9ef">new</span><span style="color:#f92672">-</span>from<span style="color:#f92672">-</span>pairs((@l Z @c)<span style="color:#f92672">.</span>flat<span style="color:#f92672">.</span>pairup); <span style="color:#75715e">#Bag of all tiles</span>
<span style="color:#66d9ef">my</span> %values<span style="color:#f92672">=</span>(@l Z @v)<span style="color:#f92672">.</span>flat;  <span style="color:#75715e">#Letter value map</span>
<span style="color:#66d9ef">my</span> BagHash $drawBag;        <span style="color:#75715e">#Bag of drawn tiles</span>
</code></pre></div><p>Ruben&rsquo;s way of selecting tiles is impressively less concise:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">for</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">..</span><span style="color:#ae81ff">7</span> {
    <span style="color:#66d9ef">my</span> $i<span style="color:#f92672">=</span>$tileBag<span style="color:#f92672">.</span>total<span style="color:#f92672">.</span>rand<span style="color:#f92672">.</span>Int;
    <span style="color:#66d9ef">my</span> $t<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">my</span> $selected;
    <span style="color:#66d9ef">for</span> <span style="color:#e6db74">&#34;A&#34;</span><span style="color:#f92672">..</span><span style="color:#e6db74">&#34;Z&#34;</span> {
        $t<span style="color:#f92672">+=</span>$tileBag{$_};
        <span style="color:#66d9ef">if</span> $t <span style="color:#f92672">&gt;</span> $i {
            $tileBag{$_}<span style="color:#f92672">--</span>;
            $drawBag{$_}<span style="color:#f92672">++</span>;
            <span style="color:#66d9ef">last</span>;
        }
    }
}
</code></pre></div><p>Using the <code>pick</code> method could have reduced all this to a single code statement.</p>
<p>The bulk of the work is then done as follows:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#75715e">#Find all words which can be made from the drawn bag</span>
<span style="color:#e6db74">&#34;../words_alpha.txt&#34;</span><span style="color:#f92672">.</span>IO<span style="color:#f92672">.</span>lines<span style="color:#f92672">.</span>map({<span style="color:#f92672">.</span>uc})<span style="color:#f92672">.</span>grep({$_<span style="color:#f92672">.</span>chars <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">7</span>}) <span style="color:#f92672">==&gt;</span>
grep({ <span style="color:#f92672">.</span>comb<span style="color:#f92672">.</span>BagHash (<span style="color:#f92672">&lt;=</span>) $drawBag; }) <span style="color:#f92672">==&gt;</span>
map({<span style="color:#f92672">|</span>($_, %values{<span style="color:#f92672">.</span>comb}<span style="color:#f92672">.</span>sum)})<span style="color:#f92672">==&gt;</span>
<span style="color:#66d9ef">my</span> %contenders;

<span style="color:#75715e">#Print sores of all possible words in asscending order</span>
<span style="color:#66d9ef">my</span> @sorted<span style="color:#f92672">=</span>%contenders<span style="color:#f92672">.</span>keys<span style="color:#f92672">.</span>sort({%contenders{$<span style="color:#960050;background-color:#1e0010">^</span>a} <span style="color:#e6db74">&lt;=&gt;</span> %contenders{$<span style="color:#960050;background-color:#1e0010">^</span>b}});

put <span style="color:#e6db74">&#34;Contenders (word: score):&#34;</span>;
put <span style="color:#e6db74">&#34;$_: %contenders{$_}&#34;</span> <span style="color:#66d9ef">for</span> @sorted;
put <span style="color:#e6db74">&#34;\nDrawn tiles: $drawBag&#34;</span>;
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-038/ryan-thompson/perl6/ch-2.p6">Ryan Thompson</a> first populated a <code>%val</code> hash, a <code>@bag</code> array, and a <code>dict</code>hash with, respectively, the letter values, tile counts and words of the word list. The bulk of the work is then done in the following subroutine using permutations of the selected tiles:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">best</span>-word( @seven ) {
    <span style="color:#66d9ef">my</span> %best <span style="color:#f92672">=</span> ( word <span style="color:#f92672">=&gt;</span> <span style="color:#e6db74">&#39;&#39;</span>, score <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">0</span> );

    <span style="color:#66d9ef">for</span> @seven<span style="color:#f92672">.</span>permutations <span style="color:#f92672">-&gt;</span> @p {
        <span style="color:#75715e"># Here we check every 1..7-length prefix of the permutation</span>
        <span style="color:#66d9ef">my</span> $word <span style="color:#f92672">=</span> @p<span style="color:#f92672">.</span>join;
        <span style="color:#66d9ef">while</span> $word<span style="color:#f92672">.</span>chars {
            <span style="color:#66d9ef">if</span> %dict{$word}:exists {
                <span style="color:#66d9ef">my</span> $score <span style="color:#f92672">=</span> word<span style="color:#f92672">-</span>score($word);
                %best<span style="color:#f92672">&lt;</span>word score<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> $word, $score <span style="color:#66d9ef">if</span> $score <span style="color:#f92672">&gt;</span> %best<span style="color:#e6db74">&lt;score&gt;</span>;
            }
            $word <span style="color:#f92672">=</span> $word<span style="color:#f92672">.</span>chop;
        }
    }

    %best;
}
</code></pre></div><h2 id="see-also">SEE ALSO</h2>
<p>Only two blog posts (besides mine) this time:</p>
<ul>
<li>
<p>Arne Sommer: <a href="https://raku-musings.com/date-word.html;">https://raku-musings.com/date-word.html;</a></p>
</li>
<li>
<p>Javier Luque: <a href="https://perlchallenges.wordpress.com/2019/12/10/perl-weekly-challenge-038/">https://perlchallenges.wordpress.com/2019/12/10/perl-weekly-challenge-038/</a>.</p>
</li>
</ul>
<h2 id="wrapping-up">Wrapping up</h2>
<p>Please let me know if I forgot any of the challengers or if you think my explanation of your code misses something important (send me an e-mail or just raise an issue against this GitHub page).</p>
<p>If you want to participate to the Perl Weekly Challenge, please connect to <a href="https://perlweeklychallenge.org/">this site</a>.</p>

                </div>
            </div>
        </div>
    </div>
</section>


<!-- Call To Action Section Start -->
<section id="call-to-action">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2 class="title wow fadeInDown" data-wow-delay=".3s" data-wow-duration="500ms">SO WHAT DO YOU THINK ?</h2>
                    <p class="wow fadeInDown" data-wow-delay=".5s" data-wow-duration="500ms">If you have any suggestions or ideas then please do share with us.</p>
                    <a href="/contact" class="btn btn-default btn-contact wow fadeInDown" data-wow-delay=".7s" data-wow-duration="500ms">Contact with me</a>
                </div>
            </div>

        </div>
    </div>
</section>
<!-- Call To Action Section End -->



<!-- Footer Section Start -->
<footer id="footer">
    <div class="container">
        <div class="row content-justify-between">
            <div class="col-md-8 col-12 text-center text-lg-left text-md-left">
                <p class="copyright">Copyright:
                    <span>
                        2019 - 2025
                    </span> The Weekly Challenge. Theme Design and Developed by
                    <a href="http://www.Themefisher.com" rel="noreferrer" rel="noreferrer" target="_blank">Themefisher</a>.
                </p>
            </div>
            <div class="col-md-4 col-12">
                <!-- Social Media -->
                <ul class="social text-center text-md-right text-lg-right">
                    <li>
                        <a href="https://twitter.com/PerlWChallenge" class="twitter" rel="noreferrer" target="_blank" title="Follow us">
                            <i class="ion-social-twitter"></i>
                        </a>
                    </li>
                    <li>
                        <a href="/rss.xml" class="rss" target="_blank" title="RSS Feed">
                            <i class="ion-social-rss"></i>
                        </a>
                    </li>
                </ul>
            </div>
        </div>
    </div>
</footer>
<!-- footer section end -->

<!-- jquery -->
<script src="https://theweeklychallenge.org/plugins/jquery/jquery.min.js"></script>
<!-- Form Validation -->
<script src="https://theweeklychallenge.org/plugins/form-validation/jquery.form.min.js"></script>
<script src="https://theweeklychallenge.org/plugins/form-validation/jquery.validate.min.js"></script>
<!-- slick slider -->
<script src="https://theweeklychallenge.org/plugins/slick/slick.min.js"></script>
<!-- bootstrap js -->
<script src="https://theweeklychallenge.org/plugins/bootstrap/bootstrap.min.js"></script>
<!-- chart js -->
<script src="https://theweeklychallenge.org/plugins/chart/highstock.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/drilldown.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/data.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/chart.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/pwc-challenge.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/gc-challenge.js"></script>
<!-- wow js -->
<script src="https://theweeklychallenge.org/plugins/wow-js/wow.min.js"></script>
<!-- slider js -->
<script src="https://theweeklychallenge.org/plugins/slider/slider.js"></script>
<!-- Fancybox -->
<script src="https://theweeklychallenge.org/plugins/facncybox/jquery.fancybox.js"></script>
<!-- template main js -->

<script src="https://theweeklychallenge.org/js/script.min.js"></script>
<!-- google analitycs -->

<script async src="https://www.googletagmanager.com/gtag/js?id=G-CJTPYM9SB8"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-CJTPYM9SB8');
</script>
</body>

</html>

