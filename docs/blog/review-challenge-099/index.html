<!DOCTYPE html>
<html class="no-js" lang="en-us">
<head>
    <!-- Basic Page Needs -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:title"       content="The Weekly Challenge - Perl & Raku"/>
    <meta property="og:type"        content="website"/>
    <meta property="og:url"         content="https://theweeklychallenge.org/"/>
    <meta property="og:image"       content="https://theweeklychallenge.org/images/about/about.jpg"/>
    <meta property="og:description" content="You do not have to be an expert."/>
    <meta name="twitter:card"       content="summary" />
    <meta name="twitter:image"      content="https://theweeklychallenge.org/images/about/about.jpg"/>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <meta name="description" content="Colin Crain › Perl Weekly Review #099">
    <meta name="author" content="The Weekly Challenge Team">
    <meta name="generator" content="Hugo 0.67.0-DEV" />

    <link rel="me" href="https://fosstodon.org/@manwar">

    <!-- Mobile Specific Metas -->
    <meta name="format-detection" content="telephone=no">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Colin Crain › Perl Weekly Review #099</title>
    <link rel="icon" href="https://theweeklychallenge.org/images/favicon.ico">

    
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css"/>

    <!-- Twitter Bootstrs CSS -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/bootstrap/bootstrap.min.css">
    <!-- Ionicons Fonts Css -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/ionicons/ionicons.min.css">
    <!-- animate css -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/animate-css/animate.css">
    <!-- Hero area slider css-->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/slider/slider.css">
    <!-- slick slider -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/slick/slick.css">
    <!-- Fancybox -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/facncybox/jquery.fancybox.css">
    <!-- hover -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/hover/hover-min.css">
    <!-- Google fonts -->
    <link href='https://fonts.googleapis.com/css?family=Source Code Pro' rel='stylesheet'>
    <!-- template main css file -->
    
    <link rel="stylesheet" href="https://theweeklychallenge.org/css/style.min.css" integrity="" media="screen">
    <link rel="stylesheet" href="https://theweeklychallenge.org/css/main.css">

    <style>
        #goTopButton {
            display: none;          
            position: fixed;        
            bottom: 20px;           
            right: 30px;            
            z-index: 99;            
            border: none;           
            outline: none;          
            background-color: red;  
            color: white;           
            cursor: pointer;        
            padding: 15px;          
            border-radius: 10px;    
            font-size: 18px;        
        }

        #goTopButton:hover {
              background-color: #555;
        }
    </style>


</head>

<body>

<button onclick="goTop()" id="goTopButton" title="Go to top">Top</button>

<script>

    topButton = document.getElementById("goTopButton");

    
    window.onscroll = function() { scrollFunction() };

    function scrollFunction() {
        if (document.body.scrollTop > 40 || document.documentElement.scrollTop > 40) {
            topButton.style.display = "block";
        } else {
            topButton.style.display = "none";
        }
    }

    
    function goTop() {
        document.body.scrollTop = 0; 
        document.documentElement.scrollTop = 0; 
    }

</script>

<section class="top-bar animated-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-12">
                <nav class="navbar navbar-expand-lg navbar-light bg-light">
                    <a class="navbar-brand" href="https://theweeklychallenge.org/">
                        <img src="https://theweeklychallenge.org/images/logo.svg" alt="logo">
                    </a>
                    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navgation" aria-controls="navigation"
                        aria-expanded="false" aria-label="Toggle navigation">
                        <span class="navbar-toggler-icon"></span>
                    </button>

                    <div class="collapse navbar-collapse" id="navigation">
                        <ul class="navbar-nav ml-auto">
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/">Home</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/about">About</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/chart">Chart</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/champions">Champions</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/team">Team</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/challenges">Challenges</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/p5-reviews">Perl/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/p6-reviews">Raku/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/recaps">Recaps</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/blogs">Blogs</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/faq">FAQ</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/contact">Contact</a>
                            </li>
                            
                        </ul>
                    </div>
                </nav>
            </div>
        </div>
    </div>
</section>


<section class="global-page-header">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2>Colin Crain › Perl Weekly Review #099</h2>
                    <div class="portfolio-meta">
                        <span>Wednesday, Mar 3, 2021</span>|
                        <span> Tags:
                            perl
                        </span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

<section class="single-post">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                
                <div style="text-align: center" class="post-img">
                    <img class="img-fluid" alt="" src="https://theweeklychallenge.org/images/blog/p5-review-challenge-099.jpg">
                </div>
                
                <div style="text-align: justify" class="post-content">
                    <p>( <em>&hellip;continues from <a href="/blog/review-challenge-098/">previous week</a>.</em> )</p>
<p>Welcome to the Perl review for <strong>Week 099</strong> of the Weekly Challenge! Here we will take the time to discuss the  submissions offered by the team, factor out the common methodologies that came up in those solutions, and highlight some of the unique approaches and unusual code created.</p>
<hr>
<h3 id="why-do-we-do-these-challenges">Why do we do these challenges?</h3>
<p>I suppose any answers to that would be as wide ranging and varied as the people who choose to join the team. One thing is clear: it&rsquo;s not a competition, and there are no judges, even if there is a &ldquo;prize&rdquo; of sorts. About that &ndash; I think of it more as an honorarium periodically awarded to acknowledge the efforts we make towards this strange goal. So there&rsquo;s no determination to find the <em>fastest</em>, or the <em>shortest</em>, or even, in some abstract way, the <em>best</em> way to go about things, although I&rsquo;m certain the individuals have their own aspirations and personal drives. As Perl is such a wonderfully expressive language, this provides quite a bit of fodder to the core idea of TMTOWTDI, producing a gamut of wonderfully varied techniques and solutions.</p>
<p>Even the tasks themselves are often open to a certain amount of discretionary interpretation. What we end up with is a situation where each participant is producing something in the manner they find the most interesting or satisfying. Some team members focus on carefully crafted complete applications that thoroughly vet input data and handle every use case they can think up. Others chose to apply themselves to the logic of the underlying puzzle and making it work in the most elegant way they can. Some eschew modules they would ordinarily reach for, others embrace them, bringing to light wheels perhaps invented years ago that happen to exactly solve the problem in front of them today.</p>
<p>I&rsquo;ve been considering this question for some time and have found one binding commonality between all of us solving these challenges each week, in that however we normally live our lives, the task in front of us more than likely has nothing to do with any of that . And I think this has great value. We all do what we do, out in the real world, and hopefully we do it well. The Weekly Challenge provides a opportunity to do something germane to that life yet distinctly different; if we only do the things we already know how to do we only do the same things over and over. This is where the &ldquo;challenge&rdquo; aspect comes into play.</p>
<p>So we can consider the Weekly Challenge as providing a problem space outside of our comfort zone, as far out from comfort as we wish to take things. From those reaches we can gather and learn things and bring what we want back into our lives. Personally, I think that&rsquo;s its greatest value of all.</p>
<hr>
<p>Every week there is an enormous global collective effort made by the team, analyzing and creatively coding the submissions, and that effort deserves credit due. And that&rsquo;s why I&rsquo;m here, to try and figure out how to do that.</p>
<p>Let&rsquo;s have a look and see what we can find.</p>
<hr>
<p><strong><big>For context</big></strong>  before we begin, you may wish to revisit either of the pages for the <a href="/blog/perl-weekly-challenge-099/"><strong>original tasks</strong></a> or the summary <a href="/blog/recap-challenge-099/"><strong>recap</strong></a> of the challenge. But don&rsquo;t worry, the challenges themselves will be briefly summarized, presented below as we progress from task by task. Oh, and one more thing before we get started:</p>
<h3 id="getting-in-touch-with-us">Getting in Touch with Us</h3>
<p><a href="mailto:pwc.perfectwave@gmail.com"><img src="/images/blog/Email.svg" height="50" width="50"> Email</a> › Please email me (Colin) with any feedback, notes, clarifications or whatnot about this review.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge"><img src="/images/blog/Github.svg" height="50" width="50"> GitHub</a> › Submit a pull request to us for any issues you may find with this page.</p>
<p><a href="https://twitter.com/perlwchallenge"><img src="/images/blog/Twitter.svg" height="50" width="50"> Twitter</a> › Join the discussion on Twitter!</p>
<p>I&rsquo;m always curious as to what the people think of these efforts. Everyone here at the PWC would like to hear any feedback you&rsquo;d like to give.</p>
<p><strong>So finally, without further ado&hellip;</strong></p>
<hr>
<h2 id="---nbsp--nbsp--nbsp---task-1pwc099task1-------nbsp--nbsp--nbsp------nbsp--nbsp--nbsp---task-2pwc099task2---nbsp--nbsp--nbsp----------nbsp--nbsp--nbsp---blogspwc099blogs----nbsp--nbsp--nbsp---">•             <a href="#PWC099TASK1">Task 1</a>                 •             <a href="#PWC099TASK2">Task 2</a>                 •             <a href="#PWC099BLOGS">BLOGS</a>              	•</h2>
<hr>
<h1 id="PWC099TASK1">TASK 1</h1>
<h1 id="pattern-match">Pattern Match</h1>
<p><em>Submitted by: Mohammad S Anwar</em>
You are given a string $S and a pattern $P.</p>
<p>Write a script to check if given pattern validate the entire string.</p>
<p>Print 1 if pass otherwise 0.</p>
<p>The patterns can also have the following characters:</p>
<pre><code> ? - Match any single character.
 * - Match any sequence of characters.
</code></pre>
<p><strong>Example 1:</strong></p>
<pre><code>    Input: $S = &quot;abcde&quot; $P = &quot;a*e&quot;
    Output: 1
</code></pre><p><strong>Example 2:</strong></p>
<pre><code>    Input: $S = &quot;abcde&quot; $P = &quot;a*d&quot;
    Output: 0
</code></pre><p><strong>Example 3:</strong></p>
<pre><code>    Input: $S = &quot;abcde&quot; $P = &quot;?b*d&quot;
    Output: 0
</code></pre><p><strong>Example 4:</strong></p>
<pre><code>    Input: $S = &quot;abcde&quot; $P = &quot;a*c?e&quot;
    Output: 1
</code></pre><h2 id="about-the-solutions">about the solutions</h2>
<p>There were 25 working submissions for the first task this past week.</p>
<p>The almost unanimous decision in solving this task was to use the regular expression engine to do the final validation. This in turn required converting the toy wildcard patterns into proper Perl. This conversion was itself almost always done using regular expressions, although there were a few outliers. Ok one. One outlier. Variation did arise  from differing interpretations of the wildcards, which we&rsquo;ll address.</p>
<p>Kudos also to Gustavo and Chorba for bucking the trend and going their own way, building us proper parsers from scratch to do the validating. It&rsquo;s really not as complex as you might think and we have two examples to examine.</p>
<h2 id="a-note-on-the-wildcards">a note on the WILDCARDS</h2>
<p>The two pattern wildcards in our toy language were delivered with two directives:</p>
<ol>
<li>? - Match any single character.</li>
<li>* - Match any sequence of characters.</li>
</ol>
<p>Although the patterns <em>resemble</em> shell wildcards it&rsquo;s not stated anywhere that the <em>are</em> this thing. As such there was a range of interpretation as to what, exactly, they meant. I&rsquo;m sure every person looking at this now has an &ldquo;obvious&rdquo; understanding of the intent, but as anyone who has followed these pages should know by now, nothing is obvious. If there is any room at all for ambiguity the road less taken will be found and followed by <em>someone</em>.</p>
<p>There were some comments on the subject, mostly along the lines of noticing the differences between the wildcard <em>characters</em> given and their more familiar regular expression <em>quantifiers</em>. Only a couple mentioned any ambiguity in the interpretation, and then only to declare their decision on the matter.</p>
<p>What on Earth, you may ask, am I talking about? Well the larger variation came from the interpretation of the <code>*</code> wildcard.</p>
<p>As I said earlier, the wildcards given resemble shell metacharacters, but are not stated to be this, and instead are only given simple definitions. So myself, given the choice between suggestion and facts, took the definitions to heart, which led me in turn to consider the phrase &ldquo;any sequence of characters&rdquo;. Now a sequence is a list of things, and a sequence of <em>no</em> things isn&rsquo;t a sequence at all, as there&rsquo;s nothing to list.  This led me to conclude that an asterisk was &ldquo;a sequence of length one or more items, constructed from any characters&rdquo;.</p>
<p>I was not alone in this interpretation but had precious little company either, put solidly in the minority. As a shell metacharacter, <code>*</code> means zero or more of anything and that was the overwhelmingly popular choice we see here today. Going the other way, there were even a few who chose to define <code>?</code> as zero or one character as well, which to me sort of matches the <code>*</code> interpretation, although this diverges from the shell standards again.</p>
<p>None of these variations were a deal-breaker. I do find it interesting that something seemingly so clear can wind up with so much variation, though, and further that popular opinion was definitely against me on this one. That said I do maintain that I have a strong argument, and I&rsquo;m also glad to have at least a little company with me, here on the outside looking in.</p>
<h2 id="building-an-expression-from-a-pattern">building an EXPRESSION from a PATTERN</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/alexander-pankoff/perl/ch-1.pl"><strong>Alexander Pankoff</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/arne-sommer/perl/ch-1.pl"><strong>Arne Sommer</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/athanasius/perl/ch-1.pl"><strong>Athanasius</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/cheok-yin-fung/perl/ch-1.pl"><strong>Cheok-Yin Fung</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/colin-crain/perl/ch-1.pl"><strong>Colin Crain</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/cristian-heredia/perl/ch-1.pl"><strong>Cristina Heredia</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/dave-jacoby/perl/ch-1.pl"><strong>Dave Jacoby</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/duncan-c-white/perl/ch-1.pl"><strong>Duncan C. White</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/e-choroba/perl/ch-1.pl"><strong>E. Choroba</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/polettix/perl/ch-1.pl"><strong>Flavio Poletti</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/jaldhar-h-vyas/perl/ch-1.pl"><strong>Jaldhar H. Vyas</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/james-smith/perl/ch-1.pl"><strong>James Smith</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/jo-37/perl/ch-1.pl"><strong>Jorg Sommrey</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/laurent-rosenfeld/perl/ch-1.pl"><strong>Laurent Rosenfeld</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/lubos-kolouch/perl/ch-1.pl"><strong>Lubos Kolouch</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/perlboy1967/perl/ch-1.pl"><strong>Niels van Dijke</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/nunovieira220/perl/ch-1.pl"><strong>Nuno Vieira</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/paulo-custodio/perl/ch-1.pl"><strong>Paulo Custodio</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/pete-houston/perl/ch-1.pl"><strong>Pete Houston</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/roger-bell-west/perl/ch-1.pl"><strong>Roger Bell_West</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/sgreen/perl/ch-1.pl"><strong>Simon Green</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/stuart-little/perl/ch-1.pl"><strong>Stuart Little</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/wlmb/perl/ch-1.pl"><strong>W. Luis Mochan</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/wanderdoc/perl/ch-1.pl"><strong>Wanderdoc</strong></a></p>
<p>As I said, this was the overwhelming choice. Most involved fairly simple substitutions, but some people did pursue and find more complex, rigorous transformations.</p>
<h3 id="a-simple-plan">a SIMPLE PLAN</h3>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/arne-sommer/perl/ch-1.pl"><strong>Arne Sommer</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/athanasius/perl/ch-1.pl"><strong>Athanasius</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/cheok-yin-fung/perl/ch-1.pl"><strong>Cheok-Yin Fung</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/colin-crain/perl/ch-1.pl"><strong>Colin Crain</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/cristian-heredia/perl/ch-1.pl"><strong>Cristina Heredia</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/dave-jacoby/perl/ch-1.pl"><strong>Dave Jacoby</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/duncan-c-white/perl/ch-1.pl"><strong>Duncan C. White</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/jaldhar-h-vyas/perl/ch-1.pl"><strong>Jaldhar H. Vyas</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/james-smith/perl/ch-1.pl"><strong>James Smith</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/laurent-rosenfeld/perl/ch-1.pl"><strong>Laurent Rosenfeld</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/lubos-kolouch/perl/ch-1.pl"><strong>Lubos Kolouch</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/perlboy1967/perl/ch-1.pl"><strong>Niels van Dijke</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/nunovieira220/perl/ch-1.pl"><strong>Nuno Vieira</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/roger-bell-west/perl/ch-1.pl"><strong>Roger Bell_West</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/stuart-little/perl/ch-1.pl"><strong>Stuart Little</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/wanderdoc/perl/ch-1.pl"><strong>Wanderdoc</strong></a></p>
<p>At it&rsquo;s heart this is a simple conversion from the given patterns to well-constructed expressions. Two things need to be done: we need to convert the wildcard characters into corresponding character-class/quantifier combinations, and we need to anchor the resultant expression to both ends of our target string. After this is done the new expression gets inserted into an <code>m//</code> operation and we see what happens.</p>
<p>The solutions had quite a bit of self-similarity. Let&rsquo;s visit a few to get an overview of the field.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/colin-crain/perl/ch-1.pl"><strong>My Own Solution</strong></a></p>
<p>I&rsquo;ll demonstrate the plain-vanilla version using my own submission. It&rsquo;s nothing fancy, and the steps are clearly laid out. We convert a <code>?</code> into a single <code>.</code>, and a <code>*</code> into a <code>.+</code> class and grouping (as discused above). After that we insert the expression between anchors and return the result.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">use</span> feature <span style="color:#e6db74">qw(say signatures)</span>;
    <span style="color:#66d9ef">no</span> warnings <span style="color:#e6db74">&#39;experimental::signatures&#39;</span>;

    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">validate</span> ($str, $exp) {
        $exp <span style="color:#f92672">=~</span> <span style="color:#e6db74">s/\?/./g</span>;
        $exp <span style="color:#f92672">=~</span> <span style="color:#e6db74">s/\*/.+/g</span>;

        <span style="color:#66d9ef">return</span> $str <span style="color:#f92672">=~</span> <span style="color:#e6db74">m/^$exp$/</span> ?  <span style="color:#ae81ff">1</span>
                                 :  <span style="color:#ae81ff">0</span>;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/duncan-c-white/perl/ch-1.pl"><strong>Duncan C. White</strong></a></p>
<p>Here&rsquo;s another version of the conversion from Duncan. He takes the &ldquo;dot star&rdquo; approach to the wildcard, and affixes his anchors before returning the complete result to be matched.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">pat2regex</span>
    {
        <span style="color:#66d9ef">my</span>( $p ) <span style="color:#f92672">=</span> @_;
        <span style="color:#66d9ef">my</span> $inner <span style="color:#f92672">=</span> $p;
        $inner <span style="color:#f92672">=~</span> <span style="color:#e6db74">s/\*/.*/g</span>;    <span style="color:#75715e"># * -&gt; .*</span>
        $inner <span style="color:#f92672">=~</span> <span style="color:#e6db74">s/\?/./g</span>;        <span style="color:#75715e"># ? -&gt; .</span>
        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#39;^&#39;</span><span style="color:#f92672">.</span>$inner<span style="color:#f92672">.</span><span style="color:#e6db74">&#39;$&#39;</span>;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/lubos-kolouch/perl/ch-1.pl"><strong>Lubos Kolouch</strong></a></p>
<p>Lubos, coming from the direction of Test Driven Development, arranges things a little differently, but the same actions get accomplished in the end.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    is(pattern_match({<span style="color:#e6db74">&#39;s&#39;</span> <span style="color:#f92672">=&gt;</span> <span style="color:#e6db74">&#39;abcde&#39;</span>, <span style="color:#e6db74">&#39;p&#39;</span> <span style="color:#f92672">=&gt;</span> <span style="color:#e6db74">&#39;a*e&#39;</span>}), <span style="color:#ae81ff">1</span>);

    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">pattern_match</span> {
        <span style="color:#66d9ef">my</span> $what <span style="color:#f92672">=</span> shift;

        <span style="color:#75715e"># convert the pattern to regex</span>
        $what<span style="color:#f92672">-&gt;</span>{p} <span style="color:#f92672">=~</span> <span style="color:#e6db74">s/\?/./g</span>;
        $what<span style="color:#f92672">-&gt;</span>{p} <span style="color:#f92672">=~</span> <span style="color:#e6db74">s/\*/.*/g</span>;
        $what<span style="color:#f92672">-&gt;</span>{p} <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;^&#39;</span><span style="color:#f92672">.</span>$what<span style="color:#f92672">-&gt;</span>{p}<span style="color:#f92672">.</span><span style="color:#e6db74">&#39;$&#39;</span>;

        <span style="color:#66d9ef">my</span> $match <span style="color:#f92672">=</span> $what<span style="color:#f92672">-&gt;</span>{s} <span style="color:#f92672">=~</span><span style="color:#e6db74"> /$what-&gt;{p}/</span>;
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">unless</span> $match;
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/perlboy1967/perl/ch-1.pl"><strong>Niels van Dijke</strong></a></p>
<p>Niels makes the uncommon choice to allow the <code>?</code> to mean zero or one characters. This is neither here nor there, but as a side effect of this decision it allows him to make his conversion in a very compact manner, with a single substitution.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    $RE <span style="color:#f92672">=~</span> s<span style="color:#75715e">#([\*\?])#.$1#g;</span>
</code></pre></div><p>Knowing how it feels to be in the minority, here&rsquo;s another version by</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/nunovieira220/perl/ch-1.pl"><strong>Nuno Vieira</strong></a></p>
<p>Nuno has come to the same conclusion over <code>?</code>, and consequently was able to construct a very similar expression.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    $P <span style="color:#f92672">=~</span> <span style="color:#e6db74">s/(\?|\*)/\.$1/g</span>;
</code></pre></div><p>It&rsquo;s nice to have company.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/dave-jacoby/perl/ch-1.pl"><strong>Dave Jacoby</strong></a></p>
<p>In a related vein, here&rsquo;s Dave&rsquo;s version, of the &ldquo;dot plus&rdquo; variety. See? There are <em>several</em> of us!</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">pattern_match</span> ( $S, $P ) {
        <span style="color:#66d9ef">my</span> $pattern <span style="color:#f92672">=</span> $P;

        $pattern <span style="color:#f92672">=~</span> <span style="color:#e6db74">s/\*/.+/g</span>;
        $pattern <span style="color:#f92672">=~</span> <span style="color:#e6db74">s/\?/./g</span>;
        $pattern <span style="color:#f92672">=</span> <span style="color:#e6db74">qq{^$pattern\$}</span>;
        <span style="color:#66d9ef">return</span> $S <span style="color:#f92672">=~</span><span style="color:#e6db74"> /$pattern/mix</span> ? <span style="color:#ae81ff">1</span> : <span style="color:#ae81ff">0</span>;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/cristian-heredia/perl/ch-1.pl"><strong>Cristina Heredia</strong></a></p>
<p>Christina takes a very different approach to converting her wildcards into an expression. She first splits the pattern into an array of characters, then iterates through them one by one. If a wildcard is found, the value is replaced by the translation.</p>
<p>This is a good illustration of one quality of the <code>for</code> loop that, if casually disregarded, can produce strange behavior and bugs for the unwary. That is, when a <code>for</code> loop temporarily assigns its values, whether to the topic as seen here or any other variable, what it&rsquo;s doing is not copying the value but rather creating an <em>alias</em> to the original item in the array. Which is to say, if you alter the assigned variable, that change will be reflected in the original array because they are in fact the same thing. Here Christina assigns to <code>$_</code>, and when she&rsquo;s done the <code>@pattern</code> array retain the changes. All she need do is re-join the original array and send it to the next step.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">replaceCharacter</span> {
        <span style="color:#66d9ef">foreach</span> ( @pattern ) {
            <span style="color:#66d9ef">if</span> ($_ <span style="color:#f92672">eq</span> <span style="color:#e6db74">&#39;?&#39;</span>) {
                $_ <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;.&#39;</span>;
            }
            <span style="color:#66d9ef">elsif</span> ($_ <span style="color:#f92672">eq</span> <span style="color:#e6db74">&#39;*&#39;</span>) {
                $_ <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;.+&#39;</span>;
            }
        }
        <span style="color:#66d9ef">my</span> $redex <span style="color:#f92672">=</span> join <span style="color:#e6db74">&#39;&#39;</span>, @pattern;
        printResult($redex);
    }

    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">printResult</span>{
        <span style="color:#66d9ef">my</span> $redex <span style="color:#f92672">=</span> shift;
        <span style="color:#66d9ef">if</span> ($S <span style="color:#f92672">=~</span><span style="color:#e6db74"> /^$redex$/</span>){
            <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;1\n&#34;</span>;
        }
        <span style="color:#66d9ef">else</span> {
            <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;0\n&#34;</span>;
        }
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/james-smith/perl/ch-1.pl"><strong>James Smith</strong></a></p>
<p>As he explains, affixing the <code>/r</code> modifier to a substitution returns the completed, substituted string. James, being clever again, has chained several of these substitutions to first convert the <code>*</code> wildcards, then the <code>?</code>s, then concatenate the results between the anchors. The anchors he&rsquo;s chosen, <code>\A</code> and <code>\Z</code>, match at the end of the <em>string</em>, versus the end of the <em>line</em> as with <code>^</code> and <code>$</code>. The actions of these pairs only diverges with strings that actually contain a newline, so that&rsquo;s unlikely to make a difference here. But it is good to remember this distinction exists, should this version ever need to come into play. They&rsquo;re a lifesaver when you need them.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">file_name_match</span> {
      <span style="color:#75715e">##    {use r modifier to return string with replacements in}</span>
      <span style="color:#66d9ef">my</span> $re <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;\A&#39;</span><span style="color:#f92672">.</span>($_[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=~</span> <span style="color:#e6db74">s{[*]}{.*}g</span>r <span style="color:#f92672">=~</span> <span style="color:#e6db74">s{[?]}{.}g</span>r)<span style="color:#f92672">.</span><span style="color:#e6db74">&#39;\Z&#39;</span>;
      <span style="color:#66d9ef">return</span> $_[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=~</span> <span style="color:#e6db74">m{$re}</span> ? <span style="color:#ae81ff">1</span> : <span style="color:#ae81ff">0</span>;
    }
</code></pre></div><h3 id="more-complex-considerations">more COMPLEX considerations</h3>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/alexander-pankoff/perl/ch-1.pl"><strong>Alexander Pankoff</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/e-choroba/perl/ch-1.pl"><strong>E. Choroba</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/polettix/perl/ch-1.pl"><strong>Flavio Poletti</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/jo-37/perl/ch-1.pl"><strong>Jorg Sommrey</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/paulo-custodio/perl/ch-1.pl"><strong>Paulo Custodio</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/pete-houston/perl/ch-1.pl"><strong>Pete Houston</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/sgreen/perl/ch-1.pl"><strong>Simon Green</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/wlmb/perl/ch-1.pl"><strong>W. Luis Mochan</strong></a></p>
<p>Any constraints on the input strings are left undefined, so we really have no idea which characters they may contain beyond our wildcards. Thus, should we indiscriminately plop our translated expressions into the regex engine we may wind up in trouble. To remedy this some members took the aditional step of escaping various other, difficult characters.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/sgreen/perl/ch-1.pl"><strong>Simon Green</strong></a></p>
<p>Simon builds a custom character class of various brackets, braces and characters with special meaning to the regular expression parser.</p>
<p>Once that is done things proceed in the usual manner.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#75715e"># Escape regexp meta characters, except ? and *</span>
    $pattern <span style="color:#f92672">=~</span> <span style="color:#e6db74">s/([\{\}\[\]\(\)\^\$\.\|\+\\])/\\$1/g</span>;

    <span style="color:#75715e"># Replace ? and *</span>
    $pattern <span style="color:#f92672">=~</span> <span style="color:#e6db74">s/\?/./g</span>;
    $pattern <span style="color:#f92672">=~</span> <span style="color:#e6db74">s/\*/.+/g</span>;

    <span style="color:#75715e"># Ensure entire match</span>
    $pattern <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;^$pattern\$&#34;</span>;

    say $string <span style="color:#f92672">=~</span> $pattern ? <span style="color:#ae81ff">1</span> : <span style="color:#ae81ff">0</span>;
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/paulo-custodio/perl/ch-1.pl"><strong>Paulo Custodio</strong></a></p>
<p>Paulo takes it a little further, escaping every non-word character.</p>
<p>One thing to notice here is that using the <code>for</code> loop on a scalar, far from being pointless, is not duplicating but rather aliasing the actual variable <code>$rx</code> to the default topic <code>$_</code>. In effect this performs the multiple substitutions on that value directly without needing to copy it. This is very clean and in my eyes a very cool trick, a less uncertain version of the <a href="https://perldoc.perl.org/perlsyn#Switch-Statements">&ldquo;highly experimental&rdquo;</a> <code>given</code> statement. I&rsquo;ll have to remember use this more often.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span> $rx <span style="color:#f92672">=</span> $P;
    <span style="color:#66d9ef">for</span> ($rx) {
        <span style="color:#e6db74">s/(\W)/\\$1/g</span>;      <span style="color:#75715e"># escape all non-word chars</span>
        <span style="color:#e6db74">s/\\\*/.*/g</span>;        <span style="color:#75715e"># replace * (now \*) by .*</span>
        <span style="color:#e6db74">s/\\\?/./g</span>;         <span style="color:#75715e"># replace ? (now \?) by .</span>
    }

    say $S <span style="color:#f92672">=~</span><span style="color:#e6db74"> /^$rx$/</span> ? <span style="color:#ae81ff">1</span> : <span style="color:#ae81ff">0</span>;
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/e-choroba/perl/ch-1.pl"><strong>E. Choroba</strong></a></p>
<p>But wait, while we&rsquo;re quoting all of the non-word characters, isn&rsquo;t there a function for that? Why yes, yes there is, and anyone processing user input in a regular expression should be familiar with it. This function, <code>quotemeta</code>, will escape, as expected, all non-word characters in a given string. Sounds perfect.</p>
<p>Which is it, but notice that used this way it will indiscriminately escape our wildcards as well, replacing them with <code>\*</code> and <code>\?</code>, respectively. In order to refer to these constructs literally, we need to escape the backslashes and the original character, resulting in the rather monstrous <code>\\\*</code> and <code>\\\*</code> in our substitutions. Such is life, it can&rsquo;t be helped.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">pattern_match</span> {
        <span style="color:#66d9ef">my</span> ($string, $pattern) <span style="color:#f92672">=</span> @_;
        $pattern <span style="color:#f92672">=</span> quotemeta $pattern;
        <span style="color:#e6db74">s/\\\?/./g</span>, <span style="color:#e6db74">s/\\\*/.*/g</span> <span style="color:#66d9ef">for</span> $pattern;
        <span style="color:#66d9ef">return</span> $string <span style="color:#f92672">=~</span><span style="color:#e6db74"> /^$pattern$/</span> ? <span style="color:#ae81ff">1</span> : <span style="color:#ae81ff">0</span>
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/polettix/perl/ch-1.pl"><strong>Flavio Poletti</strong></a></p>
<p>Flavio gives us quite an unusual way of going about the translation using <code>map</code>. The target pattern is split, translated and then reassembled, not unlike Christina&rsquo;s solution above. Notice the cascading ternary operators culminating in a <code>quotemeta</code>, avoiding some backslashing.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">pattern_match</span> ($S, $T) {
       $T <span style="color:#f92672">=</span> join <span style="color:#e6db74">&#39;&#39;</span>,
          map { $_ <span style="color:#f92672">eq</span> <span style="color:#e6db74">&#39;*&#39;</span> ? <span style="color:#e6db74">&#39;.*&#39;</span> : $_ <span style="color:#f92672">eq</span> <span style="color:#e6db74">&#39;?&#39;</span> ? <span style="color:#e6db74">&#39;.&#39;</span> : quotemeta($_) }
          split <span style="color:#e6db74">m{([*?])}mxs</span>, $T;
       <span style="color:#66d9ef">return</span> $S <span style="color:#f92672">=~</span> <span style="color:#e6db74">m{\A$T\z}mxs</span> ? <span style="color:#ae81ff">1</span> : <span style="color:#ae81ff">0</span>;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/wlmb/perl/ch-1.pl"><strong>W. Luis Mochan</strong></a></p>
<p>If we stop to consider backslashes in our pattern, all this quoting and escaping can get quite ungainly. For example have a look at Luis&rsquo; solution. As more and more cases are allowed for, we end up looking like&hellip; amber waves of grain? Picket fences? ASCII art? You get the idea.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span> ($S, $P0)<span style="color:#f92672">=</span>@ARGV;
    <span style="color:#66d9ef">my</span> $P<span style="color:#f92672">=</span>quotemeta $P0;        <span style="color:#75715e"># quote anything suspicious</span>
    $P<span style="color:#f92672">=~</span><span style="color:#e6db74">s/^\\\*/.*/</span>;            <span style="color:#75715e"># Replace originally unquoted asterisks</span>
    $P<span style="color:#f92672">=~</span><span style="color:#e6db74">s/([^\\])\\\*/$1.*/g</span>;
    $P<span style="color:#f92672">=~</span><span style="color:#e6db74">s/\\\\\*/\*/g</span>;          <span style="color:#75715e"># Replace originally quoted asterisks</span>
    $P<span style="color:#f92672">=~</span><span style="color:#e6db74">s/^\\\?/./</span>;             <span style="color:#75715e"># Replace originally unquoted question marks</span>
    $P<span style="color:#f92672">=~</span><span style="color:#e6db74">s/([^\\])\\\?/$1./g</span>;
    $P<span style="color:#f92672">=~</span><span style="color:#e6db74">s/\\\\\?/\?/g</span>;          <span style="color:#75715e"># Replace originally quoted question marks</span>
    say <span style="color:#e6db74">&#34;Input: \$S=\&#34;$S\&#34; \$P=\&#34;$P0\&#34;\nOutput: &#34;</span>, $S<span style="color:#f92672">=~</span><span style="color:#e6db74">/^$P$/</span>?<span style="color:#ae81ff">1</span>:<span style="color:#ae81ff">0</span>;
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/jo-37/perl/ch-1.pl"><strong>Jorg Sommrey</strong></a></p>
<p>Culminating the series, Jorg lays out his reasoning with extensive comments on his actions. He extends the original spec, explicitly allowing a backslash to escape the following character to produce a literal. Instead of basic substitution, a rather complex upgrade match is performed and the captures fed to a function to be converted. By performing string interpolation with the <code>qr//</code> quotes, the array is joined using the <code>$OUTPUT_LIST_SEPARATOR</code>, requiring an <code>/x</code> switch to ignore whitespace. In the end a complied regular expression is returned and assigned to the <code>$re</code> variable, and it is run against the input string.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#75715e"># Convert pattern part to regex:</span>
    <span style="color:#75715e"># *  -&gt; .*</span>
    <span style="color:#75715e"># ?  -&gt; .</span>
    <span style="color:#75715e"># \x -&gt; x</span>
    <span style="color:#75715e"># other: quote if necessary</span>
    <span style="color:#75715e">#</span>
    <span style="color:#75715e"># Processes $_.</span>
    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">convmeta</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#39;.*?&#39;</span> <span style="color:#66d9ef">if</span> <span style="color:#e6db74">/^\*$/</span>;
        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#39;.&#39;</span> <span style="color:#66d9ef">if</span> <span style="color:#e6db74">/^\?$/</span>;
        <span style="color:#66d9ef">return</span> quotemeta $1 <span style="color:#66d9ef">if</span> <span style="color:#e6db74">/^\\(.)$/</span>;
        <span style="color:#75715e"># else:</span>
        quotemeta;
    }

    <span style="color:#75715e"># Match string against pattern.  Pattern meta characters are:</span>
    <span style="color:#75715e"># ? : match one character</span>
    <span style="color:#75715e"># * : match any number of characters</span>
    <span style="color:#75715e"># \ : use next character literally</span>
    <span style="color:#75715e"># The special treatment of quoted characters is beyond the specification</span>
    <span style="color:#75715e"># of this task but it seems to be useful and needful.</span>
    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">patmatch</span> ($str, $pat) {

        <span style="color:#75715e"># Convert pattern to regex.</span>
        <span style="color:#66d9ef">my</span> $re <span style="color:#f92672">=</span>  <span style="color:#66d9ef">sub</span> {<span style="color:#e6db74">qr/^ @_ $/</span>x}<span style="color:#f92672">-&gt;</span>(
            map convmeta,
            $pat <span style="color:#f92672">=~</span> <span style="color:#e6db74">m{
</span><span style="color:#e6db74">                \G              # start at previous end-of-match position and
</span><span style="color:#e6db74">                (               # capture
</span><span style="color:#e6db74">                    [^*?\\]+    # a group of non-meta chars
</span><span style="color:#e6db74">                  |             # or
</span><span style="color:#e6db74">                    [*?]        # a meta-char
</span><span style="color:#e6db74">                  |             # or
</span><span style="color:#e6db74">                    \\.         # a quoted char
</span><span style="color:#e6db74">                )
</span><span style="color:#e6db74">            }gx</span>);
        <span style="color:#75715e"># Reject incomplete patterns.</span>
        die <span style="color:#e6db74">&#34;invalid pattern: &#39;$&#39;&#39; in &#39;$pat&#39;&#34;</span> <span style="color:#66d9ef">if</span> $&#39;;

        say <span style="color:#e6db74">&#34;pattern: &#39;$pat&#39;\nregex:   $re&#34;</span> <span style="color:#66d9ef">if</span> $verbose;

        $str <span style="color:#f92672">=~</span> $re;
    }
</code></pre></div><h2 id="building-a-parser-from-scratch">building a PARSER from SCRATCH</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/gustavo-chaves/perl/ch-1.pl"><strong>Gustavo Chaves</strong></a> and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/e-choroba/perl/ch-1a.pl"><strong>E. Choroba</strong></a></p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/gustavo-chaves/perl/ch-1.pl"><strong>Gustavo Chaves</strong></a></p>
<p>Gustavo breaks from the pack and does something completely different: he builds a little match-engine parser to walk the string and the pattern using a pair of position locators.</p>
<p>As each position is compared, obviously any character is expected to match itself in both strings, and we will need special cases to deal with the two wildcard operators. Because the <code>?</code> wildcard always matches anything, it can be scooted across without comparison — leaving the only complexity to the variable-length wildcard matches with <code>*</code>. This is dealt with by recursively calling the validator on the remaining tails of the string and pattern. It&rsquo;s a neat little method and works well.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">match</span> {
        <span style="color:#66d9ef">my</span> ($pattern, $string) <span style="color:#f92672">=</span> @_;

        <span style="color:#66d9ef">my</span> ($s, $p) <span style="color:#f92672">=</span> (<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>);

      CHAR:
        <span style="color:#66d9ef">while</span> ($p <span style="color:#f92672">&lt;</span> length($pattern) <span style="color:#f92672">&amp;&amp;</span> $s <span style="color:#f92672">&lt;</span> length($string)) {
            <span style="color:#66d9ef">my</span> $c <span style="color:#f92672">=</span> substr($pattern, $p, <span style="color:#ae81ff">1</span>);

            <span style="color:#66d9ef">if</span> ($c <span style="color:#f92672">eq</span> <span style="color:#e6db74">&#39;?&#39;</span>) {
                <span style="color:#f92672">++</span>$s;
                <span style="color:#f92672">++</span>$p;
            } <span style="color:#66d9ef">elsif</span> ($c <span style="color:#f92672">eq</span> <span style="color:#e6db74">&#39;*&#39;</span>) {
                <span style="color:#66d9ef">my</span> $patterntail <span style="color:#f92672">=</span> substr($pattern, $p<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
                <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">my</span> $i<span style="color:#f92672">=</span>$s; $i <span style="color:#f92672">&lt;</span> length($string); <span style="color:#f92672">++</span>$i) {
                    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">if</span> match($patterntail, substr($string, $i));
                }
                <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
            } <span style="color:#66d9ef">elsif</span> ($c <span style="color:#f92672">eq</span> substr($string, $s, <span style="color:#ae81ff">1</span>)) {
                <span style="color:#f92672">++</span>$s;
                <span style="color:#f92672">++</span>$p;
            } <span style="color:#66d9ef">else</span> {
                <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
            }
        }

        <span style="color:#66d9ef">return</span> $p <span style="color:#f92672">==</span> length($pattern) <span style="color:#f92672">&amp;&amp;</span> $s <span style="color:#f92672">==</span> length($string);
    }
</code></pre></div><h3 id="bonus">BONUS!</h3>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/e-choroba/perl/ch-1a.pl"><strong>E. Choroba</strong></a></p>
<p>It seems that lost among the GitHub repositories Choroba submitted a <em>second</em> solution, enacting a pattern parser over the subject string in a manner quite analogous to Gustavo&rsquo;s effort. So we have <em>two</em> parsers to examine, which I, frankly, find exciting.</p>
<p>Here Choroba builds a dispatch table to handle his individual wildcard actions, those actions themselves defined in anonymous subroutines returning success or failure. I like this layout. Enjoy!</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">pattern_match</span> {
        <span style="color:#66d9ef">my</span> ($string, $pattern) <span style="color:#f92672">=</span> @_;
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">if</span> <span style="color:#e6db74">&#34;&#34;</span> <span style="color:#f92672">eq</span> $string <span style="color:#f92672">.</span> $pattern;

        <span style="color:#66d9ef">my</span> ($string_first,  $string_rest)  <span style="color:#f92672">=</span> $string  <span style="color:#f92672">=~</span><span style="color:#e6db74"> /(.)(.*)/</span>;
        <span style="color:#66d9ef">my</span> ($pattern_first, $pattern_rest) <span style="color:#f92672">=</span> $pattern <span style="color:#f92672">=~</span><span style="color:#e6db74"> /(.)(.*)/</span>;

        <span style="color:#66d9ef">my</span> $action <span style="color:#f92672">=</span> {
            <span style="color:#e6db74">&#39;?&#39;</span> <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">sub</span> {
                <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">unless</span> length $pattern;
                <span style="color:#66d9ef">return</span> pattern_match($string_rest, $pattern_rest)
            },
            <span style="color:#e6db74">&#39;*&#39;</span> <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">sub</span> {
                <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $pos (<span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> length $string) {
                    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>
                        <span style="color:#66d9ef">if</span> pattern_match(substr($string, $pos), $pattern_rest);
                }
                <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
            },
        }<span style="color:#f92672">-&gt;</span>{ $pattern_first <span style="color:#e6db74">//</span> <span style="color:#e6db74">&#34;&#34;</span> } <span style="color:#f92672">||</span> <span style="color:#66d9ef">sub</span> {
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">if</span> ($pattern_first <span style="color:#e6db74">//</span> <span style="color:#e6db74">&#34;&#34;</span>) <span style="color:#f92672">ne</span> ($string_first <span style="color:#e6db74">//</span> <span style="color:#e6db74">&#34;&#34;</span>);

            <span style="color:#66d9ef">return</span> pattern_match($string_rest, $pattern_rest)
        };
        <span style="color:#66d9ef">return</span> $action<span style="color:#f92672">-&gt;</span>()
    }
</code></pre></div><hr>
<hr>
<h1 id="PWC099TASK2">TASK 2</h1>
<h1 id="unique-subsequence">Unique Subsequence</h1>
<p><em>Submitted by: Mohammad S Anwar</em>
You are given two strings $S and $T.</p>
<p>Write a script to find out count of different unique subsequences matching $T without changing the position of characters.</p>
<p><strong>UPDATE:</strong> 2021-02-08 09:00AM (UK TIME) suggested by Jonas Berlin,
missing entry [5].</p>
<p><strong>Example 1:</strong></p>
<pre><code>    Input: $S = &quot;littleit', $T = 'lit'
    Output: 5

        1: [lit] tleit
        2: [li] t [t] leit
        3: [li] ttlei [t]
        4: litt [l] e [it]
        5: [l] ittle [it]
</code></pre><p><strong>Example 2:</strong></p>
<pre><code>    Input: $S = &quot;london', $T = 'lon'
    Output: 3

        1: [lon] don
        2: [lo] ndo [n]
        3: [l] ond [on]
</code></pre><h2 id="about-the-solutions-1">about the solutions</h2>
<p>There were 23 working submissions for the second task this past week. The most common approach was to build a recursive routine to traverse the subject string looking for sequential characters in the target. Nextmost we had those who grappled with the ideas surrounding matching out sequences with a regular expression, and then the hard part, figuring out how to count them. Finally, we had a few completely different approaches: applying brute force; assembling valid positional combinations from subgroups; and applying dynamic programmning analysis to the decision making process as the two strings are compared.</p>
<h2 id="the-recursive-solution">the RECURSIVE solution</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/alexander-pankoff/perl/ch-2.pl"><strong>Alexander Pankoff</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/athanasius/perl/ch-2.pl"><strong>Athanasius</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/cheok-yin-fung/perl/ch-2.pl"><strong>Cheok-Yin Fung</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/colin-crain/perl/ch-2.pl"><strong>Colin Crain</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/dave-jacoby/perl/ch-2.pl"><strong>Dave Jacoby</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/duncan-c-white/perl/ch-2.pl"><strong>Duncan C. White</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/e-choroba/perl/ch-2.pl"><strong>E. Choroba</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/polettix/perl/ch-2.pl"><strong>Flavio Poletti</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/james-smith/perl/ch-2.pl"><strong>James Smith</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/laurent-rosenfeld/perl/ch-2.pl"><strong>Laurent Rosenfeld</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/nunovieira220/perl/ch-2.pl"><strong>Nuno Vieira</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/paulo-custodio/perl/ch-2.pl"><strong>Paulo Custodio</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/pete-houston/perl/ch-2.pl"><strong>Pete Houston</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/sgreen/perl/ch-2.pl"><strong>Simon Green</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/stuart-little/perl/ch-2.pl"><strong>Stuart Little</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/wlmb/perl/ch-2.pl"><strong>W. Luis Mochan</strong></a></p>
<p>In the recursive solution, we start at the beginning of both strings. We take the first character from the target substring and start scanning left to right across the other, examining each character in turn for a match. The <code>index</code> function came in handy here, but there were other ways to do it. If the character is found, two things happen: the routine recurses, with the remaining rightward portions of both strings, and the original search continues down the line for another occurence of the first character. The original search could  either  be placed in a loop that continues, or descend in another recursion, with the remaining string and the  substring passed through unchanged.</p>
<p>The routine when called in recursion then scoops off the first character of the remaining substring, being the second character this time, which it then attempts to find. The edge case is when an incidence of the last character of the substring is found, causing another complete set of ordered characters to be chalked up.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/dave-jacoby/perl/ch-2.pl"><strong>Dave Jacoby</strong></a></p>
<p>Dave demonstrates the steps. Here he uses two recursion paths based on whether the initial characters of the two strings match or do not match. If the do not, we continue looking for the same initial character. If they do, then we begin looking for the next character.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">unique_sub</span> ( $S, $T, $p = 0, $q = 0, $done = undef ) {
        <span style="color:#66d9ef">if</span> ( $p <span style="color:#f92672">&gt;</span> length $S ) { <span style="color:#66d9ef">return</span> }
        $done <span style="color:#e6db74">//</span><span style="color:#f92672">=</span> <span style="color:#f92672">[]</span>;
        <span style="color:#66d9ef">my</span> @output;
        <span style="color:#66d9ef">my</span> $l   <span style="color:#f92672">=</span> length $T;
        <span style="color:#66d9ef">my</span> $l1  <span style="color:#f92672">=</span> substr $S, $p, <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">my</span> $l2  <span style="color:#f92672">=</span> substr $T, $q, <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">my</span> $key <span style="color:#f92672">=</span> join <span style="color:#e6db74">&#39;.&#39;</span>, $done<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>

        <span style="color:#960050;background-color:#1e0010">#</span> THE CASE OF NO MATCH
        <span style="color:#66d9ef">my</span> $copy<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span> <span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#960050;background-color:#1e0010">$</span>done<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>
        push @output, unique_sub( $S, $T, $p <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, $q, $copy );

        <span style="color:#75715e"># THE CASE OF MATCH</span>
        <span style="color:#66d9ef">if</span> ( $l1 <span style="color:#f92672">eq</span> $l2 ) {    <span style="color:#75715e"># is a match</span>
            <span style="color:#66d9ef">if</span> ( $q <span style="color:#f92672">&lt;</span> $l ) {    <span style="color:#75715e"># is not a complete match</span>
                push $copy<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span>, $p;
                push @output, unique_sub( $S, $T, $p <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, $q <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, $copy );
            }
            <span style="color:#66d9ef">elsif</span> ( $l <span style="color:#f92672">==</span> $q ) {    <span style="color:#75715e"># is a complete match</span>
                push @output, $key;
            }
        }
        <span style="color:#66d9ef">return</span> sort @output;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/colin-crain/perl/ch-2.pl"><strong>My Own Solution</strong></a></p>
<p>My own <code>descend</code> routine uses <code>index</code> to rapidly move forward to the next position of the  character in question. A counter is incremented if the last character is found, and these increments are gathered and returned to produce the final tally.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">descend</span> ($str, $target) {
            <span style="color:#66d9ef">my</span> $count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">unless</span> length $str <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> length $target <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>;

            <span style="color:#66d9ef">my</span> $t   <span style="color:#f92672">=</span> substr( $target, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span> );
            <span style="color:#66d9ef">my</span> $idx <span style="color:#f92672">=</span> index $str, $t;

            <span style="color:#66d9ef">if</span> ($idx <span style="color:#f92672">&gt;</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
                $count<span style="color:#f92672">++</span> <span style="color:#66d9ef">if</span> length $target <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>;
                $count <span style="color:#f92672">+=</span> descend( substr($str, $idx<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>), $target);
                $count <span style="color:#f92672">+=</span> descend( substr($str, $idx<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>), substr( $target, <span style="color:#ae81ff">1</span> ));
            }

            <span style="color:#66d9ef">return</span> $count;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/nunovieira220/perl/ch-2.pl"><strong>Nuno Vieira</strong></a></p>
<p>Nuno also descends on both options after finding a letter match, calling <code>counter</code> with first the target string unchanged, then with the first letter removed, to begin searching for the following letter. When constructed this way the routing can be very compact.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">counter</span> {
      <span style="color:#66d9ef">my</span> ($S, $T) <span style="color:#f92672">=</span> @_;

      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>length($T) <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>length($S));

      <span style="color:#66d9ef">my</span> $index <span style="color:#f92672">=</span> index($S, substr($T, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>));
      <span style="color:#66d9ef">my</span> $last <span style="color:#f92672">=</span> length($T) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> ? <span style="color:#ae81ff">1</span> : <span style="color:#ae81ff">0</span>;

      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">if</span>($index <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
      <span style="color:#66d9ef">return</span> $last <span style="color:#f92672">+</span> counter(substr($S, $index <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>), $T) <span style="color:#f92672">+</span> counter(substr($S, $index <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>), substr($T, <span style="color:#ae81ff">1</span>));
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/pete-houston/perl/ch-2.pl"><strong>Pete Houston</strong></a></p>
<p>Pete introduces the idea of putting the search for the initial character in a loop, so recursion only starts when a match is found, descending and searching for the following letter. After the recursion is spawned, the loop continues across the string, looking for the next incidence of the initial letter.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">count_seqs</span> {
        <span style="color:#66d9ef">my</span> ($str, $sub) <span style="color:#f92672">=</span> @_;
        say  <span style="color:#e6db74">&#34;str $str   sub $sub&#34;</span>;

        <span style="color:#66d9ef">my</span> $tot <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">my</span> $pos <span style="color:#f92672">=</span> index ($str, substr ($sub, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>));
        <span style="color:#66d9ef">my</span> $len <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">==</span> length $sub;

        <span style="color:#66d9ef">while</span> ($pos <span style="color:#f92672">&gt;</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
            $tot <span style="color:#f92672">+=</span> $len ?
                <span style="color:#ae81ff">1</span> :
                count_seqs (substr ($str, $pos <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>), substr ($sub, <span style="color:#ae81ff">1</span>));
            $pos <span style="color:#f92672">=</span> index ($str, substr ($sub, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>), $pos <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
        }
        <span style="color:#66d9ef">return</span> $tot;
    }

</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/laurent-rosenfeld/perl/ch-2.pl"><strong>Laurent Rosenfeld</strong></a></p>
<p>Laurent gives us another version of using a loop to continue searching for a letter across the given string:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">search_substr</span> {
        <span style="color:#66d9ef">my</span> ($in, $searched) <span style="color:#f92672">=</span> @_;
        <span style="color:#66d9ef">my</span> $start <span style="color:#f92672">=</span> substr $searched, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">my</span> $index <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>) {
            $index <span style="color:#f92672">=</span> index $in, $start, $index;
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">if</span> $index <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>;
            $index<span style="color:#f92672">++</span>;
            <span style="color:#f92672">++</span>$count <span style="color:#f92672">and</span> <span style="color:#66d9ef">next</span>  <span style="color:#66d9ef">if</span> length $searched <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>;
            search_substr (substr($in, $index), substr($searched, <span style="color:#ae81ff">1</span>));
        }
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/cheok-yin-fung/perl/ch-2.pl"><strong>Cheok-Yin Fung</strong></a></p>
<p>Cy&rsquo;s recursive <code>check</code> routine returns stringified lists of offsets, with one offset for each of the characters in the target string, one list per working solution. She can then decode these into the bracketed output strings displayed in the example:</p>
<p>The internal strings look like this:</p>
<pre><code>    0,0,0
    0,0,1
    0,0,5
    0,5,0
    4,1,0
</code></pre><p>This translates to the positional offsets for the characters &ldquo;l&rdquo;, &ldquo;i&rdquo; and &ldquo;t&rdquo;. The strings are decoded and reused to create this lovely output:</p>
<pre><code>    1: [lit]tleit
    2: [li]t[t]leit
    3: [li]ttlei[t]
    4: [l]ittle[it]
    5: litt[l]e[it]
</code></pre><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">for</span> $i (@ices) {
        <span style="color:#66d9ef">my</span> @poss <span style="color:#f92672">=</span> @{check( substr($s_rightsub, $i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
                     , substr($t_pattern,<span style="color:#ae81ff">1</span>) , [<span style="color:#e6db74">&#34;&#34;</span>] )};
        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $s (@app) {
            <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $t (@poss) {
                <span style="color:#66d9ef">if</span> (substr($t, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>) <span style="color:#f92672">ne</span> <span style="color:#e6db74">&#34;#&#34;</span>) {
                    push @new_app, $s<span style="color:#f92672">.</span>$i<span style="color:#f92672">.</span><span style="color:#e6db74">&#34;,&#34;</span><span style="color:#f92672">.</span>$t;
                }
            }
        }
    }

</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/alexander-pankoff/perl/ch-2.pl"><strong>Alexander Pankoff</strong></a></p>
<p>Pankoff states that he started with Dave Jacoby&rsquo;s recursive solution, and extends it with a  custom <code>StringIterator</code> class that knows how to, well, iterate across strings of course. Now the ideas of a string and removing and holding up the first character of that string have been encapsulated into a single object. The recursive routine itself is also broken off into an anonymous subroutine, so that after dissection and compartmentalization the actual running of the program is initiated by one line: calling <code>$go</code> (a coderef to our anonymous routine) with the two strings as <code>StringIterator</code> objects.</p>
<p>The indirect action can be confusing at first but the functional programming paradigm of breaking procedures down into discreet, self-contained parts is a very powerful technique with large and complex structures. By isolating the actions and removing interwoven side-effects each step can be refined and examined without requiring adjustment to the whole unit.</p>
<p>He has clearly documented his steps. Notice how if you disregard the comment text how small the control flow really is.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">count_subsequences</span> ( $string, $target ) {

        <span style="color:#75715e"># create a recurisve helper routine that works on StringIterator objects</span>
        <span style="color:#66d9ef">my</span> $go;
        $go <span style="color:#f92672">=</span> <span style="color:#66d9ef">sub</span> ( $string_iterator, $target_iterator ) {
            <span style="color:#66d9ef">my</span> $current <span style="color:#f92672">=</span> $string_iterator<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">next</span>;

            <span style="color:#75715e"># we&#39;re at the end of the string</span>
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>defined $current;

            <span style="color:#75715e"># recurse into the non matching case. here we have to clone our</span>
            <span style="color:#75715e"># iterators to prevent modifications inside of the nested calls from</span>
            <span style="color:#75715e"># affecting us here</span>
            <span style="color:#75715e"># the $string_iterator has already been advanced by our call to next</span>
            <span style="color:#75715e"># whereas the target_iterator is still in its original state</span>
            <span style="color:#66d9ef">my</span> $count <span style="color:#f92672">=</span> $go<span style="color:#f92672">-&gt;</span>( $string_iterator<span style="color:#f92672">-&gt;</span>clone, $target_iterator<span style="color:#f92672">-&gt;</span>clone );

            <span style="color:#75715e"># advance the target_iterator and get the current target char</span>
            <span style="color:#66d9ef">my</span> $target_char <span style="color:#f92672">=</span> $target_iterator<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">next</span>;
            <span style="color:#66d9ef">if</span> ( $current <span style="color:#f92672">eq</span> $target_char ) {

                <span style="color:#75715e"># we have a full match if the target_iterator is exhausted. We can</span>
                <span style="color:#75715e"># increment the count and stop here.</span>
                <span style="color:#66d9ef">if</span> ( $target_iterator<span style="color:#f92672">-&gt;</span>is_at_end ) {
                    $count <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
                }

                <span style="color:#75715e"># if we don&#39;t have a full match we have to recurse. both iterators</span>
                <span style="color:#75715e"># have been advanced by now and won&#39;t be used anymore. we can pass</span>
                <span style="color:#75715e"># them as is.</span>
                <span style="color:#66d9ef">else</span> {
                    $count <span style="color:#f92672">+=</span> $go<span style="color:#f92672">-&gt;</span>( $string_iterator, $target_iterator, );
                }
            }

            <span style="color:#66d9ef">return</span> $count;
        };

        <span style="color:#75715e"># create the Iterator objects and go!</span>
        $go<span style="color:#f92672">-&gt;</span>( StringIterator<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">new</span>($string), StringIterator<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">new</span>($target) );
    }

    <span style="color:#66d9ef">package</span> StringIterator {

        <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">new</span> ( $class, $string ) {
            <span style="color:#66d9ef">my</span> $self <span style="color:#f92672">=</span> {
                string   <span style="color:#f92672">=&gt;</span> $string,
                position <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">0</span>,
                size     <span style="color:#f92672">=&gt;</span> length($string),
            };

            <span style="color:#66d9ef">return</span> bless $self, $class;
        }

        <span style="color:#75715e"># returns the current char and advances the iterator</span>
        <span style="color:#75715e"># returns `undef` if the iterator is exhausted</span>
        <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">next</span>($self) {
            <span style="color:#66d9ef">return</span> undef <span style="color:#66d9ef">if</span> $self<span style="color:#f92672">-&gt;</span>is_at_end();
            <span style="color:#66d9ef">my</span> $char <span style="color:#f92672">=</span> substr( $self<span style="color:#f92672">-&gt;</span>{string}, $self<span style="color:#f92672">-&gt;</span>{position}, <span style="color:#ae81ff">1</span> );
            $self<span style="color:#f92672">-&gt;</span>{position}<span style="color:#f92672">++</span>;
            <span style="color:#66d9ef">return</span> $char;
        }

        <span style="color:#75715e"># returns 1 if the iterator is at the end</span>
        <span style="color:#75715e">#         0 otherwise</span>
        <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">is_at_end</span>($self) {
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">if</span> $self<span style="color:#f92672">-&gt;</span>{position} <span style="color:#f92672">&gt;=</span> $self<span style="color:#f92672">-&gt;</span>{size};
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
        }

        <span style="color:#75715e"># returns a clone of the iterator object</span>
        <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">clone</span>($self) {
            <span style="color:#66d9ef">return</span> bless {%$self}, ref $self;
        }
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/james-smith/perl/ch-2.pl"><strong>James Smith</strong></a></p>
<p>Finally, James uses a regular expression to scan across his string looking for the target character. There&rsquo;s quite a bit of extra code added to produce his fancy bracketed output as per the challenge example. He provides several versions of his method, with and without the verbose output, and also adding a cache to the recursive routine which speed things up by several orders of magnitude. Stripped of the extended functionality the routine is reduced to only three lines.</p>
<p>Here is the fancy display version, with his very helpful commentary preserved intact:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">display_uniq_subseq</span> {
      <span style="color:#66d9ef">my</span>( $haystack, $prev, $regexp, $needle, @result ) <span style="color:#f92672">=</span> (
        $_[<span style="color:#ae81ff">0</span>],          <span style="color:#75715e">## haystack (first string)</span>
        @_<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">2</span>?$_[<span style="color:#ae81ff">2</span>]:<span style="color:#e6db74">q()</span>, <span style="color:#75715e">## previous string (3rd parameter if it exists)</span>
        $_[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=~</span> <span style="color:#e6db74">m{(.)(.*)}</span> ? (<span style="color:#e6db74">&#39;\A(.*?)(&#39;</span><span style="color:#f92672">.</span>$1<span style="color:#f92672">.</span><span style="color:#e6db74">&#39;)&#39;</span>,$2) : (<span style="color:#e6db74">q()</span>,<span style="color:#e6db74">q()</span>),
        <span style="color:#75715e">## The regex for finding matches + the remainder of needle</span>
        <span style="color:#75715e">## Slightly more complex than the previous version as we</span>
        <span style="color:#75715e">## remove the &#34;optimization&#34; step in the other two functions</span>
      );

      <span style="color:#75715e">## If we have exhausted the substring we return the previous part</span>
      <span style="color:#75715e">## along with what is left of the haystack.</span>
      <span style="color:#75715e">## Note individual mapped letters are surrounded by individual</span>
      <span style="color:#75715e">## brackets - to collapse these down to clusters of matched</span>
      <span style="color:#75715e">## characters - We collapse adjacent []s by stripping &#34;][&#34;.</span>
      <span style="color:#75715e">## We again use the &#34;r&#34; modifier to just return the result</span>
      <span style="color:#75715e">## of the replacement.</span>
      <span style="color:#66d9ef">return</span> ($prev <span style="color:#f92672">=~</span><span style="color:#e6db74">s{\]\[}{}g</span>r)<span style="color:#f92672">.</span>$haystack <span style="color:#66d9ef">if</span> $regexp <span style="color:#f92672">eq</span> <span style="color:#e6db74">q()</span>;

      <span style="color:#75715e">## regex collects anything before the matched letter &amp;</span>
      <span style="color:#75715e">## the matched letter</span>
      <span style="color:#66d9ef">while</span>( $haystack <span style="color:#f92672">=~</span> <span style="color:#e6db74">s{$regexp}{}</span> ) {
        <span style="color:#66d9ef">my</span>( $pre_match, $match ) <span style="color:#f92672">=</span> ($1,$2);
        push @result, display_uniq_subseq(
          $haystack, $needle, $prev<span style="color:#f92672">.</span>$pre_match<span style="color:#f92672">.</span><span style="color:#e6db74">&#39;[&#39;</span><span style="color:#f92672">.</span>$match<span style="color:#f92672">.</span><span style="color:#e6db74">&#39;]&#39;</span>,
        );
        <span style="color:#75715e">## add the match onto the previous string, and</span>
        <span style="color:#75715e">## continue to the next match</span>
        $prev <span style="color:#f92672">.=</span> $pre_match<span style="color:#f92672">.</span>$match;
      }
      <span style="color:#66d9ef">return</span> @result;
    }
</code></pre></div><h2 id="match-with-a-regex">match with a REGEX</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/polettix/perl/ch-2.pl"><strong>Flavio Poletti</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/jaldhar-h-vyas/perl/ch-2.pl"><strong>Jaldhar H. Vyas</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/jo-37/perl/ch-2.pl"><strong>Jorg Sommrey</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/perlboy1967/perl/ch-2.pl"><strong>Niels van Dijke</strong></a></p>
<p>Several people tried solving the problem with a regex, with varying results. This is certainly a non-trivial task, and I applaud anyone for the effort. Sometimes a match was used in a recursive solution, to scan across the string. But in others the regular expression is the star of the show, doing all the work.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/jaldhar-h-vyas/perl/ch-2.pl"><strong>Jaldhar H. Vyas</strong></a></p>
<p>Jaldar  takes a novel approach where he applies conbinatorics to a model regular expression to match the target substring. By creating a set of patterns that match all combinations of spacings within the larger string he can try them all and find those that match. Each match represents one unique solution.</p>
<p>Internally, for the example &ldquo;littleit&rdquo; and &ldquo;lit&rdquo;, the patterns look like this:</p>
<pre><code>    lit
    l.{1}it
    l.{2}it
    l.{3}it
    l.{4}it
    l.{5}it
    li.{1}t
    li.{2}t
    li.{3}t
    li.{4}t
    li.{5}t

</code></pre><p>Here is the code to do the matches:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span> @patterns <span style="color:#f92672">=</span> ( $T );
    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i (<span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> (length $T) <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>) {
        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $j (<span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> (length $S) <span style="color:#f92672">-</span> (length $T)) {
            <span style="color:#66d9ef">my</span> @t <span style="color:#f92672">=</span> split <span style="color:#e6db74">//</span>, $T;
            $t[$i] <span style="color:#f92672">.=</span> <span style="color:#e6db74">&#34;.{$j}&#34;</span>;
            <span style="color:#66d9ef">my</span> $pattern <span style="color:#f92672">=</span> join <span style="color:#e6db74">q{}</span>, @t;
            push @patterns, $pattern;
        }
    }

    <span style="color:#66d9ef">my</span> $count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $pattern (@patterns) {
        <span style="color:#66d9ef">if</span> ($S <span style="color:#f92672">=~</span><span style="color:#e6db74"> /($pattern)/</span>) {
            $count<span style="color:#f92672">++</span>;
        }
    }

</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/perlboy1967/perl/ch-2.pl"><strong>Niels van Dijke</strong></a></p>
<p>Niels takes a quite different route to get where he&rsquo;s going. He first uses <code>Algorithm::Combinatorics::variations_with_repetition</code> to, in circuitous fashion, determine all the various ways to partition the target sequence into different groupings: &ldquo;lit&rdquo;; &ldquo;l&rdquo; and &ldquo;it&rdquo;; &ldquo;li&rdquo; and &ldquo;t&rdquo;; or &ldquo;l&rdquo;, &ldquo;i&rdquo; and &ldquo;t&rdquo;. He then passes these lists to a second routine which shifts off the first term in the first list and searches for it in a regular expression. On finding a match he recursively starts searching for the next term in the list. Sound familiar? Is a recursive solution or a regular expression? Who knows? These categories of mine always seem to break down eventually.</p>
<p>As Niels is really getting dirty down in the guts of the RE engine I&rsquo;d say it belongs over on this side with us weirdos and masochists who enjoy this sort of thing. Remember: with great power comes great responsibility. And madness, and megalomania, and possibly the urge to take over the world. We&rsquo;ll have to watch for that.</p>
<p>Anyway, let&rsquo;s do some internal snooping on the regexes and subsequent groupings formed:</p>
<pre><code>    ^(.{3})$
    lit
    ^(.{1})(.{2})$
    l it
    ^(.{2})(.{1})$
    li t
    ^(.{1})(.{1})(.{1})$
    l i t

</code></pre><p>This method, however, will still find adjacent target subsequences, equivalent to larger groupings, so a little clever filtering removes all the duplicate sequences before producing a nice verbose output.</p>
<pre><code>[
    [0] &quot;[l]ittle[it]&quot;,
    [1] &quot;[li]t[t]leit&quot;,
    [2] &quot;[li]ttlei[t]&quot;,
    [3] &quot;[lit]tleit&quot;,
    [4] &quot;litt[l]e[it]&quot;
]

</code></pre><p>Here&rsquo;s the initial substring component:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">getSubstrings</span>($) {
     <span style="color:#66d9ef">my</span> ($t) <span style="color:#f92672">=</span> @_;

      <span style="color:#66d9ef">my</span> @r;

      <span style="color:#66d9ef">my</span> $l <span style="color:#f92672">=</span> length($t);
      <span style="color:#66d9ef">my</span> @L <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> $l);

      <span style="color:#75715e"># I admit... difficult way to find substrings of &#39;$t&#39;</span>
      <span style="color:#75715e"># but its cool, so why not?</span>
      <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $cCount (<span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> $l) {
        <span style="color:#66d9ef">my</span> $v <span style="color:#f92672">=</span> variations_with_repetition(<span style="color:#f92672">\</span>@L,$cCount);

        <span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">my</span> $a <span style="color:#f92672">=</span> $v<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">next</span>) {
          <span style="color:#66d9ef">next</span> <span style="color:#66d9ef">unless</span> sum(@$a) <span style="color:#f92672">==</span> $l;

          <span style="color:#66d9ef">my</span> $re1 <span style="color:#f92672">=</span> sprintf(<span style="color:#e6db74">&#39;^(%s)$&#39;</span>, join(<span style="color:#e6db74">&#39;)(&#39;</span>, map { <span style="color:#e6db74">&#34;.{$_}&#34;</span> } @$a));
          $T <span style="color:#f92672">=~</span> m<span style="color:#75715e">#$re1#;</span>

          push(@r, [map {substr($T, $-[$_], $+[$_]<span style="color:#f92672">-</span>$-[$_]) } (<span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> scalar(@<span style="color:#960050;background-color:#1e0010">+</span>) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)]);
        }
      }

      <span style="color:#66d9ef">return</span> @r;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/polettix/perl/ch-2.pl"><strong>Flavio Poletti</strong></a></p>
<p>The real challenge to constructing a regular expression to solve the task is not so much to simply match the letters within the string, but to determine <em>how many ways</em> the letters can be matched within the string.</p>
<p>Flavio provides us with solutions done two ways. First he gives us a lovely recursive solution to give us the subsequence count that closely follows many of the solutions we have seen today. On the other hand, he also gives us a marvelous little regular expression that not only finds every match, but <em>counts the matches as it makes them</em>. I had forgotten this trick and am pleasantly reminded.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">unique_subsequence_rx</span> ($S, $T) {
       $T <span style="color:#f92672">=</span> join <span style="color:#e6db74">&#39;.*&#39;</span>, split <span style="color:#e6db74">m{}mxs</span>, $T;
       <span style="color:#66d9ef">my</span> $count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
       <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">while</span> $S <span style="color:#f92672">=~</span> <span style="color:#e6db74">m{$T(?{++$count}</span>)(?<span style="color:#f92672">!</span>)};
       <span style="color:#66d9ef">return</span> $count;
    }
</code></pre></div><p>How does it work? The target string is broken apart into letters, which are joined together again with <code>.*</code>, for any number of interstitial characters, including none. The RE engine is set to matching. When this, the first part of the match, is found, the engine then attempts to continue matching the rest of the expression. That is comprised first of the zero-width code block <code>(?{++$count})</code> which is evaluated, ratcheting the counter, and as a code block always evaluates to true. The next part, a zero-width negative lookahead with no content, will always match the nothingness preceding whatever follows, and hence always fails. Remember it succeeds when it does <em>not</em> match whatever follows. The engine, unhappy, returns back to the beginning to try another version. As the last part of the expression will always fail, the engine will continue to examine every  combination, looking for a positive outcome, before giving up after exhausting the possibilities. However, along the way the counter will be incremented after every successful match of the subsequence portion of the expression.</p>
<p>As we will see next, the <code>(?!)</code> construct can also be written <code>(*FAIL)</code>, which might be a bit clearer as to what&rsquo;s happening.</p>
<p>And that, my friends, might be the shortest, easiest way to get this job done.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/jo-37/perl/ch-2.pl"><strong>Jorg Sommrey</strong></a></p>
<p>Jorg&rsquo;s submission is quite a bit longer, but only because he has opted to recreate the extended explanation of the output from the challenge example. His generated form of an expression for the pair &ldquo;littleit&rdquo; and &ldquo;lit&rdquo; is</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    (?<span style="color:#f92672">^</span>u:(l)<span style="color:#f92672">.*</span>?(i)<span style="color:#f92672">.*</span>?(t))
</code></pre></div><p>Here the three letters are placed into capture groups, with a standard set of flags applied at the beginning: i, m, s, and x. Then using a counting construction similar to what we just saw, the Perl special variable <code>@-</code>, <code>@LAST_MATCH_START</code> is pushed on to the <code>@match</code> array at every completed match. This array holds the start position of the last completed match, followed by the positions of the capture groups, <code>$1</code>, <code>$2</code>, etc. Notice here that rather than taking a direct reference to the variable, a new anonymous array is created from the contents. Taking a reference just doesn&rsquo;t work, for a variety of reasons. He can then use these position lists to construct a display of the individual sequence matched within the string. As mentioned earlier, the <code>(*FAIL)</code> construct always fails.</p>
<p>The number of matches is the element count for the <code>@match</code> array.</p>
<pre><code>    sequence: 'lit'
    matcher:  (?^u:(l).*?(i).*?(t))
    littleit
    lit•••••
    li•t••••
    li•••••t
    l•••••it
    ••••l•it

</code></pre><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#75715e"># Count occurences of a character sequence within a string.</span>
    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">matchseq</span> ($str, $seq) {

        <span style="color:#75715e"># Create a regex that matches the character sequence and captures</span>
        <span style="color:#75715e"># all of its characters individually.</span>
        <span style="color:#75715e"># Example transformation chain:</span>
        <span style="color:#75715e"># &#39;x*&#39; -&gt; (&#39;x&#39;, &#39;*&#39;) -&gt; (&#39;x&#39;, &#39;\\*&#39;) -&gt; (?:(x).*?(\*))</span>
        <span style="color:#66d9ef">my</span> $seqmatch <span style="color:#f92672">=</span> <span style="color:#66d9ef">sub</span> {
            local $&#34; <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;).*?(&#39;</span>;
            <span style="color:#e6db74">qr{(@_)}</span>;
        }<span style="color:#f92672">-&gt;</span>(map quotemeta, split <span style="color:#e6db74">//</span>, $seq);

        <span style="color:#75715e"># Find all sequence matches and collect the character match offsets.</span>
        <span style="color:#66d9ef">my</span> @match;
        $str <span style="color:#f92672">=~</span> <span style="color:#e6db74">m{ $seqmatch (?{push @match, [@-]}</span>) (<span style="color:#f92672">*</span>FAIL) }x;

        explainseq($str, $seq, $seqmatch, <span style="color:#f92672">\</span>@match) <span style="color:#66d9ef">if</span> $verbose;

        <span style="color:#75715e"># Return the number of matches.</span>
        scalar @match;
    }

    <span style="color:#75715e"># Show the locations of the character sequence within the string.</span>
    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">explainseq</span> ($str, $seq, $re, $matches) {

        say <span style="color:#e6db74">&#34;sequence: &#39;$seq&#39;&#34;</span>;
        say <span style="color:#e6db74">&#34;matcher:  $re&#34;</span>;
        say $str;

        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $match (@$matches) {

            <span style="color:#75715e"># Discard match offset, keeping submatches only. (See @-)</span>
            shift @$match;

            <span style="color:#75715e"># Prepare a string having the same length as $str.</span>
            <span style="color:#66d9ef">my</span> $seqloc <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;\N{MIDDLE DOT}&#34;</span> x length $str;

            <span style="color:#75715e"># Overwrite the string at match offsets with chars from the</span>
            <span style="color:#75715e"># sequence.</span>
            <span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">my</span> ($idx, $offs) <span style="color:#f92672">=</span> each @$match) {
                substr($seqloc, $offs, <span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span> substr($seq, $idx, <span style="color:#ae81ff">1</span>);
            }
            say $seqloc;
        }
    }
</code></pre></div><h2 id="unique-approaches-and-grandiose-schemes">UNIQUE approaches and GRANDIOSE SCHEMES</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/arne-sommer/perl/ch-2.pl"><strong>Arne Sommer</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/roger-bell-west/perl/ch-2.pl"><strong>Roger Bell_West</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/wanderdoc/perl/ch-2.pl"><strong>Wanderdoc</strong></a></p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/arne-sommer/perl/ch-2.pl"><strong>Arne Sommer</strong></a></p>
<p>Arne brute forces the solution by looking at all binary numbers counting up to <code>0b111...</code>, with the number of 1s being the length of the searched string. Allowing only those whose count of 1s is equal to the target string the every possible combination of letters from the string can be evaluated, choosing the letter signified by a 1 in the binary mask.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span> $binary   <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;1&#39;</span> x $S_length;
    <span style="color:#66d9ef">my</span> $max      <span style="color:#f92672">=</span> oct(<span style="color:#e6db74">&#39;0b&#39;</span> <span style="color:#f92672">.</span> $binary);

    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $current (<span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> $max)
    {
      <span style="color:#66d9ef">my</span> $mask <span style="color:#f92672">=</span> sprintf(<span style="color:#e6db74">&#34;%0&#34;</span> <span style="color:#f92672">.</span> $S_length <span style="color:#f92672">.</span><span style="color:#e6db74">&#34;b&#34;</span>, $current);

      <span style="color:#66d9ef">if</span> (sum(split(<span style="color:#e6db74">//</span>, $mask)) <span style="color:#f92672">!=</span> $T_length)
      {
        say <span style="color:#e6db74">&#34;:   Skipped binary mask &#39;{ $mask }&#39; - wrong number of 1s&#34;</span> <span style="color:#66d9ef">if</span> $verbose;
        <span style="color:#66d9ef">next</span>;
      }

      <span style="color:#66d9ef">my</span> $candidate <span style="color:#f92672">=</span> join(<span style="color:#e6db74">&#34;&#34;</span>, map { substr($mask, $_, <span style="color:#ae81ff">1</span>) <span style="color:#f92672">eq</span> <span style="color:#e6db74">&#39;1&#39;</span> ? substr($S, $_,<span style="color:#ae81ff">1</span>) : <span style="color:#e6db74">&#39;&#39;</span> } (<span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $S_length <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>));

      <span style="color:#66d9ef">if</span> ($candidate <span style="color:#f92672">eq</span> $T)
      {
        $matches<span style="color:#f92672">++</span>;
        say <span style="color:#e6db74">&#34;: + Match found with binary mask &#39;$mask&#39;.&#34;</span> <span style="color:#66d9ef">if</span> $verbose;
      }
      <span style="color:#66d9ef">else</span>
      {
        say <span style="color:#e6db74">&#34;:   Considering binary mask &#39; $mask&#39; - no match&#34;</span> <span style="color:#66d9ef">if</span> $verbose;
      }
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/roger-bell-west/perl/ch-2.pl"><strong>Roger Bell_West</strong></a></p>
<p>Roger starts his solution by creating a hash of letters in the searched string, pointing to lists of their location positions. Armed with this, he then proceeds to convert the target string into a sequence of arrays of the various positions the individual characters are found at in the searched. Once this is done he need only to create a nest of iterations to find all increasing sequences that can be generated.</p>
<p>The three steps:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    {
        <span style="color:#66d9ef">my</span> $i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;                                      <span style="color:#75715e">## [1]</span>
        <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $c ( split <span style="color:#e6db74">&#39;&#39;</span>, $text ) {
            push @{ $s{ $c } }, $i;
            $i<span style="color:#f92672">++</span>;
        }
    }
    <span style="color:#66d9ef">my</span> @j;
    <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $c ( split <span style="color:#e6db74">&#39;&#39;</span>, $match ) {                <span style="color:#75715e">## [2]</span>
        <span style="color:#66d9ef">if</span> ( exists $s{ $c } ) {
            push @j, $s{ $c };
        } <span style="color:#66d9ef">else</span> {
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
        }
    }
    <span style="color:#66d9ef">my</span> @o <span style="color:#f92672">=</span> ( <span style="color:#ae81ff">1</span> ) x scalar @{ $j[<span style="color:#ae81ff">0</span>] };                  <span style="color:#75715e">## [3]</span>
    <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $m ( <span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$#j ) {
        <span style="color:#66d9ef">my</span> @n;
        <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $bi ( <span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$#{ $j[$m] } ) {
            <span style="color:#66d9ef">my</span> $t <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
            <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $ai ( <span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$#{ $j[$m <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] } ) {
                <span style="color:#66d9ef">if</span> ( $j[$m <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][$ai] <span style="color:#f92672">&lt;</span> $j[$m][$bi] ) {
                    $t <span style="color:#f92672">+=</span> $o[$ai];
                }
            }
            push @n, $t;
        }
        @o <span style="color:#f92672">=</span> @n;
    }
    <span style="color:#66d9ef">return</span> sum( @o );
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/wanderdoc/perl/ch-2.pl"><strong>Wanderdoc</strong></a></p>
<p>The doctor gives us a dynamic programming solution, essentially tracking the alignments between the characters in the subject and the target as we work across the letters. LIke we saw in the recursive solutions, either a pair can correspond or not. The sum of the various valid pathways is counted up as a matrix of partial solutions is built up, and the ultimate tally is found in the lower right-hand cell.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">find_subsequence</span>
    {
         <span style="color:#66d9ef">my</span> ($str_1, $str_2) <span style="color:#f92672">=</span> @_;
         <span style="color:#66d9ef">my</span> $mtr;

         <span style="color:#66d9ef">my</span> @first  <span style="color:#f92672">=</span> split(<span style="color:#e6db74">//</span>,$str_1);
         <span style="color:#66d9ef">my</span> @second <span style="color:#f92672">=</span> split(<span style="color:#e6db74">//</span>,$str_2);

         <span style="color:#66d9ef">do</span> { <span style="color:#66d9ef">my</span> $ch1 <span style="color:#f92672">=</span> $_;
              <span style="color:#66d9ef">do</span> { $mtr<span style="color:#f92672">-&gt;</span>[$ch1][$_] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> } <span style="color:#66d9ef">for</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> scalar @second }
              <span style="color:#66d9ef">for</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> scalar @first;
         $mtr<span style="color:#f92672">-&gt;</span>[$_][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">for</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> scalar @first;

         <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i ( <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> scalar @first )
         {
              <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $j ( <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> scalar @second )
              {
                   <span style="color:#66d9ef">if</span>($first[$i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">eq</span> $second[$j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])
                   {
                        $mtr<span style="color:#f92672">-&gt;</span>[$i][$j] <span style="color:#f92672">+=</span> $mtr<span style="color:#f92672">-&gt;</span>[$i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][$j] <span style="color:#f92672">+</span> $mtr<span style="color:#f92672">-&gt;</span>[$i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][$j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
                   }
                   <span style="color:#66d9ef">else</span>
                   {
                        $mtr<span style="color:#f92672">-&gt;</span>[$i][$j] <span style="color:#f92672">+=</span> $mtr<span style="color:#f92672">-&gt;</span>[$i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][$j];
                   }
              }
         }

         <span style="color:#66d9ef">return</span> $mtr<span style="color:#f92672">-&gt;</span>[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
    }

</code></pre></div><hr>
<h1 id="PWC099BLOGS">BLOGS</h1>
<hr>
<p><strong>That’s it for me this week, people! Warped by the rain, driven by the snow, resolute and unbroken by the torrential influx, I somehow continue to maintain my bearings. Looking forward to next wave, the perfect wave, I am: <em>your humble servant</em>.</strong></p>
<h1 id="PWC093BLOGS">But if Your <em>THIRST</em> for <em>KNOWLEDGE</em> is not <em>SLAKED</em>,</h1>
<h1 id="then-run-dont-walk-to-the-watering-hole">then <em>RUN</em> <em>(dont walk!)</em> to the <em>WATERING HOLE</em></h1>
<h1 id="and-read-these-blog-links">and <em>READ</em> these <em>BLOG</em> <em>LINKS</em>:</h1>
<p><strong>( <em>don&rsquo;t think, trust your training, you&rsquo;re in the zone, just do it &hellip;</em> )</strong></p>
<p><strong>Aaron Smith</strong></p>
<ul>
<li><a href="https://aaronreidsmith.github.io/blog/perl-weekly-challenge-099/">Perl Weekly Challenge 99 - Aaron Smith</a> ( <em>Raku</em> )</li>
</ul>
<p><strong>Arne Sommer</strong></p>
<ul>
<li><a href="https://raku-musings.com/subsequently-matched.html">Subsequently Matched with Raku and Perl</a> ( <em>Perl &amp; Raku</em> )</li>
</ul>
<p><strong>Colin Crain</strong></p>
<ul>
<li><a href="https://colincrain.com/2021/02/13/diffraction-gratings-producing-a-wildcard-wonderland/">Diffraction Gratings Producing a Wildcard Wonderland — Programming Excursions in Perl and Raku</a> ( <em>Perl &amp; Raku</em> )</li>
</ul>
<p><strong>Dave Jacoby</strong></p>
<ul>
<li><a href="https://jacoby.github.io/2021/02/11/london-patterns-perl-weekly-challenge-99.html">London Patterns: Perl Weekly Challenge #99 | Committed to Memory</a> ( <em>Perl</em> )</li>
</ul>
<p><strong>Flavio Poletti</strong></p>
<ul>
<li><a href="https://github.polettix.it/ETOOBUSY/2021/02/10/pwc099-pattern-match/">PWC099 - Pattern Matching - ETOOBUSY</a> ( <em>Perl</em> )</li>
<li><a href="https://github.polettix.it/ETOOBUSY/2021/02/11/pwc099-unique-subsequence/">PWC099 - Unique Subsequence - ETOOBUSY</a> ( <em>Perl</em> )</li>
</ul>
<p><strong>Jaldhar H. Vyas</strong></p>
<ul>
<li><a href="https://www.braincells.com/perl/2021/02/perl_weekly_challenge_week_99.html">Perl Weekly Challenge: Week 99</a> ( <em>Perl &amp; Raku</em> )</li>
</ul>
<p><strong>James Smith</strong></p>
<ul>
<li><a href="http://blogs.perl.org/users/james_curtis-smith/2021/02/perl-weekly-challenge-99.html">Perl weekly challenge 99 | James Curtis-Smith</a> ( <em>Perl</em> )</li>
</ul>
<p><strong>Laurent Rosenfeld</strong></p>
<ul>
<li><a href="http://blogs.perl.org/users/laurent_r/2021/02/perl-weekly-challenge-99-pattern-match-and-unique-subsequence.html">Perl Weekly Challenge 99: Pattern Match and Unique Subsequence</a> ( <em>Perl &amp; Raku</em> )</li>
</ul>
<p><strong>Luca Ferrari</strong></p>
<ul>
<li><a href="https://fluca1978.github.io/2021/02/08/PerlWeeklyChallenge99.html#task1">Perl Weekly Challenge 99: overlapping searches - Task 1 – Luca Ferrari</a> ( <em>Raku</em> )</li>
<li><a href="https://fluca1978.github.io/2021/02/08/PerlWeeklyChallenge99.html#task2">Perl Weekly Challenge 99: overlapping searches – Task 2 - Luca Ferrari</a> ( <em>Raku</em> )</li>
</ul>
<p><strong>Roger Bell_West</strong></p>
<ul>
<li><a href="https://blog.firedrake.org/archive/2021/02/Perl_Weekly_Challenge_99__Unique_Match.html">RogerBW's Blog: Perl Weekly Challenge 99: Unique Match</a> ( <em>Perl &amp; Raku</em> )</li>
</ul>
<p><strong>Simon Green</strong></p>
<ul>
<li><a href="https://dev.to/simongreennet/weekly-challenge-099-ncp">Weekly Challenge 099</a> ( <em>Perl</em> )</li>
</ul>
<p><strong>W. Luis Mochan</strong></p>
<ul>
<li><a href="https://wlmb.github.io/2021/02/08/PWC099/">Perl Weekly Challenge 99 – W. Luis Mochán</a> ( <em>Perl</em> )</li>
</ul>

                </div>
            </div>
        </div>
    </div>
</section>


<!-- Call To Action Section Start -->
<section id="call-to-action">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2 class="title wow fadeInDown" data-wow-delay=".3s" data-wow-duration="500ms">SO WHAT DO YOU THINK ?</h2>
                    <p class="wow fadeInDown" data-wow-delay=".5s" data-wow-duration="500ms">If you have any suggestions or ideas then please do share with us.</p>
                    <a href="/contact" class="btn btn-default btn-contact wow fadeInDown" data-wow-delay=".7s" data-wow-duration="500ms">Contact with me</a>
                </div>
            </div>

        </div>
    </div>
</section>
<!-- Call To Action Section End -->



<!-- Footer Section Start -->
<footer id="footer">
    <div class="container">
        <div class="row content-justify-between">
            <div class="col-md-8 col-12 text-center text-lg-left text-md-left">
                <p class="copyright">Copyright:
                    <span>
                        2019 - 2024
                    </span> The Weekly Challenge. Theme Design and Developed by
                    <a href="http://www.Themefisher.com" rel="noreferrer" rel="noreferrer" target="_blank">Themefisher</a>.
                </p>
            </div>
            <div class="col-md-4 col-12">
                <!-- Social Media -->
                <ul class="social text-center text-md-right text-lg-right">
                    <li>
                        <a href="https://twitter.com/PerlWChallenge" class="twitter" rel="noreferrer" target="_blank" title="Follow us">
                            <i class="ion-social-twitter"></i>
                        </a>
                    </li>
                    <li>
                        <a href="/rss.xml" class="rss" target="_blank" title="RSS Feed">
                            <i class="ion-social-rss"></i>
                        </a>
                    </li>
                </ul>
            </div>
        </div>
    </div>
</footer>
<!-- footer section end -->

<!-- jquery -->
<script src="https://theweeklychallenge.org/plugins/jquery/jquery.min.js"></script>
<!-- Form Validation -->
<script src="https://theweeklychallenge.org/plugins/form-validation/jquery.form.min.js"></script>
<script src="https://theweeklychallenge.org/plugins/form-validation/jquery.validate.min.js"></script>
<!-- slick slider -->
<script src="https://theweeklychallenge.org/plugins/slick/slick.min.js"></script>
<!-- bootstrap js -->
<script src="https://theweeklychallenge.org/plugins/bootstrap/bootstrap.min.js"></script>
<!-- chart js -->
<script src="https://theweeklychallenge.org/plugins/chart/highstock.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/drilldown.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/data.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/chart.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/pwc-challenge.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/gc-challenge.js"></script>
<!-- wow js -->
<script src="https://theweeklychallenge.org/plugins/wow-js/wow.min.js"></script>
<!-- slider js -->
<script src="https://theweeklychallenge.org/plugins/slider/slider.js"></script>
<!-- Fancybox -->
<script src="https://theweeklychallenge.org/plugins/facncybox/jquery.fancybox.js"></script>
<!-- template main js -->

<script src="https://theweeklychallenge.org/js/script.min.js"></script>
<!-- google analitycs -->

<script async src="https://www.googletagmanager.com/gtag/js?id=G-CJTPYM9SB8"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-CJTPYM9SB8');
</script>
</body>

</html>

