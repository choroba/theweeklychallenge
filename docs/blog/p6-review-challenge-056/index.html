<!DOCTYPE html>
<html class="no-js" lang="en-us">
<head>
    <!-- Basic Page Needs -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:title"       content="The Weekly Challenge: Laurent Rosenfeld Weekly Review: Challenge - 056"/>
    <meta property="og:type"        content="website"/>
    <meta property="og:url"         content="https://theweeklychallenge.org/blog/p6-review-challenge-056/"/>
    <meta property="og:image"       content="https://theweeklychallenge.org/images/blog/p6-review-challenge-056.jpg"/>
    <meta property="og:description" content="Laurent Rosenfeld Weekly Review: Challenge - #056."/>
    <meta name="twitter:card"       content="summary" />
    <meta name="twitter:image"      content="https://theweeklychallenge.org/images/blog/p6-review-challenge-056.jpg"/>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <meta name="description" content="Laurent Rosenfeld Weekly Review: Challenge - #056.">
    <meta name="author" content="The Weekly Challenge Team">
    <meta name="generator" content="Hugo 0.67.0-DEV" />

    <link rel="me" href="https://fosstodon.org/@manwar">
    <link rel="canonical" href="https://theweeklychallenge.org/blog/p6-review-challenge-056/" />

    <!-- Mobile Specific Metas -->
    <meta name="format-detection" content="telephone=no">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Laurent Rosenfeld Weekly Review: Challenge - 056</title>
    <link rel="icon" href="https://theweeklychallenge.org/images/favicon.ico">

    
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css"/>

    <!-- Twitter Bootstrs CSS -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/bootstrap/bootstrap.min.css">
    <!-- Ionicons Fonts Css -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/ionicons/ionicons.min.css">
    <!-- animate css -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/animate-css/animate.css">
    <!-- Hero area slider css-->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/slider/slider.css">
    <!-- slick slider -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/slick/slick.css">
    <!-- Fancybox -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/facncybox/jquery.fancybox.css">
    <!-- hover -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/hover/hover-min.css">
    <!-- Google fonts -->
    <link href='https://fonts.googleapis.com/css?family=Source Code Pro' rel='stylesheet'>
    <!-- template main css file -->
    
    <link rel="stylesheet" href="https://theweeklychallenge.org/css/style.min.css" integrity="" media="screen">
    <link rel="stylesheet" href="https://theweeklychallenge.org/css/main.css">

    <style>
        #goTopButton {
            display: none;          
            position: fixed;        
            bottom: 20px;           
            right: 30px;            
            z-index: 99;            
            border: none;           
            outline: none;          
            background-color: red;  
            color: white;           
            cursor: pointer;        
            padding: 15px;          
            border-radius: 10px;    
            font-size: 18px;        
        }

        #goTopButton:hover {
              background-color: #555;
        }
    </style>


</head>

<body>

<button onclick="goTop()" id="goTopButton" title="Go to top">Top</button>

<script>

    topButton = document.getElementById("goTopButton");

    
    window.onscroll = function() { scrollFunction() };

    function scrollFunction() {
        if (document.body.scrollTop > 40 || document.documentElement.scrollTop > 40) {
            topButton.style.display = "block";
        } else {
            topButton.style.display = "none";
        }
    }

    
    function goTop() {
        document.body.scrollTop = 0; 
        document.documentElement.scrollTop = 0; 
    }

</script>

<section class="top-bar animated-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-12">
                <nav class="navbar navbar-expand-lg navbar-light bg-light">
                    <a class="navbar-brand" href="https://theweeklychallenge.org/">
                        <img src="https://theweeklychallenge.org/images/logo.svg" alt="logo">
                    </a>
                    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navgation" aria-controls="navigation"
                        aria-expanded="false" aria-label="Toggle navigation">
                        <span class="navbar-toggler-icon"></span>
                    </button>

                    <div class="collapse navbar-collapse" id="navigation">
                        <ul class="navbar-nav ml-auto">
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/">Home</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/about">About</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/chart">Chart</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/champions">Champions</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/team">Team</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/challenges">Challenges</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/p5-reviews">Perl/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/p6-reviews">Raku/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/recaps">Recaps</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/blogs">Blogs</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/faq">FAQ</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/contact">Contact</a>
                            </li>
                            
                        </ul>
                    </div>
                </nav>
            </div>
        </div>
    </div>
</section>


<section class="global-page-header">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2>Laurent Rosenfeld Weekly Review: Challenge - 056</h2>
                    <div class="portfolio-meta">
                        <span>Thursday, May 7, 2020</span>|
                        <span> Tags:
                            Raku
                        </span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

<section class="single-post">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                
                <div style="text-align: center" class="post-img">
                    <img class="img-fluid" alt="" src="https://theweeklychallenge.org/images/blog/p6-review-challenge-056.jpg">
                </div>
                
                <div style="text-align: justify" class="post-content">
                    <hr>
<h1 id="raku-solutions-weekly-review">Raku Solutions Weekly Review</h1>
<hr>
<h1 id="path-sums-in-a-binary-tree">Path Sums in a Binary Tree</h1>
<p>This is derived in part from my <a href="http://blogs.perl.org/users/laurent_r/2020/04/perl-weekly-challenge-56-diff-k-and-path-sum.html">blog post</a> made in answer to the <a href="https://perlweeklychallenge.org/blog/perl-weekly-challenge-056/">Week 56 of the Perl Weekly Challenge</a> organized by  <a href="http://blogs.perl.org/users/mohammad_s_anwar/">Mohammad S. Anwar</a> as well as answers made by others to the same challenge.</p>
<p>The challenge reads as follows:
<em>You are given a binary tree and a sum, write a script to find if the tree has a path such that adding up all the values along the path equals the given sum. Only complete paths (from root to leaf node) may be considered for a sum.</em></p>
<p><em>Example: given the below binary tree and sum = 22,</em></p>
<pre><code>      5
     / \
    4   8
   /   / \
  11  13  9
 /  \      \
7    2      1
</code></pre>
<p><em>For the given binary tree, the partial path sum 5 → 8 → 9 = 22 is not valid.</em></p>
<p><em>The script should return the path 5 → 4 → 11 → 2 whose sum is 22.</em></p>
<p>So basically we have to implement a <a href="https://en.wikipedia.org/wiki/Depth-first_search">depth-first tree traversal</a> algorithm. Once this is done, finding the paths matching the criteria is quite easy.</p>
<p>The first question to be answered is: how do we represent a binary tree? There are a number of possibilities. We’ll just present three.</p>
<p>The most obvious way might be a nested hash of hashes. Each node is represented by a hash with three items: the current node value, a reference to the left child and a reference to the right child. For example, the top three rows of the binary tree shown above could look like this: <code>{ val =&gt; 5, left =&gt; {val =&gt; 4, left =&gt; { val =&gt; 11}}, right =&gt; { val =&gt; 8, left =&gt; { val =&gt; 13}, right { val =&gt; 9 }}}</code>. Or, in a more graphical way:</p>
<pre><code>{ val =&gt; 5,
  left =&gt; {
    val =&gt; 4,
    left =&gt; {
        val =&gt; 11
    }
  },
  right =&gt; {
    val =&gt; 8,
    left =&gt; {
        val =&gt; 13
        },
        right {
            val =&gt; 9
        }
    }
}
</code></pre>
<p>But that&rsquo;s quite verbose, I don’t like doing so much typing. I&rsquo;ll present an example of that implementation in my <a href="https://github.com/LaurentRosenfeld/Perl-6-Miscellaneous/blob/master/Challenges-in-Perl6/Tree-inversion.md">review of Raku solutions to PWC 57</a>.</p>
<p>A more concise way would to use a nested array of arrays. For each node, the first array item is the current value, the second item the left child and the third item the right child. The top of the tree shown above might look like this: <code>[5, [4, [11]], [8, [13], ]]</code>. Or, more graphically:</p>
<pre><code>[
    5,
    [
        4, [11]
       ],
    [
        8, [13]
    ]
]
</code></pre>
<p>We could also use an array of arrays by level (breadth-first), which will also be shown in my <a href="https://github.com/LaurentRosenfeld/Perl-6-Miscellaneous/blob/master/Challenges-in-Perl6/Tree-inversion.md">review of Raku solutions to PWC 57</a>.</p>
<p>We could even use a simple flat array in a way similar to what is commonly done for <em>binary heaps</em> (i.e. a binary tree that keeps a partial order). Here we&rsquo;re not interested with partial order, but the idea is to use an array with an implicit data structure reflected in the following properties. The item with subscript 0 is the value of the root node. The index of an element is used to compute the index of its parent and the indices of its children. The basic idea is that, for any node, the index of its parent is about half the index of the current node, and, conversely, the indices of the children are about twice the index of the current node. More precisely, for a tree starting at index 0, the exact formulas for a node with index <code>$n</code> are commonly as follows:</p>
<ul>
<li>parent: <code>int( ($n-1)/2 )</code></li>
<li>left child: <code>2*$n + 1</code></li>
<li>right child: <code>2*$n + 2</code></li>
</ul>
<p>The root node is at index 0, and its children are at positions 1 and 2. The children of item with index 1 are at positions 3 and 4 and the children of 2 are at positions 5 and 6.</p>
<p>These rules may seem a bit complicated (and it is a bit tedious to compute these things manually), but they&rsquo;re in fact quite easy to implement:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">children</span> ($i) {
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>$i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>$i<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>;
}
</code></pre></div><p>The binary tree:</p>
<pre><code>      5
     / \
    4   8
   /   / \
  11  13  9
</code></pre>
<p>would be represented by this simple array:</p>
<pre><code>[5, 4, 8, 11, , 13, 9]
</code></pre>
<p>Note that it is very easy to populate the binary-heap-like array from a graphical representation: you just need to perform a breadth-first traversal and provide empty slots for missing nodes if any.</p>
<p>Another very tempting possibility is to implement a class for binary trees providing the basic data structure and possibly methods for tree traversal and other common operations on trees. I did not implement such a class, but several other challengers did, as we&rsquo;ll see below.</p>
<h4 id="implementing-the-tree-as-a-nested-array-of-arrays">Implementing the Tree as a Nested Array of Arrays</h4>
<p>We&rsquo;ll use a nested array of arrays to represent the binary tree. We implement a recursive <code>dfs</code> (for depth-first search) subroutine to walk through the various paths of the tree. At each call of the subroutine, we keep track of the current sum and of the current path. When we reach a leaf (no more child), we print the path if the current sum is equal to the target value.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">use</span> v6;

<span style="color:#66d9ef">my</span> @tree <span style="color:#f92672">=</span> [<span style="color:#ae81ff">5</span>, [<span style="color:#ae81ff">4</span>, [<span style="color:#ae81ff">11</span>, [<span style="color:#ae81ff">7</span>], [<span style="color:#ae81ff">2</span>]]], [<span style="color:#ae81ff">8</span>, [<span style="color:#ae81ff">13</span>], [<span style="color:#ae81ff">9</span>, [<span style="color:#ae81ff">1</span>]]]] ;

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">dfs</span> (@node, $target, $sum, @path) {
    <span style="color:#66d9ef">my</span> $new<span style="color:#f92672">-</span>sum <span style="color:#f92672">=</span> $sum <span style="color:#f92672">+</span> @node[<span style="color:#ae81ff">0</span>];
    <span style="color:#66d9ef">unless</span> @node[<span style="color:#ae81ff">1</span>]:exists <span style="color:#f92672">or</span> @node[<span style="color:#ae81ff">2</span>]:exists {
        say $new<span style="color:#f92672">-</span>sum, <span style="color:#e6db74">&#34; -&gt; @path[] @node[0]&#34;</span> <span style="color:#66d9ef">if</span> $new<span style="color:#f92672">-</span>sum <span style="color:#f92672">==</span> $target;
    }
    dfs(@node[<span style="color:#ae81ff">1</span>], $target, $new<span style="color:#f92672">-</span>sum, (@path, @node[<span style="color:#ae81ff">0</span>])<span style="color:#f92672">.</span>flat)
        <span style="color:#66d9ef">if</span> defined @node[<span style="color:#ae81ff">1</span>];
    dfs(@node[<span style="color:#ae81ff">2</span>], $target, $new<span style="color:#f92672">-</span>sum, (@path, @node[<span style="color:#ae81ff">0</span>])<span style="color:#f92672">.</span>flat)
        <span style="color:#66d9ef">if</span> defined @node[<span style="color:#ae81ff">2</span>];
}

<span style="color:#66d9ef">my</span> $target <span style="color:#f92672">=</span> @<span style="color:#960050;background-color:#1e0010">*</span>ARGS<span style="color:#f92672">.</span>elems <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> ?? @<span style="color:#960050;background-color:#1e0010">*</span>ARGS[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">!!</span> <span style="color:#ae81ff">22</span>;
dfs(@tree, $target, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">[]</span>);
</code></pre></div><p>Here are a few runs:</p>
<pre><code>$ perl6  bin_tree_sum.p6
22 -&gt; 5 4 11 2

$ perl6  bin_tree_sum.p6 22
22 -&gt; 5 4 11 2

$ perl6  bin_tree_sum.p6 24

$ perl6  bin_tree_sum.p6 26
26 -&gt; 5 8 13

$ perl6  bin_tree_sum.p6 23
23 -&gt; 5 8 9 1
</code></pre>
<h4 id="implementing-the-tree-as-a-flat-array-binary-heap-like">Implementing the Tree as a Flat Array (Binary-Heap-Like)</h4>
<p>As explained above, we can use a flat array to represent a binary tree, with the following rules: the indices of the children of a node with index <code>$n</code> are as follows:</p>
<ul>
<li>left child: <code>2*$n + 1</code></li>
<li>right child: <code>2*$n + 2</code></li>
</ul>
<p>In Raku, it isn&rsquo;t possible to just leave an &ldquo;empty slot&rdquo; when defining an array (as we could in Perl). We need to provide undefined values, such as, for example, <code>Nil</code>, <code>Any</code>, or <code>Int</code>. We&rsquo;ll use <code>Int</code> since it is the most consistent option with a tree made of integers.</p>
<p>The code isn&rsquo;t much more complicated than before:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">use</span> v6;

<span style="color:#66d9ef">my</span> @tree <span style="color:#f92672">=</span> [<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">11</span>, Int, <span style="color:#ae81ff">13</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">2</span>, Int, Int, Int, Int, <span style="color:#ae81ff">1</span>];

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">dfs</span> ($index, $target, $sum, @path) {
    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">children</span> ($i) { <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>$i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>$i<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span> }
    <span style="color:#66d9ef">my</span> $cur<span style="color:#f92672">-</span>val <span style="color:#f92672">=</span> @tree[$index];
    <span style="color:#66d9ef">my</span> $new<span style="color:#f92672">-</span>sum <span style="color:#f92672">=</span> $sum <span style="color:#f92672">+</span> $cur<span style="color:#f92672">-</span>val;
    <span style="color:#66d9ef">my</span> ($left, $right) <span style="color:#f92672">=</span> children $index;
    <span style="color:#66d9ef">unless</span> defined @tree[$left] <span style="color:#f92672">or</span> defined @tree[$right] {
        say $new<span style="color:#f92672">-</span>sum, <span style="color:#e6db74">&#34; -&gt; @path[] $cur-val&#34;</span> <span style="color:#66d9ef">if</span> $new<span style="color:#f92672">-</span>sum <span style="color:#f92672">==</span> $target;
    }
    dfs($left, $target, $new<span style="color:#f92672">-</span>sum, (@path, $cur<span style="color:#f92672">-</span>val)<span style="color:#f92672">.</span>flat)
        <span style="color:#66d9ef">if</span> defined @tree[$left];
    dfs($right, $target, $new<span style="color:#f92672">-</span>sum, (@path, $cur<span style="color:#f92672">-</span>val)<span style="color:#f92672">.</span>flat)
        <span style="color:#66d9ef">if</span> defined @tree[$right];
}

<span style="color:#66d9ef">my</span> $target <span style="color:#f92672">=</span> @<span style="color:#960050;background-color:#1e0010">*</span>ARGS<span style="color:#f92672">.</span>elems <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> ?? @<span style="color:#960050;background-color:#1e0010">*</span>ARGS[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">!!</span> <span style="color:#ae81ff">22</span>;
<span style="color:#66d9ef">my</span> $root<span style="color:#f92672">-</span>node <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
dfs($root<span style="color:#f92672">-</span>node, $target, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">[]</span>);
</code></pre></div><p>Here are a few runs:</p>
<pre><code>$ perl6 bin_tree_sum2.p6
22 -&gt; 5 4 11 2

$ perl6 bin_tree_sum2.p6 22
22 -&gt; 5 4 11 2

$ perl6 bin_tree_sum2.p6 23
23 -&gt; 5 8 9 1

$ perl6 bin_tree_sum2.p6 24

$ perl6 bin_tree_sum2.p6 26
26 -&gt; 5 8 13
</code></pre>
<h2 id="alternative-solutions">Alternative Solutions</h2>
<p>Most of the challengers implemented a simple class to implement a tree node data structure, but, curiously, only one (Simon Proctor) really implemented an object-oriented program.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-056/arne-sommer/raku/ch-2.p6">Arne Sommer</a> implemented a simple recursive <code>BinaryNode</code>class:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl">class BinaryNode
{
  has Int        $<span style="color:#960050;background-color:#1e0010">.</span>value;
  has BinaryNode $<span style="color:#960050;background-color:#1e0010">.</span>left;
  has BinaryNode $<span style="color:#960050;background-color:#1e0010">.</span>right;
}
</code></pre></div><p>The bulk of the work is done in the recursive <code>traverse</code> subroutine, which implements a depth-first walk through the tree and checks whether the path sum is equal to the target value:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">traverse</span> ($current, $target-sum, @path is copy)
{
  <span style="color:#66d9ef">if</span> ($current<span style="color:#f92672">.</span>left <span style="color:#f92672">or</span> $current<span style="color:#f92672">.</span>right)
  {
    @path<span style="color:#f92672">.</span>push: $current<span style="color:#f92672">.</span>value;

    traverse($current<span style="color:#f92672">.</span>left,  $target<span style="color:#f92672">-</span>sum, @path) <span style="color:#66d9ef">if</span> $current<span style="color:#f92672">.</span>left;
    traverse($current<span style="color:#f92672">.</span>right, $target<span style="color:#f92672">-</span>sum, @path) <span style="color:#66d9ef">if</span> $current<span style="color:#f92672">.</span>right;
  }
  <span style="color:#66d9ef">else</span>
  {
    @path<span style="color:#f92672">.</span>push: $current<span style="color:#f92672">.</span>value;
    say <span style="color:#e6db74">&#34;: &#34;</span> <span style="color:#f92672">~</span> @path<span style="color:#f92672">.</span>join(<span style="color:#e6db74">&#34; -&gt; &#34;</span>) <span style="color:#66d9ef">if</span> $verbose;
    say @path<span style="color:#f92672">.</span>join(<span style="color:#e6db74">&#34; -&gt; &#34;</span>) <span style="color:#66d9ef">if</span> @path<span style="color:#f92672">.</span>sum <span style="color:#f92672">==</span> $target<span style="color:#f92672">-</span>sum;
    <span style="color:#66d9ef">return</span>;
  }
}
</code></pre></div><p>The rest of the code takes an input string representing a breadth-first representation of the tree and transforms it into a nested <code>BinaryNode</code> object:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl">unit <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">MAIN</span> (Int :$sum = 22, Str :$tree = &#34;5 | 4 8 | 11 * 13 9 | 7 2 * * * 1&#34;, :$verbose);

my @btree = $tree.split(&#34;|&#34;)&gt;&gt;.words;

my @old-nodes;
my @new-nodes;

for @btree.reverse -&gt; $row
{
  <span style="color:#66d9ef">my</span> @current <span style="color:#f92672">=</span> @$row;
  @old<span style="color:#f92672">-</span>nodes  <span style="color:#f92672">=</span> @new<span style="color:#f92672">-</span>nodes;
  @new<span style="color:#f92672">-</span>nodes  <span style="color:#f92672">=</span> ();

  <span style="color:#66d9ef">for</span> @current <span style="color:#f92672">-&gt;</span> $value
  {
    <span style="color:#66d9ef">if</span> $value <span style="color:#f92672">eq</span> <span style="color:#e6db74">&#34;*&#34;</span>
    {
      @new<span style="color:#f92672">-</span>nodes<span style="color:#f92672">.</span>push(<span style="color:#e6db74">&#34;*&#34;</span>);
      <span style="color:#66d9ef">next</span>;
    }

    <span style="color:#66d9ef">my</span> $left  <span style="color:#f92672">=</span> @old<span style="color:#f92672">-</span>nodes<span style="color:#f92672">.</span>shift <span style="color:#e6db74">//</span> <span style="color:#e6db74">&#34;*&#34;</span>; $left  <span style="color:#f92672">=</span> Nil <span style="color:#66d9ef">if</span> $left  <span style="color:#f92672">eq</span> <span style="color:#e6db74">&#34;*&#34;</span>;
    <span style="color:#66d9ef">my</span> $right <span style="color:#f92672">=</span> @old<span style="color:#f92672">-</span>nodes<span style="color:#f92672">.</span>shift <span style="color:#e6db74">//</span> <span style="color:#e6db74">&#34;*&#34;</span>; $right <span style="color:#f92672">=</span> Nil <span style="color:#66d9ef">if</span> $right <span style="color:#f92672">eq</span> <span style="color:#e6db74">&#34;*&#34;</span>;

    @new<span style="color:#f92672">-</span>nodes<span style="color:#f92672">.</span>push(BinaryNode<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(value <span style="color:#f92672">=&gt;</span> $value<span style="color:#f92672">.</span>Int,
                                   left  <span style="color:#f92672">=&gt;</span> $left  <span style="color:#e6db74">//</span> Nil,
                                   right <span style="color:#f92672">=&gt;</span> $right <span style="color:#e6db74">//</span> Nil));
  }
}

<span style="color:#66d9ef">my</span> $btree <span style="color:#f92672">=</span> @new<span style="color:#f92672">-</span>nodes[<span style="color:#ae81ff">0</span>];

say $btree, <span style="color:#e6db74">&#34;\n&#34;</span> <span style="color:#66d9ef">if</span> $verbose;

traverse($btree, $sum, ());
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-056/kevin-colyer/raku/ch-2.p6">Kevin Colyer</a> also used an object-oriented implementation, and created a recursive <code>node</code> class quite similar to Arne&rsquo;s <code>BinaryNode</code> class:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl">class node {
    has Int $<span style="color:#960050;background-color:#1e0010">.</span>value;
    has node $<span style="color:#960050;background-color:#1e0010">.</span>left;
    has node $<span style="color:#960050;background-color:#1e0010">.</span>right;
}
</code></pre></div><p>Kevin&rsquo;s binary tree is a nested hard-coded <code>node</code> object:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">my</span> $root <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(value <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">5</span>,
    left <span style="color:#f92672">=&gt;</span> node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(value <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">4</span>, left <span style="color:#f92672">=&gt;</span> node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(value <span style="color:#f92672">=&gt;</span><span style="color:#ae81ff">11</span>, left<span style="color:#f92672">=&gt;</span>node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(value<span style="color:#f92672">=&gt;</span><span style="color:#ae81ff">7</span>),right <span style="color:#f92672">=&gt;</span> node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(value <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">2</span>))),
    right <span style="color:#f92672">=&gt;</span> node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(value<span style="color:#f92672">=&gt;</span><span style="color:#ae81ff">8</span>,left<span style="color:#f92672">=&gt;</span>node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(value<span style="color:#f92672">=&gt;</span><span style="color:#ae81ff">13</span>),right<span style="color:#f92672">=&gt;</span> node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(value<span style="color:#f92672">=&gt;</span><span style="color:#ae81ff">9</span>,right<span style="color:#f92672">=&gt;</span> node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(value<span style="color:#f92672">=&gt;</span><span style="color:#ae81ff">1</span>)))
    );
</code></pre></div><p>Otherwise, most of the work is done in the recursive <code>dfs</code> subroutine implementing a depth-first traversal:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">dfs</span>($node,$target,$new=True) {
    state $found<span style="color:#f92672">=</span>False;
    state @values;
    <span style="color:#66d9ef">if</span> $new {
        @values <span style="color:#f92672">=</span> Empty;
        $found<span style="color:#f92672">=</span>False;
    }
    <span style="color:#66d9ef">my</span> $siblings<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
    @values<span style="color:#f92672">.</span>push: $node<span style="color:#f92672">.</span>value;

    <span style="color:#66d9ef">if</span> $node<span style="color:#f92672">.</span>left:defined {
        $siblings<span style="color:#f92672">++</span>;
        dfs($node<span style="color:#f92672">.</span>left, $target,False);
        <span style="color:#66d9ef">return</span> @values <span style="color:#66d9ef">if</span> $found;
    }

    <span style="color:#66d9ef">if</span> $node<span style="color:#f92672">.</span>right:defined {
        $siblings<span style="color:#f92672">++</span>;
        dfs($node<span style="color:#f92672">.</span>right,$target,False);
        <span style="color:#66d9ef">return</span> @values <span style="color:#66d9ef">if</span> $found;
    }

    <span style="color:#75715e"># lone leaf</span>
    <span style="color:#66d9ef">if</span> $siblings<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> @values<span style="color:#f92672">.</span>sum<span style="color:#f92672">==</span>$target {
        $found<span style="color:#f92672">=</span>True;
        <span style="color:#66d9ef">return</span> @values;
    }

    <span style="color:#75715e"># not found so back track</span>
    @values<span style="color:#f92672">.</span>pop;
    <span style="color:#66d9ef">return</span> Empty;
}
</code></pre></div><p>The rest of his code consists in two multi <code>MAIN</code> subroutines:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6">multi MAIN(<span style="color:#e6db74">&#39;test&#39;</span>) {
    dfs($root,$_)<span style="color:#f92672">.</span>say <span style="color:#66d9ef">for</span> <span style="color:#ae81ff">15</span><span style="color:#f92672">..</span><span style="color:#ae81ff">30</span>;
}
multi MAIN(Int $target where <span style="color:#f92672">*</span> <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
    <span style="color:#66d9ef">my</span> @values<span style="color:#f92672">=</span>dfs($root,$target);
    <span style="color:#66d9ef">if</span> @values <span style="color:#f92672">==</span> Empty {
        say <span style="color:#e6db74">&#34;Target sum [$target] not found in tree&#34;</span>;
        exit;
    }
    say @values<span style="color:#f92672">.</span>join(<span style="color:#e6db74">&#34; -&gt; &#34;</span>) <span style="color:#f92672">~</span> <span style="color:#e6db74">&#34; = $target&#34;</span>;
}
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-056/luca-ferrari/raku/ch-2.p6">Luca Ferrari</a> also used an object-oriented representation and implemented a recursive <code>Node</code> class:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl">class Node {
    has Int:D  $<span style="color:#960050;background-color:#1e0010">.</span>value <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    has Node $<span style="color:#960050;background-color:#1e0010">.</span>left is rw;
    has Node $<span style="color:#960050;background-color:#1e0010">.</span>right is rw;
    has Node $<span style="color:#960050;background-color:#1e0010">.</span>parent is rw;
    has Bool $<span style="color:#960050;background-color:#1e0010">.</span>is<span style="color:#f92672">-</span>leaf <span style="color:#f92672">=</span> False;
}
</code></pre></div><p>Populating the tree is done with hard coded object construction:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"> <span style="color:#66d9ef">my</span> $root                <span style="color:#f92672">=</span> Node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>( :value( <span style="color:#ae81ff">5</span> )  );
 $root<span style="color:#f92672">.</span>left              <span style="color:#f92672">=</span> Node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>( :value( <span style="color:#ae81ff">4</span> ), :parent( $root ) );
 $root<span style="color:#f92672">.</span>right             <span style="color:#f92672">=</span> Node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>( :value( <span style="color:#ae81ff">8</span> ), :parent( $root ) );
 $root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left         <span style="color:#f92672">=</span> Node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>( :value( <span style="color:#ae81ff">11</span> ), :parent( $root<span style="color:#f92672">.</span>left ) );
 $root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left        <span style="color:#f92672">=</span> Node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>( :value( <span style="color:#ae81ff">13</span> ), :parent( $root<span style="color:#f92672">.</span>right ), :is<span style="color:#f92672">-</span>leaf );
 $root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right       <span style="color:#f92672">=</span> Node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>( :value( <span style="color:#ae81ff">9</span> ), :parent( $root<span style="color:#f92672">.</span>right ) );
 $root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left    <span style="color:#f92672">=</span> Node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>( :value( <span style="color:#ae81ff">7</span> ),  :parent( $root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left ), :is<span style="color:#f92672">-</span>leaf );
 $root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right   <span style="color:#f92672">=</span> Node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>( :value( <span style="color:#ae81ff">2</span> ), :parent( $root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left ), :is<span style="color:#f92672">-</span>leaf );
 $root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>( :value( <span style="color:#ae81ff">1</span> ), :parent( $root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right ), :is<span style="color:#f92672">-</span>leaf );
</code></pre></div><p>Then, Luca stored all these objects into the <code>@nodes</code> array for the purpose of building an array of leaves, and implemented an <em>upward</em> (from the leaves to the root) tree traversal:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#66d9ef">my</span> @nodes <span style="color:#f92672">=</span> $root
    , $root<span style="color:#f92672">.</span>left
    , $root<span style="color:#f92672">.</span>right
    , $root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left
    , $root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left
    , $root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right
    , $root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left
    , $root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right
    , $root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right;

<span style="color:#75715e"># find the leaves</span>
<span style="color:#66d9ef">my</span> @leaves <span style="color:#f92672">=</span> @nodes<span style="color:#f92672">.</span>grep( <span style="color:#f92672">*.</span>is<span style="color:#f92672">-</span>leaf );

<span style="color:#75715e"># now walk from the leaves to the root</span>
<span style="color:#66d9ef">for</span> @leaves  {
    <span style="color:#66d9ef">my</span> @path <span style="color:#f92672">=</span> [ <span style="color:#f92672">.</span>value ];
    <span style="color:#66d9ef">my</span> $node <span style="color:#f92672">=</span> $_;
    @path<span style="color:#f92672">.</span>push: $node<span style="color:#f92672">.</span>value <span style="color:#66d9ef">while</span> ( $node <span style="color:#f92672">=</span> $node<span style="color:#f92672">.</span>parent );
    <span style="color:#66d9ef">my</span> $sum <span style="color:#f92672">=</span> [<span style="color:#f92672">+</span>] @path;
    say <span style="color:#e6db74">&#34;Sum is $sum with the path { @path.reverse }&#34;</span> <span style="color:#66d9ef">if</span> ( $sum <span style="color:#f92672">==</span> $target );
}
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-056/markus-holzer/raku/ch-2.p6">Markus Holzer</a> used a hash of hashes to store the tree data structure:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">my</span> %tree <span style="color:#f92672">=</span>
    <span style="color:#ae81ff">5</span> <span style="color:#f92672">=&gt;</span> {
        <span style="color:#ae81ff">4</span> <span style="color:#f92672">=&gt;</span> {
            <span style="color:#ae81ff">11</span> <span style="color:#f92672">=&gt;</span> {
                <span style="color:#ae81ff">7</span> <span style="color:#f92672">=&gt;</span> Any,
                <span style="color:#ae81ff">2</span> <span style="color:#f92672">=&gt;</span> Any
            },
        },
        <span style="color:#ae81ff">8</span> <span style="color:#f92672">=&gt;</span> {
             <span style="color:#ae81ff">9</span> <span style="color:#f92672">=&gt;</span> {
                <span style="color:#ae81ff">1</span> <span style="color:#f92672">=&gt;</span> Any
             },
             <span style="color:#ae81ff">7</span> <span style="color:#f92672">=&gt;</span> {
                <span style="color:#ae81ff">2</span> <span style="color:#f92672">=&gt;</span> Any
             },
             <span style="color:#ae81ff">13</span> <span style="color:#f92672">=&gt;</span> Any,
        }
    };
</code></pre></div><p>The structure is quite concise. Its possible shortcoming is that, since hashes don&rsquo;t have any order, there is no distinction between left and right children, but it absolutely doesn&rsquo;t matter with the task to be solved.</p>
<p>Markus&rsquo;s code for traversing the tree is fairly concise and uses the <code>find-path-sum</code> recursive multi subroutine:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#f92672">.</span>join(<span style="color:#e6db74">&#39;→&#39;</span>)<span style="color:#f92672">.</span>say
    <span style="color:#66d9ef">for</span> find<span style="color:#f92672">-</span>path<span style="color:#f92672">-</span>sum( %tree, <span style="color:#ae81ff">22</span> );

multi <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">find</span>-path-sum( Hash:D $tree, Int $n )
{
    multi <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">find</span>-path-sum( Hash:D $tree, Int $n, Array $path ) {
        find<span style="color:#f92672">-</span>path<span style="color:#f92672">-</span>sum( $tree{ $_ }, $n <span style="color:#f92672">-</span> $_, $path<span style="color:#f92672">.</span>clone<span style="color:#f92672">.</span>push($_) )
            <span style="color:#66d9ef">for</span> $tree<span style="color:#f92672">.</span>keys; }

    multi <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">find</span>-path-sum( Any, Int $n, Array $path ) {
        take $path <span style="color:#66d9ef">if</span> $n <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>; }

    gather find<span style="color:#f92672">-</span>path<span style="color:#f92672">-</span>sum( $tree, $n, <span style="color:#f92672">[]</span> );
}
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-056/noud/raku/ch-2.p6">Noud Aldenhoven</a> created a recursive <code>Node</code> class to store the tree data structure:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl">class Node {
    has Node $<span style="color:#960050;background-color:#1e0010">.</span>left;
    has Node $<span style="color:#960050;background-color:#1e0010">.</span>right;
    has $<span style="color:#960050;background-color:#1e0010">.</span>value;
}
</code></pre></div><p>Noud wrote an recursive <code>path-sum</code> subroutine to traverse the tree and compute all possible path sums:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">path</span>-sum($tree, $sum) {
    <span style="color:#66d9ef">if</span> ($tree<span style="color:#f92672">.</span>value <span style="color:#f92672">==</span> $sum) {
        <span style="color:#66d9ef">if</span> ($tree<span style="color:#f92672">.</span>left <span style="color:#f92672">||</span> $tree<span style="color:#f92672">.</span>right) {
            <span style="color:#66d9ef">return</span> <span style="color:#f92672">[]</span>;
        } <span style="color:#66d9ef">else</span> {
            <span style="color:#66d9ef">return</span> [[$tree<span style="color:#f92672">.</span>value],];
        }
    }

    <span style="color:#66d9ef">my</span> @ret <span style="color:#f92672">=</span> <span style="color:#f92672">[]</span>;
    <span style="color:#66d9ef">if</span> ($tree<span style="color:#f92672">.</span>left) {
        <span style="color:#66d9ef">for</span> path<span style="color:#f92672">-</span>sum($tree<span style="color:#f92672">.</span>left, $sum <span style="color:#f92672">-</span> $tree<span style="color:#f92672">.</span>value) <span style="color:#f92672">-&gt;</span> @r {
            @ret<span style="color:#f92672">.</span>push([$tree<span style="color:#f92672">.</span>value, <span style="color:#f92672">|</span>(@r)]);
        }
    }
    <span style="color:#66d9ef">if</span> ($tree<span style="color:#f92672">.</span>right) {
        <span style="color:#66d9ef">for</span> path<span style="color:#f92672">-</span>sum($tree<span style="color:#f92672">.</span>right, $sum <span style="color:#f92672">-</span> $tree<span style="color:#f92672">.</span>value) <span style="color:#f92672">-&gt;</span> @r {
            @ret<span style="color:#f92672">.</span>push([$tree<span style="color:#f92672">.</span>value, <span style="color:#f92672">|</span>(@r)]);
        }

    }
    <span style="color:#66d9ef">return</span> @ret;
}
</code></pre></div><p>Finally, this is Noud&rsquo;s code for populating the nested tree object and calling <code>path-sum</code> subroutine:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">my</span> Node $tree <span style="color:#f92672">.=</span> <span style="color:#66d9ef">new</span>(
    value <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">5</span>,
    left <span style="color:#f92672">=&gt;</span> Node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(
        value <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">4</span>,
        left <span style="color:#f92672">=&gt;</span> Node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(
            value <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">11</span>,
            left <span style="color:#f92672">=&gt;</span> Node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(
                value <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">7</span>),
            right <span style="color:#f92672">=&gt;</span> Node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(
                value <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">2</span>))),
    right <span style="color:#f92672">=&gt;</span> Node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(
        value <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">8</span>,
        left <span style="color:#f92672">=&gt;</span> Node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(
            value <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">13</span>),
        right <span style="color:#f92672">=&gt;</span> Node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(
            value <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">9</span>,
            right <span style="color:#f92672">=&gt;</span> Node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(
                value <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">1</span>))));

<span style="color:#66d9ef">for</span> path<span style="color:#f92672">-</span>sum($tree, <span style="color:#ae81ff">22</span>) <span style="color:#f92672">-&gt;</span> @full<span style="color:#f92672">-</span>path {
    say @full<span style="color:#f92672">-</span>path<span style="color:#f92672">.</span>join(<span style="color:#e6db74">&#39; -&gt; &#39;</span>);
}
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-056/simon-proctor/raku/ch-2.p6">Simon Proctor</a> made a full-fledged object-oriented program, including three classes, one role and even a grammar. Simon&rsquo;s code is more than 200-line long, so I will quote only parts of it (please follow the link if you want to see it all). Let&rsquo;s start with his <code>BTree</code> role, which implements most of the methods used in the program:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl">role BTree[<span style="color:#f92672">::</span>T] {
    has T $<span style="color:#960050;background-color:#1e0010">.</span>value is required;
    has BTree @<span style="color:#960050;background-color:#1e0010">!</span>nodes[<span style="color:#ae81ff">2</span>];

    method Str( ) {
        ( $<span style="color:#960050;background-color:#1e0010">!</span>value , <span style="color:#f92672">|</span>@<span style="color:#960050;background-color:#1e0010">.</span>nodes<span style="color:#f92672">.</span>map( { <span style="color:#e6db74">&#34;({$_})&#34;</span> } ) )<span style="color:#f92672">.</span>join(<span style="color:#e6db74">&#34;&#34;</span>);
    }

    method nodes() {
        @<span style="color:#960050;background-color:#1e0010">!</span>nodes<span style="color:#f92672">.</span>grep({defined $_});
    }

    method children() {
        @<span style="color:#960050;background-color:#1e0010">.</span>nodes<span style="color:#f92672">.</span>elems;
    }
    method gist() {
        BTreeRep<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>( tree<span style="color:#f92672">=&gt;</span>self )<span style="color:#f92672">.</span>gist();
    }

    method traverse() {
        gather {
            <span style="color:#66d9ef">if</span> ( self<span style="color:#f92672">.</span>children ) {
                <span style="color:#66d9ef">for</span> @<span style="color:#960050;background-color:#1e0010">.</span>nodes <span style="color:#f92672">-&gt;</span> $n {
                    <span style="color:#66d9ef">for</span> $n<span style="color:#f92672">.</span>traverse <span style="color:#f92672">-&gt;</span> @t {
                        take ($<span style="color:#960050;background-color:#1e0010">!</span>value, <span style="color:#f92672">|</span>@t);
                    }
                }
            } <span style="color:#66d9ef">else</span> {
                take ( $<span style="color:#960050;background-color:#1e0010">!</span>value, );
            }
        }
    }

    multi method from<span style="color:#f92672">-</span>Str(<span style="color:#e6db74">&#39;&#39;</span>) { BTree }

    multi method from<span style="color:#f92672">-</span>Str( <span style="color:#f92672">::</span>?CLASS:U: Str $in ) {
        <span style="color:#66d9ef">my</span> $match <span style="color:#f92672">=</span> BTreeGrammar<span style="color:#f92672">.</span>parse( $in );
        <span style="color:#66d9ef">if</span> ( $match ) {
            self<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(
                value <span style="color:#f92672">=&gt;</span> $match<span style="color:#e6db74">&lt;tree&gt;&lt;value&gt;</span><span style="color:#f92672">.</span>Str,
                nodes <span style="color:#f92672">=&gt;</span> [
                          self<span style="color:#f92672">.</span>from<span style="color:#f92672">-</span>Str( $match<span style="color:#e6db74">&lt;tree&gt;&lt;left&gt;</span> ?? $match<span style="color:#e6db74">&lt;tree&gt;&lt;left&gt;</span><span style="color:#f92672">.</span>Str <span style="color:#f92672">!!</span> <span style="color:#e6db74">&#39;&#39;</span> ),
                          self<span style="color:#f92672">.</span>from<span style="color:#f92672">-</span>Str( $match<span style="color:#e6db74">&lt;tree&gt;&lt;right&gt;</span> ?? $match<span style="color:#e6db74">&lt;tree&gt;&lt;right&gt;</span><span style="color:#f92672">.</span>Str <span style="color:#f92672">!!</span> <span style="color:#e6db74">&#39;&#39;</span> )
                      ]
            );
        } <span style="color:#66d9ef">else</span> {
            die <span style="color:#e6db74">&#34;Unable to Parse $in&#34;</span>;
        }

    }
}
</code></pre></div><p>The <code>BTree</code> role is then applied to the <code>UBTree</code> class like so:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl">class UBTree does BTree[UInt] {
    submethod BUILD ( UInt() :$value, :@nodes ) {
        $<span style="color:#960050;background-color:#1e0010">!</span>value <span style="color:#f92672">=</span> $value;
        @<span style="color:#960050;background-color:#1e0010">!</span>nodes <span style="color:#f92672">=</span> @nodes;
    }
}
</code></pre></div><p>For those who don&rsquo;t know, the default <code>BUILD</code> submethod is automatically called by the <code>new</code> constructor method. Here, it is necessary to redefine the <code>BUILD</code> submethod to properly initialize the class&rsquo;s private attributes.</p>
<p>Note that the <code>from-Str</code> method of the <code>BTree</code> role uses a grammar, <code>BTreeGrammar</code>, to parse the input string representing the input binary tree:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#75715e"># Example tree 5(4(11(7)(2)))(8(13)(9(1)))</span>
grammar BTreeGrammar {
    token TOP { <span style="color:#e6db74">&lt;tree&gt;</span> };
    token tree { <span style="color:#e6db74">&lt;value&gt;</span> [<span style="color:#e6db74">&#34;(&#34;</span> $<span style="color:#960050;background-color:#1e0010">&lt;</span>left<span style="color:#f92672">&gt;=</span><span style="color:#e6db74">&lt;tree&gt;</span> <span style="color:#e6db74">&#34;)&#34;</span>]? [<span style="color:#e6db74">&#34;(&#34;</span> $<span style="color:#960050;background-color:#1e0010">&lt;</span>right<span style="color:#f92672">&gt;=</span><span style="color:#e6db74">&lt;tree&gt;</span> <span style="color:#e6db74">&#34;)&#34;</span>]? };
    regex value { <span style="color:#e6db74">&lt;-[()]&gt;</span><span style="color:#f92672">+</span> }
}
</code></pre></div><p>There are many other interesting things in Simon&rsquo;s program, but, as I said, it&rsquo;s just too long to be quoted entirely.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-056/shahed-nooshmand/raku/ch-2.p6">Shahed Nooshmand</a>&lsquo;s program is incredibly short and concise:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl">multi paths(Pair $tree) {
    <span style="color:#f92672">|</span>paths($tree<span style="color:#f92672">.</span>value)<span style="color:#f92672">.</span>map: {$tree<span style="color:#f92672">.</span>key, <span style="color:#f92672">|</span>$_}
}
multi paths(Positional $nodes) {
    $nodes<span style="color:#f92672">.</span>map: { paths $_ }
}
multi paths($leaf) { $leaf }

<span style="color:#66d9ef">my</span> $tree <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span> <span style="color:#f92672">=&gt;</span> (<span style="color:#ae81ff">4</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">11</span> <span style="color:#f92672">=&gt;</span> (<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">2</span>),
                 <span style="color:#ae81ff">8</span> <span style="color:#f92672">=&gt;</span> (<span style="color:#ae81ff">9</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">13</span>));
say %<span style="color:#960050;background-color:#1e0010">(</span>paths($tree)<span style="color:#f92672">.</span>map: {<span style="color:#f92672">.</span>sum <span style="color:#f92672">=&gt;</span> $_}){<span style="color:#ae81ff">22</span>}
</code></pre></div><p>The multi recursive <code>paths</code> subroutine returns a list of all the complete paths in the tree. The tree is implemented as a hash in which each parent is the key of a <code>Pair</code>, and its children are the value of that <code>Pair</code>. I don&rsquo;t have much more to say about it, except that you should really take the time to read very carefully and understand this nice and beautiful gem.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-056/colin-crain/raku/ch-2.p6">Colin Crain</a>&lsquo;s submission starts (as quite commonly)  with a long comment explaining the various ways he considered for implementing the binary tree. Please follow the link, it is really an interesting reading. I think that Collin should really transform these detailed comments into blog posts, as they are really extremely interesting and informative (at least when the subject is so interesting). Anyway, back to the his comment, after a thorough discussion of various possibilities, Colin finally settled with an implementation of what I called &ldquo;flat array&rdquo; or binary-heap-like in my solutions.</p>
<p>The main work is done in the recursive <code>sum_path</code> subroutine:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">sum_path</span> (@tree, $target, $index, @prev_working, @paths) {
<span style="color:#75715e">## walks the tree and computes complete the path sum</span>
    <span style="color:#66d9ef">my</span> @working <span style="color:#f92672">=</span> @prev_working;
    @working<span style="color:#f92672">.</span>append: @tree[$index];

    <span style="color:#75715e">## if we are at a terminal node check the sum and return</span>
    <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span> @tree[$index <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>defined <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span> @tree[$index <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>]<span style="color:#f92672">.</span>defined ) {
        <span style="color:#66d9ef">my</span> $sum <span style="color:#f92672">=</span> [<span style="color:#f92672">+</span>] @working;
        @paths<span style="color:#f92672">.</span>push: @working <span style="color:#66d9ef">if</span> $sum <span style="color:#f92672">==</span> $target;

        say @working<span style="color:#f92672">.</span>join(<span style="color:#e6db74">&#39; + &#39;</span>) <span style="color:#f92672">~</span> <span style="color:#e6db74">&#34; = $sum&#34;</span>;

        <span style="color:#66d9ef">return</span>;
    }

    <span style="color:#66d9ef">for</span> ( $index <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, $index <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span> ) <span style="color:#f92672">-&gt;</span> $child {
        sum_path( @tree, $target, $child, @working, @paths ) <span style="color:#66d9ef">if</span> @tree[$child]<span style="color:#f92672">.</span>defined;
    }
}
</code></pre></div><p>Colin&rsquo;s program also has a <code>generate_tree</code> subroutine to generate random binary trees:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">generate_tree</span> ($depth){
<span style="color:#75715e">## automatically generates a random binary tree of rank n, with node values 1..10</span>
<span style="color:#75715e">## odds of a node being a terminator increase as the rank of the node increases</span>
<span style="color:#75715e">## which avoids trees with branches that quickly end</span>
    <span style="color:#66d9ef">my</span> @tree;
    @tree[<span style="color:#ae81ff">0</span>]  <span style="color:#f92672">=</span> (<span style="color:#f92672">^</span><span style="color:#ae81ff">10</span>)<span style="color:#f92672">.</span>pick;            <span style="color:#75715e">## always defined</span>
    <span style="color:#66d9ef">my</span> $nodes <span style="color:#f92672">=</span> (<span style="color:#ae81ff">2</span><span style="color:#f92672">**</span>($depth<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)) <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>;   <span style="color:#75715e">## 0-based count to last node, (start of next rank - 1)</span>

    <span style="color:#66d9ef">for</span> ( <span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$nodes ) <span style="color:#f92672">-&gt;</span> $index {
        <span style="color:#66d9ef">my</span> $rank <span style="color:#f92672">=</span> get_rank($index);
        <span style="color:#66d9ef">my</span> $parent <span style="color:#f92672">=</span> (($index<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>)<span style="color:#f92672">.</span>Int;
        <span style="color:#66d9ef">if</span> @tree[$parent]<span style="color:#f92672">.</span>defined {
            <span style="color:#75715e">## the odds of the switch being 0 increase as the rank progresses</span>
            <span style="color:#75715e">## the first node will always generate the next rank</span>
            <span style="color:#66d9ef">my</span> $switch <span style="color:#f92672">=</span> $index <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> ?? (<span style="color:#f92672">^</span>($nodes <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">**</span> $rank)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>)<span style="color:#f92672">.</span>pick<span style="color:#f92672">.</span>Int <span style="color:#f92672">!!</span> <span style="color:#ae81ff">1</span>;
            @tree[$index] <span style="color:#f92672">=</span> $switch ?? (<span style="color:#f92672">^</span><span style="color:#ae81ff">10</span>)<span style="color:#f92672">.</span>pick <span style="color:#f92672">!!</span> Nil;
        }
    }
    <span style="color:#66d9ef">return</span> @tree;
}
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">get_rank</span> ($n) {
<span style="color:#75715e">## determines the rank of a node from its index</span>
    <span style="color:#66d9ef">return</span> $n <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> ?? (log($n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">/</span>log(<span style="color:#ae81ff">2</span>))<span style="color:#f92672">.</span>Int <span style="color:#f92672">!!</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>And this is the main code calling these subroutines:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">MAIN</span> ($depth = 3) {

    <span style="color:#66d9ef">my</span> @tree <span style="color:#f92672">=</span> generate_tree($depth);

    <span style="color:#66d9ef">my</span> $tstr <span style="color:#f92672">=</span> @tree<span style="color:#f92672">.</span>map({$_<span style="color:#f92672">.</span>defined ?? $_ <span style="color:#f92672">!!</span> <span style="color:#e6db74">&#34;undef&#34;</span>})<span style="color:#f92672">.</span>join(<span style="color:#e6db74">&#39;, &#39;</span>);
    <span style="color:#66d9ef">my</span> $target <span style="color:#f92672">=</span> (($depth<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">4.5</span>)<span style="color:#f92672">.</span>Int;

    say <span style="color:#e6db74">qq:to/__END__/;
</span><span style="color:#e6db74">    tree:</span>   $tstr
    target: $target
    paths found:
    <span style="color:#75715e">__END__
</span><span style="color:#75715e">
</span><span style="color:#75715e">    my $index = 0;
</span><span style="color:#75715e">    my @working;
</span><span style="color:#75715e">    my @paths;
</span><span style="color:#75715e">    sum_path(@tree, $target, $index, @working, @paths);
</span><span style="color:#75715e">
</span><span style="color:#75715e">    say &#34;\nsolutions:\n&#34;;
</span><span style="color:#75715e">    @paths.elems == 0 ?? say &#39;(none)&#39; !! ($_.join(&#39; -&gt; &#39;).say for @paths);
</span><span style="color:#75715e">}
</span></code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-056/javier-luque/raku/ch-2.p6">Javier Luque</a> wrote a recursive <code>BTree::Node</code> class to implement the basic data structure:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl">class BTree::Node {
    has Int $<span style="color:#960050;background-color:#1e0010">.</span>value is rw;
    has BTree::Node $<span style="color:#960050;background-color:#1e0010">.</span>left is rw;
    has BTree::Node $<span style="color:#960050;background-color:#1e0010">.</span>right is rw;
}
</code></pre></div><p>The hard work (tree traversal and computing the path sum) is done in the recursive <code>path-sum</code> subroutine:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">path</span>-sum(BTree::Node $node, Int $k, Int $total is copy, Str $path_string is copy) {
    $total <span style="color:#f92672">+=</span> $node<span style="color:#f92672">.</span>value;
    $path_string <span style="color:#f92672">~=</span> $node<span style="color:#f92672">.</span>value;

    <span style="color:#75715e"># Branch left</span>
    path<span style="color:#f92672">-</span>sum( $node<span style="color:#f92672">.</span>left,
              $k,
              $total,
              $path_string <span style="color:#f92672">~</span> <span style="color:#e6db74">&#39; → &#39;</span> )
    <span style="color:#66d9ef">if</span> ($node<span style="color:#f92672">.</span>left);

    <span style="color:#75715e"># Branch right</span>
    path<span style="color:#f92672">-</span>sum($node<span style="color:#f92672">.</span>right,
             $k,
             $total,
             $path_string <span style="color:#f92672">~</span> <span style="color:#e6db74">&#39; → &#39;</span> )
        <span style="color:#66d9ef">if</span> ($node<span style="color:#f92672">.</span>right);

    <span style="color:#75715e"># Calculate total if we can&#39;t branch</span>
    <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span>$node<span style="color:#f92672">.</span>left <span style="color:#f92672">&amp;&amp;</span>
         <span style="color:#f92672">!</span>$node<span style="color:#f92672">.</span>right <span style="color:#f92672">&amp;&amp;</span>
         $total <span style="color:#f92672">==</span> $k ) {
        say $path_string;
    }
}
</code></pre></div><p>Otherwise, the construction of the binary tree is hard-coded in the main code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">my</span> $root <span style="color:#f92672">=</span>
    BTree::Node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(
        value <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">5</span>,
        left <span style="color:#f92672">=&gt;</span> BTree::Node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(
            	value <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">4</span>,
            	left <span style="color:#f92672">=&gt;</span> BTree::Node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(
            		value <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">11</span>,
            		left <span style="color:#f92672">=&gt;</span> BTree::Node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(
            			value <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">7</span>
            		),
            		right <span style="color:#f92672">=&gt;</span> BTree::Node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(
            			value <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">2</span>,
            		)
            	)
            ),
        right <span style="color:#f92672">=&gt;</span> BTree::Node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(
            value <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">8</span>,
            left <span style="color:#f92672">=&gt;</span> BTree::Node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(
            	value <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">13</span>
            ),
            right <span style="color:#f92672">=&gt;</span> BTree::Node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(
            	value <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">9</span>,
            	right <span style="color:#f92672">=&gt;</span> BTree::Node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(
            		value <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">1</span>,
            	)
            )
        )
    );

<span style="color:#66d9ef">my</span> $k <span style="color:#f92672">=</span> <span style="color:#ae81ff">22</span>;
path<span style="color:#f92672">-</span>sum($root, $k, <span style="color:#ae81ff">0</span>, <span style="color:#e6db74">&#39;&#39;</span>);
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-056/mark-anderson/raku/ch-2.p6">Mark Anderson</a> also used object-oriented programming for the tree data structure:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6">class node {
    has UInt  $<span style="color:#960050;background-color:#1e0010">.</span>value;
    has Array $<span style="color:#960050;background-color:#1e0010">.</span>parents  is rw;
    has node  $<span style="color:#960050;background-color:#1e0010">.</span>left     is rw;
    has node  $<span style="color:#960050;background-color:#1e0010">.</span>right    is rw;
}
</code></pre></div><p>The bulk of the work is done in the <code>traverse</code> subroutine:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">traverse</span>($node) {
    <span style="color:#66d9ef">my</span> @parents <span style="color:#f92672">=</span> [$node<span style="color:#f92672">.</span>value, <span style="color:#f92672">|</span>$node<span style="color:#f92672">.</span>parents];
    <span style="color:#66d9ef">if</span> $node<span style="color:#f92672">.</span>left {
        $node<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>parents <span style="color:#f92672">=</span> @parents;
        traverse($node<span style="color:#f92672">.</span>left);
    }
    <span style="color:#66d9ef">if</span> $node<span style="color:#f92672">.</span>right {
        $node<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>parents <span style="color:#f92672">=</span> @parents;
        traverse($node<span style="color:#f92672">.</span>right);
    }
    <span style="color:#66d9ef">unless</span> $node<span style="color:#f92672">.</span>left <span style="color:#f92672">or</span> $node<span style="color:#f92672">.</span>right {
        say @parents<span style="color:#f92672">.</span>reverse<span style="color:#f92672">.</span>join(<span style="color:#e6db74">&#34; -&gt; &#34;</span>) <span style="color:#f92672">~</span> <span style="color:#e6db74">&#34; == 22&#34;</span> <span style="color:#66d9ef">if</span> @parents<span style="color:#f92672">.</span>sum <span style="color:#f92672">==</span> <span style="color:#ae81ff">22</span>;
    }
}
</code></pre></div><p>The tree construction is hard-coded:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">my</span> $root <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(value <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">5</span>, parents <span style="color:#f92672">=&gt;</span> <span style="color:#f92672">[]</span>);

$root<span style="color:#f92672">.</span>left  <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(value <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">4</span>);
$root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(value <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">8</span>);

$root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(value <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">11</span>);

$root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left  <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(value <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">7</span>);
$root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(value <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">2</span>);

$root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left  <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(value <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">13</span>);
$root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(value <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">9</span>);

$root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(value <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">1</span>);

traverse($root);
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-056/mohammad-anwar/raku/ch-2.p6">Mohammad S. Anwar</a> used a nested hash of hashes of arrays to represent the binary tree:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">my</span> Hash<span style="color:#f92672">[]</span> $TREE <span style="color:#f92672">=</span> :{
    <span style="color:#ae81ff">5</span> <span style="color:#f92672">=&gt;</span> { <span style="color:#ae81ff">4</span> <span style="color:#f92672">=&gt;</span> { <span style="color:#ae81ff">11</span> <span style="color:#f92672">=&gt;</span> [<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">2</span>] },
           <span style="color:#ae81ff">8</span> <span style="color:#f92672">=&gt;</span> { <span style="color:#ae81ff">13</span> <span style="color:#f92672">=&gt;</span> <span style="color:#f92672">[]</span>,
                   <span style="color:#ae81ff">9</span> <span style="color:#f92672">=&gt;</span> [<span style="color:#ae81ff">1</span>],
                },
         },
};
</code></pre></div><p>and used nested <code>for</code> loops to walk through the path:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">find</span>-matched-paths(Hash[] $TREE, Int $SUM) {
    <span style="color:#66d9ef">my</span> $paths <span style="color:#f92672">=</span> <span style="color:#f92672">[]</span>;
    <span style="color:#66d9ef">for</span> $TREE<span style="color:#f92672">.</span>keys <span style="color:#f92672">-&gt;</span> $k {
        <span style="color:#66d9ef">my</span> $path <span style="color:#f92672">=</span> [ $k<span style="color:#f92672">.</span>Int ];
        <span style="color:#66d9ef">for</span> $TREE{$k}<span style="color:#f92672">.</span>keys <span style="color:#f92672">-&gt;</span> $i {
            <span style="color:#66d9ef">my</span> $_path <span style="color:#f92672">=</span> [ $k<span style="color:#f92672">.</span>Int, $i<span style="color:#f92672">.</span>Int ];
            <span style="color:#66d9ef">for</span> $TREE{$k}{$i}<span style="color:#f92672">.</span>keys <span style="color:#f92672">-&gt;</span> $j {
                $_path<span style="color:#f92672">.</span>push: $j<span style="color:#f92672">.</span>Int;
                <span style="color:#66d9ef">if</span> $TREE{$k}{$i}{$j}<span style="color:#f92672">.</span>elems <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> {
                    <span style="color:#66d9ef">for</span> $TREE{$k}{$i}{$j} <span style="color:#f92672">-&gt;</span> $e {
                        $_path<span style="color:#f92672">.</span>push: $e<span style="color:#f92672">.</span>Int;
                    }
                    $paths<span style="color:#f92672">.</span>push: $_path;
                }
                <span style="color:#66d9ef">else</span> {
                    $paths<span style="color:#f92672">.</span>push: [ @$_path ];
                }
            }
        }
    }
    <span style="color:#66d9ef">my</span> $matched<span style="color:#f92672">-</span>paths <span style="color:#f92672">=</span> <span style="color:#f92672">[]</span>;
    <span style="color:#66d9ef">for</span> @$paths <span style="color:#f92672">-&gt;</span> $path {
        $matched<span style="color:#f92672">-</span>paths<span style="color:#f92672">.</span>push: $path<span style="color:#f92672">.</span>join(<span style="color:#e6db74">&#34; -&gt; &#34;</span>) <span style="color:#66d9ef">if</span> $SUM <span style="color:#f92672">==</span> [<span style="color:#f92672">+</span>] $path;
    }
    <span style="color:#66d9ef">return</span> $matched<span style="color:#f92672">-</span>paths;
}
</code></pre></div><p>The only problem with this iterative approach is that the <code>find-matched-paths</code> subroutine is implicitly hard-coded for a maximum tree depth of four levels. With a deeper tree, it would be necessary to add new nested loops. In that sense, I believe that a recursive approach is more adapted to a depth-first tree traversal, although computer science tells us that a recursive program can always be turned into an iterative program, for example by adding an explicit call stack (see Ruben Westerberg&rsquo;s solution in my <a href="https://github.com/LaurentRosenfeld/Perl-6-Miscellaneous/blob/master/Challenges-in-Perl6/Tree-inversion.md">review of Raku solutions to PWC 57</a> for an example of that).</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-056/ryan-thompson/raku/ch-2.p6">Ryan Thompson</a> used an array of arrays to store the binary tree and obtained a remarkably concise program:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">my</span> @tree <span style="color:#f92672">=</span> [<span style="color:#ae81ff">6</span>, [<span style="color:#ae81ff">5</span>, [<span style="color:#ae81ff">2</span>], [<span style="color:#ae81ff">4</span>, [<span style="color:#ae81ff">15</span>]]], [<span style="color:#ae81ff">19</span>, [<span style="color:#ae81ff">4</span>, [<span style="color:#ae81ff">5</span>]], [<span style="color:#ae81ff">2</span>, [<span style="color:#ae81ff">12</span>]]], [<span style="color:#ae81ff">1</span>, [<span style="color:#ae81ff">16</span>, [<span style="color:#ae81ff">7</span>]]]];

path<span style="color:#f92672">-</span>sum(@tree,<span style="color:#ae81ff">30</span>)<span style="color:#f92672">.</span>say;

<span style="color:#75715e">#| Does a certain complete sum exist in the tree?</span>
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">path</span>-sum( @tree, $sum is copy, @path is copy = [] ) {
    <span style="color:#66d9ef">my</span> ($val, @kids) <span style="color:#f92672">=</span> @tree;
    @path<span style="color:#f92672">.</span>push: $val;
    $sum <span style="color:#f92672">-=</span> $val;

    <span style="color:#66d9ef">return</span> @path <span style="color:#66d9ef">if</span> $sum <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> <span style="color:#f92672">!</span>@kids;
    <span style="color:#66d9ef">return</span> Empty <span style="color:#66d9ef">if</span> $sum <span style="color:#f92672">&lt;</span>  <span style="color:#ae81ff">0</span>;

    <span style="color:#f92672">|</span>@kids<span style="color:#f92672">.</span>map: { path<span style="color:#f92672">-</span>sum($_, $sum, @path) };
}
</code></pre></div><p>Note that Ryan’s array of arrays is not the same as mine. My basic array has three items (value, left node, right node), where as Ryan’s basic array has two items: the node value and an array of references to the children). TIMTOWTDI.</p>
<hr>
<h2 id="see-also">SEE ALSO</h2>
<p>Six blog posts on the subject:</p>
<ul>
<li>
<p>Arne Sommer: <a href="https://raku-musings.com/diff-sum.html;">https://raku-musings.com/diff-sum.html;</a></p>
</li>
<li>
<p>Luca Ferraru: <a href="https://fluca1978.github.io/2020/04/14/PerlWeeklyChallenge56.html;">https://fluca1978.github.io/2020/04/14/PerlWeeklyChallenge56.html;</a></p>
</li>
<li>
<p>Shahed Nooshmand: <a href="https://rafraichisso.ir/2020/04/18/pwc-56;">https://rafraichisso.ir/2020/04/18/pwc-56;</a></p>
</li>
<li>
<p>Javier Luque: <a href="https://perlchallenges.wordpress.com/2020/04/13/perl-weekly-challenge-056/;">https://perlchallenges.wordpress.com/2020/04/13/perl-weekly-challenge-056/;</a></p>
</li>
<li>
<p>Mohammad S. Anwar: <a href="https://perlweeklychallenge.org/blog/weekly-challenge-056/;">https://perlweeklychallenge.org/blog/weekly-challenge-056/;</a></p>
</li>
<li>
<p>Ryan Thompson: <a href="https://ry.ca/2020/04/path-sum/">https://ry.ca/2020/04/path-sum/</a>.</p>
</li>
</ul>
<h2 id="wrapping-up">Wrapping up</h2>
<p>Please let me know if I forgot any of the challengers or if you think my explanation of your code misses something important (send me an e-mail or just raise an issue against this GitHub page).</p>
<p>If you want to participate to the Perl Weekly Challenge, please connect to <a href="https://perlweeklychallenge.org/">this site</a>.</p>

                </div>
            </div>
        </div>
    </div>
</section>


<!-- Call To Action Section Start -->
<section id="call-to-action">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2 class="title wow fadeInDown" data-wow-delay=".3s" data-wow-duration="500ms">SO WHAT DO YOU THINK ?</h2>
                    <p class="wow fadeInDown" data-wow-delay=".5s" data-wow-duration="500ms">If you have any suggestions or ideas then please do share with us.</p>
                    <a href="/contact" class="btn btn-default btn-contact wow fadeInDown" data-wow-delay=".7s" data-wow-duration="500ms">Contact with me</a>
                </div>
            </div>

        </div>
    </div>
</section>
<!-- Call To Action Section End -->



<!-- Footer Section Start -->
<footer id="footer">
    <div class="container">
        <div class="row content-justify-between">
            <div class="col-md-8 col-12 text-center text-lg-left text-md-left">
                <p class="copyright">Copyright:
                    <span>
                        2019 - 2025
                    </span> The Weekly Challenge. Theme Design and Developed by
                    <a href="http://www.Themefisher.com" rel="noreferrer" rel="noreferrer" target="_blank">Themefisher</a>.
                </p>
            </div>
            <div class="col-md-4 col-12">
                <!-- Social Media -->
                <ul class="social text-center text-md-right text-lg-right">
                    <li>
                        <a href="https://twitter.com/PerlWChallenge" class="twitter" rel="noreferrer" target="_blank" title="Follow us">
                            <i class="ion-social-twitter"></i>
                        </a>
                    </li>
                    <li>
                        <a href="/rss.xml" class="rss" target="_blank" title="RSS Feed">
                            <i class="ion-social-rss"></i>
                        </a>
                    </li>
                </ul>
            </div>
        </div>
    </div>
</footer>
<!-- footer section end -->

<!-- jquery -->
<script src="https://theweeklychallenge.org/plugins/jquery/jquery.min.js"></script>
<!-- Form Validation -->
<script src="https://theweeklychallenge.org/plugins/form-validation/jquery.form.min.js"></script>
<script src="https://theweeklychallenge.org/plugins/form-validation/jquery.validate.min.js"></script>
<!-- slick slider -->
<script src="https://theweeklychallenge.org/plugins/slick/slick.min.js"></script>
<!-- bootstrap js -->
<script src="https://theweeklychallenge.org/plugins/bootstrap/bootstrap.min.js"></script>
<!-- chart js -->
<script src="https://theweeklychallenge.org/plugins/chart/highstock.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/drilldown.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/data.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/chart.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/pwc-challenge.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/gc-challenge.js"></script>
<!-- wow js -->
<script src="https://theweeklychallenge.org/plugins/wow-js/wow.min.js"></script>
<!-- slider js -->
<script src="https://theweeklychallenge.org/plugins/slider/slider.js"></script>
<!-- Fancybox -->
<script src="https://theweeklychallenge.org/plugins/facncybox/jquery.fancybox.js"></script>
<!-- template main js -->

<script src="https://theweeklychallenge.org/js/script.min.js"></script>
<!-- google analitycs -->

<script async src="https://www.googletagmanager.com/gtag/js?id=G-CJTPYM9SB8"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-CJTPYM9SB8');
</script>
</body>

</html>

