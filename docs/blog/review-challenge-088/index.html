<!DOCTYPE html>
<html class="no-js" lang="en-us">
<head>
    <!-- Basic Page Needs -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:title"       content="Colin Crain › Perl Weekly Review #088"/>
    <meta property="og:type"        content="website"/>
    <meta property="og:url"         content="https://theweeklychallenge.org/blog/review-challenge-088/"/>
    <meta property="og:image"       content="https://theweeklychallenge.org/images/about/about.jpg"/>
    <meta property="og:description" content="Colin Crain › Perl Weekly Review #088"/>
    <meta name="twitter:card"       content="summary" />
    <meta name="twitter:image"      content="https://theweeklychallenge.org/images/about/about.jpg"/>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <meta name="description" content="Colin Crain › Perl Weekly Review #088">
    <meta name="author" content="The Weekly Challenge Team">
    <meta name="generator" content="Hugo 0.67.0-DEV" />

    <link rel="me" href="https://fosstodon.org/@manwar">
    <link rel="canonical" href="https://theweeklychallenge.org/blog/review-challenge-088/" />

    <!-- Mobile Specific Metas -->
    <meta name="format-detection" content="telephone=no">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Colin Crain › Perl Weekly Review #088</title>
    <link rel="icon" href="https://theweeklychallenge.org/images/favicon.ico">

    
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css"/>

    <!-- Twitter Bootstrs CSS -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/bootstrap/bootstrap.min.css">
    <!-- Ionicons Fonts Css -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/ionicons/ionicons.min.css">
    <!-- animate css -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/animate-css/animate.css">
    <!-- Hero area slider css-->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/slider/slider.css">
    <!-- slick slider -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/slick/slick.css">
    <!-- Fancybox -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/facncybox/jquery.fancybox.css">
    <!-- hover -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/hover/hover-min.css">
    <!-- Google fonts -->
    <link href='https://fonts.googleapis.com/css?family=Source Code Pro' rel='stylesheet'>
    <!-- template main css file -->
    
    <link rel="stylesheet" href="https://theweeklychallenge.org/css/style.min.css" integrity="" media="screen">
    <link rel="stylesheet" href="https://theweeklychallenge.org/css/main.css">

    <style>
        #goTopButton {
            display: none;          
            position: fixed;        
            bottom: 20px;           
            right: 30px;            
            z-index: 99;            
            border: none;           
            outline: none;          
            background-color: red;  
            color: white;           
            cursor: pointer;        
            padding: 15px;          
            border-radius: 10px;    
            font-size: 18px;        
        }

        #goTopButton:hover {
              background-color: #555;
        }
    </style>


</head>

<body>

<button onclick="goTop()" id="goTopButton" title="Go to top">Top</button>

<script>

    topButton = document.getElementById("goTopButton");

    
    window.onscroll = function() { scrollFunction() };

    function scrollFunction() {
        if (document.body.scrollTop > 40 || document.documentElement.scrollTop > 40) {
            topButton.style.display = "block";
        } else {
            topButton.style.display = "none";
        }
    }

    
    function goTop() {
        document.body.scrollTop = 0; 
        document.documentElement.scrollTop = 0; 
    }

</script>

<section class="top-bar animated-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-12">
                <nav class="navbar navbar-expand-lg navbar-light bg-light">
                    <a class="navbar-brand" href="https://theweeklychallenge.org/">
                        <img src="https://theweeklychallenge.org/images/logo.svg" alt="logo">
                    </a>
                    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navgation" aria-controls="navigation"
                        aria-expanded="false" aria-label="Toggle navigation">
                        <span class="navbar-toggler-icon"></span>
                    </button>

                    <div class="collapse navbar-collapse" id="navigation">
                        <ul class="navbar-nav ml-auto">
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/">Home</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/about">About</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/chart">Chart</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/champions">Champions</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/team">Team</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/challenges">Challenges</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/p5-reviews">Perl/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/p6-reviews">Raku/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/recaps">Recaps</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/blogs">Blogs</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/faq">FAQ</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/contact">Contact</a>
                            </li>
                            
                        </ul>
                    </div>
                </nav>
            </div>
        </div>
    </div>
</section>


<section class="global-page-header">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2>Colin Crain › Perl Weekly Review #088</h2>
                    <div class="portfolio-meta">
                        <span>Sunday, Dec 13, 2020</span>|
                        <span> Tags:
                            perl
                        </span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

<section class="single-post">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                
                <div style="text-align: center" class="post-img">
                    <img class="img-fluid" alt="" src="https://theweeklychallenge.org/images/blog/p5-review-challenge-088.jpg">
                </div>
                
                <div style="text-align: justify" class="post-content">
                    <p>( <em>&hellip;continues from <a href="/blog/review-challenge-087/">previous week</a>.</em> )</p>
<p>Welcome to the Perl review for <strong>Week 088</strong> of the Weekly Challenge! Here we will take the time to discuss the  submissions offered by the team, factor out the common methodologies that came up in those solutions, and highlight some of the unique approaches and unusual code created.</p>
<hr>
<h3 id="why-do-we-do-these-challenges">Why do we do these challenges?</h3>
<p>I suppose any answers to that would be as wide ranging and varied as the people who choose to join the team. One thing is clear: it&rsquo;s not a competition, and there are no judges, even if there is a &ldquo;prize&rdquo; of sorts. About that &ndash; I think of it more as an honorarium periodically awarded to acknowledge the efforts we make towards this strange goal. So there&rsquo;s no determination to find the <em>fastest</em>, or the <em>shortest</em>, or even, in some abstract way, the <em>best</em> way to go about things, although I&rsquo;m certain the individuals have their own aspirations and personal drives. As Perl is such a wonderfully expressive language, this provides quite a bit of fodder to the core idea of TMTOWTDI, producing a gamut of wonderfully varied techniques and solutions.</p>
<p>Even the tasks themselves are often open to a certain amount of discretionary interpretation. What we end up with is a situation where each participant is producing something in the manner they find the most interesting or satisfying. Some team members focus on carefully crafted complete applications that thoroughly vet input data and handle every use case they can think up. Others chose to apply themselves to the logic of the underlying puzzle and making it work in the most elegant way they can. Some eschew modules they would ordinarily reach for, others embrace them, bringing to light wheels perhaps invented years ago that happen to exactly solve the problem in front of them today.</p>
<p>I&rsquo;ve been considering this question for some time and have found one binding commonality between all of us solving these challenges each week, in that however we normally live our lives, the task in front of us more than likely has nothing to do with any of that . And I think this has great value. We all do what we do, out in the real world, and hopefully we do it well. The Weekly Challenge provides a opportunity to do something germane to that life yet distinctly different; if we only do the things we already know how to do we only do the same things over and over. This is where the &ldquo;challenge&rdquo; aspect comes into play.</p>
<p>So we can consider the Weekly Challenge as providing a problem space outside of our comfort zone, as far out from comfort as we wish to take things. From those reaches we can gather and learn things and bring what we want back into our lives. Personally, I think that&rsquo;s its greatest value of all.</p>
<hr>
<p>Every week there is an enormous global collective effort made by the team, analyzing and creatively coding the submissions, and that effort deserves credit due. And that&rsquo;s why I&rsquo;m here, to try and figure out how to do that.</p>
<p>Let&rsquo;s have a look and see what we can find.</p>
<hr>
<p><strong><big>For context</big></strong>  before we begin, you may wish to revisit either of the pages for the <a href="/blog/perl-weekly-challenge-088/"><strong>original tasks</strong></a> or the summary <a href="/blog/recap-challenge-088/"><strong>recap</strong></a> of the challenge. But don&rsquo;t worry, the challenges themselves will be briefly summarized, presented below as we progress from task by task. Oh, and one more thing before we get started:</p>
<h3 id="getting-in-touch-with-us">Getting in Touch with Us</h3>
<p><a href="mailto:pwc.perfectwave@gmail.com"><img src="/images/blog/Email.svg" height="50" width="50"> Email</a> › Please email me (Colin) with any feedback, notes, clarifications or whatnot about this review.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge"><img src="/images/blog/Github.svg" height="50" width="50"> GitHub</a> › Submit a pull request to us for any issues you may find with this page.</p>
<p><a href="https://twitter.com/perlwchallenge"><img src="/images/blog/Twitter.svg" height="50" width="50"> Twitter</a> › Join the discussion on Twitter!</p>
<p>I&rsquo;m always curious as to what the people think of these efforts. Everyone here at the PWC would like to hear any feedback you&rsquo;d like to give.</p>
<p><strong>So finally, without further ado&hellip;</strong></p>
<hr>
<h2 id="---nbsp--nbsp--nbsp---task-1pwc088task1-------nbsp--nbsp--nbsp------nbsp--nbsp--nbsp---task-2pwc088task2---nbsp--nbsp--nbsp------nbsp--nbsp--nbsp---blogspwc088blogs----nbsp--nbsp--nbsp---">•             <a href="#PWC088TASK1">Task 1</a>                 •             <a href="#PWC088TASK2">Task 2</a>             	•             <a href="#PWC088BLOGS">BLOGS</a>              	•</h2>
<hr>
<h1 id="PWC088TASK1">TASK 1</h1>
<h1 id="array-of-product">Array of Product</h1>
<p><em>Submitted by: Mohammad S Anwar</em></p>
<p>You are given an array of positive integers @N.</p>
<p>Write a script to return an array @M where $M[i] is the product of all elements of @N except the index $N[i].</p>
<h4 id="example-1">Example 1:</h4>
<p>Input:</p>
<pre><code>    @N = (5, 2, 1, 4, 3)
</code></pre><p>Output:</p>
<pre><code>    @M = (24, 60, 120, 30, 40)

    $M[0] = 2 x 1 x 4 x 3 = 24
    $M[1] = 5 x 1 x 4 x 3 = 60
    $M[2] = 5 x 2 x 4 x 3 = 120
    $M[3] = 5 x 2 x 1 x 3 = 30
    $M[4] = 5 x 2 x 1 x 4 = 40
</code></pre><h4 id="example-2">Example 2:</h4>
<p>Input:</p>
<pre><code>    @N = (2, 1, 4, 3)
</code></pre><p>Output:</p>
<pre><code>    @M = (12, 24, 6, 8)

    $M[0] = 1 x 4 x 3 = 12
    $M[1] = 2 x 4 x 3 = 24
    $M[2] = 2 x 1 x 3 = 6
    $M[3] = 2 x 1 x 4 = 8
</code></pre><h2 id="about-the-solutions">about the solutions</h2>
<p>There were 32 submissions for the first task this past week. The pack broke along two basic approaches, to either actively construct the product for each element, or to create an intermediary value and derive the subproducts from this through division. There were also a few renegades, out there on the hoary fringes, blazing new paths across the uncharted wilderness. We&rsquo;ll get to them.</p>
<p>The question of overflows came up several times. By my thinking, I figure that if you&rsquo;re riding so close to the edge that a single multiplication will send you over it then likely your whole approach needs a rework. Not necessarily, mind you, but generally one should have a pretty good idea of the range of one&rsquo;s data, and whether the number 6x10^53 is liable to show up in a list of single-digit values. On the other hand if you were writing a general command line utility this case would need to be gracefully handled. So it really depends on how you choose to interpret the goal of the task. Me, I generally focus on the puzzle and the underlying logic more than constructing a robust app. Obviously others here have different priorities, which is as it should be. For a more thorough examination of this idea look down to the end where Abigail and Flavio address it.</p>
<h2 id="additive-or-subtractive">ADDITIVE or SUBTRACTIVE?</h2>
<p>In sculpture, there is a basic dichotomy in method that generally holds: either to <em>add</em> stuff, like blobs of clay, to your creation until it looks like what you want, or to <em>remove</em> stuff, like marble chips, until you only want what&rsquo;s left. Michelangelo famously once stated:</p>
<blockquote>
<p>“The sculpture is already complete within the marble block, before I start my work. It is already there, I just have to chisel away the superfluous material.”</p>
</blockquote>
<p>These particular terms, &ldquo;additive&rdquo; and &ldquo;subtractive&rdquo;, are perhaps a little confusing to apply to the task at hand, not least because we aren&rsquo;t using addition but rather multiplication for our results. However the primal forms of the two strategies remain, and we can witness them here in this creative work as well. Either people actively <em>constructed</em> the product at each index from the values specified, or alternately the total product of <em>all</em> values was first obtained, and then the final products would be&hellip; <em>destructed?</em> from the larger by dividing out each individual element in turn. Yes, at some point each element is first mulitiplied into the total and later divided out again, but on the other hand the total product of the array need only be calculated once.</p>
<h2 id="construct-a-new-array-correctly-formed">CONSTRUCT a new array correctly formed</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/adam-russell/perl/ch-1.pl"><strong>Adam Russell</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/cheok-yin-fung/perl/ch-1.pl"><strong>Cheok-Yin Fung</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/cristian-heredia/perl/ch-1.pl"><strong>Cristina Heredia</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/dave-jacoby/perl/ch-1.pl"><strong>Dave Jacoby</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/duane-powell/perl/ch-1.pl"><strong>Duane Powell</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/e-choroba/perl/ch-1.pl"><strong>E. Choroba</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/juliodcs/perl/ch-1.pl"><strong>Julio de Castro</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/miguel-prz/perl/ch-1.pl"><strong>Miguel Prz</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/nunovieira220/perl/ch-1.pl"><strong>Nuno Vieira</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/samir-parikh/perl/ch-1.pl"><strong>Samir Parikh</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/walt-mankowski/perl/ch-1.pl"><strong>Walt Mankowski</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/wanderdoc/perl/ch-1.pl"><strong>Wanderdoc</strong></a></p>
<p>In the constructive paradigm, at each element of the input array a list of all the elements, save that one, is created and the product taken. Or each element of the is multiplied, but the target value is skipped over and excluded at the last minute. Either way, there proved to be a few ways to implement it, with the net result being the same.</p>
<p>Let&rsquo;s start with an example:</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/duane-powell/perl/ch-1.pl"><strong>Duane Powell</strong></a></p>
<p>Duane lays out this method quite clearly. In the first loop we go through the input array and construct a sequence of arrays, each with one element spliced out, corresponding to successive indices in the input. In the followup, this list of array references is iterated over and the product of the subarrays are calculated.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">foreach</span> ( @N ) {
    <span style="color:#66d9ef">my</span> @temp <span style="color:#f92672">=</span> @N;
    splice @temp, $i, <span style="color:#ae81ff">1</span>;
    push @M, <span style="color:#f92672">\</span>@temp;
    $i<span style="color:#f92672">++</span>;
}

<span style="color:#66d9ef">my</span> @total;
<span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $array_ref ( @M ) {
    <span style="color:#66d9ef">my</span> $total <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    $total <span style="color:#f92672">*=</span> $_ <span style="color:#66d9ef">foreach</span> (@{$array_ref});
    push @total, $total;
}
</code></pre></div><p>Another way to construct the sublist of required elements for each calculation is to create a complex array slice.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/adam-russell/perl/ch-1.pl"><strong>Adam Russell</strong></a></p>
<p>demonstrates the form below. The array slice neatly selects the parts of the source array before and after each given element, which is then handed over to a subroutine to compute the product.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">list_product</span>{
        <span style="color:#66d9ef">my</span> @numbers <span style="color:#f92672">=</span> @_;
        <span style="color:#66d9ef">my</span> $product <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        map {$product <span style="color:#f92672">*=</span> $_ } @numbers;
        <span style="color:#66d9ef">return</span> $product;
    }


    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i (<span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> (@N <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)){
        <span style="color:#66d9ef">my</span> @numbers <span style="color:#f92672">=</span> @N[<span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, $i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> (@N <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)];
        push @M, list_product(@numbers);
    }
</code></pre></div><p>A third way is to exclude individual indices from the product-taking.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/dave-jacoby/perl/ch-1.pl"><strong>Dave Jacoby</strong></a></p>
<p>shows us his method. Here Dave uses <code>grep</code> to filter the indices of the input array, then using <code>map</code> to convert the values into those of the array rather than the indices. Borrowing <code>product</code> from <code>List::Util</code> allows him to neatly preform the required calculation.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">array_of_products</span>( $arrayref ) {
        <span style="color:#66d9ef">my</span> $end <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> scalar $arrayref<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>
        my @output;
        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i ( <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $end ) {
            push @output,
                product map { $arrayref<span style="color:#f92672">-&gt;</span>[$_] } grep { $_ <span style="color:#f92672">!=</span> $i } <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $end;
        }
        <span style="color:#66d9ef">return</span> @output;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/wanderdoc/perl/ch-1.pl"><strong>Wanderdoc</strong></a></p>
<p>does nearly the same thing with an air of beautiful simplicity, using <code>reduce</code> instead of <code>product</code>, also taken from <code>List::Util</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">aop</span>
    {
         <span style="color:#66d9ef">my</span> @arr <span style="color:#f92672">=</span> @_;
         <span style="color:#66d9ef">my</span> @aop <span style="color:#f92672">=</span> map { <span style="color:#66d9ef">my</span> $n <span style="color:#f92672">=</span> $_;
                        reduce { $a <span style="color:#f92672">*</span> $b } @arr[grep { $_ <span style="color:#f92672">!=</span> $n } <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $#arr] }
                   <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $#arr;
         <span style="color:#66d9ef">return</span> @aop;
    }
</code></pre></div><p>I really like this layout for complex <code>map</code> functions. I find it the most readable formatting by far and encourage it&rsquo;s adoption.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/juliodcs/perl/ch-1.pl"><strong>Julio de Castro</strong></a></p>
<p>Julio also gives us a complex mapping function, and I&rsquo;m going to take a small liberty in formatting it along the same lines for clarity:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">array_of_product</span>(@n) {
        [
            map {
                @{$_} <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> ? <span style="color:#ae81ff">0</span> : reduce { $a <span style="color:#f92672">*</span> $b } @{$_}
            }
            map {
                <span style="color:#66d9ef">my</span> $idx <span style="color:#f92672">=</span> $_;
                [ map { $n[$_] } grep { $idx <span style="color:#f92672">!=</span> $_ } <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> @n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> ]
            }
            <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> @n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
        ]
    }
</code></pre></div><p>So, reading from the bottom up, in this multiple mapping function each index is first mapped to an array of every index in the input save that one. This list is then passed to a second mapping where it is reduced by multiplication. A special case is introduced for when the list length is is 0, to yield a 0 result. I&rsquo;m not convivced the challenge has any meaning when given an empty list (I&rsquo;m leaning toward NaN), but sure, why not? Just make sure to define it in the docs&hellip; What wew end up with is a very robust functional solution.</p>
<p>In a similar manner we can focus on the elements we wish to <em>exclude</em> and <code>next</code> right over them in the product calculation.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/miguel-prz/perl/ch-1.pl"><strong>Miguel Prz</strong></a></p>
<p>demonstrates this approach:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">array_of_product</span> {
        <span style="color:#66d9ef">my</span> @result;
        <span style="color:#66d9ef">for</span>( <span style="color:#66d9ef">my</span> $i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; $i<span style="color:#f92672">&lt;</span>@_; $i<span style="color:#f92672">++</span> ) {
            <span style="color:#66d9ef">my</span> $product <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
            <span style="color:#66d9ef">for</span>( <span style="color:#66d9ef">my</span> $j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; $j<span style="color:#f92672">&lt;</span>@_; $j<span style="color:#f92672">++</span> ) {
                <span style="color:#66d9ef">next</span> <span style="color:#66d9ef">if</span> $i <span style="color:#f92672">==</span> $j;
                $product <span style="color:#f92672">*=</span> $_[$j];
            }
            push @result, $product;
        }
        <span style="color:#66d9ef">return</span> @result;
    }
</code></pre></div><p>Finally,</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/e-choroba/perl/ch-1.pl"><strong>E. Choroba</strong></a></p>
<p>avoids the issue of <em>excluding</em> individual values from the product-taking completely. Instead he uses a <code>local</code> copy to set individual values to 1 before applying the <code>product</code> function from <code>List::Util</code> we saw earlier. Sneaky! I like it.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">array_of_product</span> {
        <span style="color:#66d9ef">my</span> (@n) <span style="color:#f92672">=</span> @_;
        <span style="color:#66d9ef">return</span> [map { local $n[$_] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; product(@n) } <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $#n]
    }
</code></pre></div><h2 id="divide-out-the-individual-elements">DIVIDE OUT the individual elements</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/alexander-pankoff/perl/ch-1.pl"><strong>Alexander Pankoff</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/arne-sommer/perl/ch-1.pl"><strong>Arne Sommer</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/athanasius/perl/ch-1.pl"><strong>Athanasius</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/colin-crain/perl/ch-1.pl"><strong>Colin Crain</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/duncan-c-white/perl/ch-1.pl"><strong>Duncan C. White</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/jaldhar-h-vyas/perl/ch-1.pl"><strong>Jaldhar H. Vyas</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/james-smith/perl/ch-1.pl"><strong>James Smith</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/jo-37/perl/ch-1.pl"><strong>Jorg Sommrey</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/laurent-rosenfeld/perl/ch-1.pl"><strong>Laurent Rosenfeld</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/lubos-kolouch/perl/ch-1.pl"><strong>Lubos Kolouch</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/jeongoon/perl/ch-1.pl"><strong>Myoungjin Jeon</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/perlboy1967/perl/ch-1.pl"><strong>Niels van Dijke</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/pete-houston/perl/ch-1.pl"><strong>Pete Houston</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/roger-bell-west/perl/ch-1.pl"><strong>Roger Bell_West</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/sgreen/perl/ch-1.pl"><strong>Simon Green</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/hstejas/perl/ch-1.pl"><strong>Tejas</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/ulrich-rieke/perl/ch-1.pl"><strong>Ulrich Rieke</strong></a></p>
<p>In the divisive paradigm (yea, I&rsquo;m just kind of making up words here, don&rsquo;t make too much of it), the product it taken for every every element in the input list, and then at each element this total is divided out again by the value, to produce the subproduct we are looking for. This approach requires us to first multiply and later divide out each element from the total, but this is balanced by the fact we need only multiply the complete list once.</p>
<p>Because the steps are so straightforward, there wasn&rsquo;t a tremendous amount of variety in this very popular choice of proceeding. There were variations in the control structures to do the looping, and the particular method of producing the product, but the core idea of dividing out individual elelments from a grand total remained consistent throughout.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/pete-houston/perl/ch-1.pl"><strong>Pete Houston</strong></a></p>
<p>will start us off with a neat pure Perl rendition:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span> $prod <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    $prod <span style="color:#f92672">*=</span> $_ <span style="color:#66d9ef">for</span> @in;

    <span style="color:#66d9ef">my</span> @out;
    push @out, $prod<span style="color:#f92672">/</span>$_ <span style="color:#66d9ef">for</span> @in;
</code></pre></div><p>That&rsquo;s really all there is to it.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/ulrich-rieke/perl/ch-1.pl"><strong>Ulrich Rieke</strong></a></p>
<p>here uses an explicit <code>for</code> loop to get the job done, after borrowing <code>product</code> from <code>List::Util</code> to reduce the list.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">use</span> List::Util <span style="color:#e6db74">qw( product )</span> ;

    <span style="color:#66d9ef">my</span> $product <span style="color:#f92672">=</span> product @array ;
    <span style="color:#66d9ef">my</span> $len <span style="color:#f92672">=</span> scalar @array ;
    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i ( <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $len <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> ) {
        push @M , $product <span style="color:#f92672">/</span> $array[ $i ] ;
    }
</code></pre></div><p>Alternately,</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/hstejas/perl/ch-1.pl"><strong>Tejas</strong></a></p>
<p>gives us a C-style <code>for</code> loop for the main iteration, but uses <code>map</code> in void context to create their product.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    map { $product <span style="color:#f92672">*=</span> $_ } @{$n};

    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">my</span> $idx <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; $idx <span style="color:#f92672">&lt;</span> scalar @{$n}; $idx<span style="color:#f92672">++</span>) {
        push @m, $product <span style="color:#f92672">/</span> $n<span style="color:#f92672">-&gt;</span>[$idx];
    }
</code></pre></div><p>And</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/athanasius/perl/ch-1.pl"><strong>Athanasius</strong></a></p>
<p>has opted for using the more generic <code>reduce</code> with a multiplication function to create the initial product.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span>   $product <span style="color:#f92672">=</span> reduce { $a <span style="color:#f92672">*</span> $b } @N;                     <span style="color:#75715e"># List reduction</span>
    <span style="color:#66d9ef">my</span>   @M;
    push @M, $product <span style="color:#f92672">/</span> $N[$_] <span style="color:#66d9ef">for</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $#N;
</code></pre></div><p>Working on lists of data to output transformed versions of those lists naturally lends itself to functional paradigms, as in the <code>reduce</code> function above, where we apply a basic multiplication to the list as a data structure rather than a composite of parts. This in turn led to the widespread use of <code>map</code> to act on the list rather than crafting a more traditional loop. With the use of <code>map</code>, though, the already concise code becomes even more compact.</p>
<p>As the self-similarity between solutions is quite evident, I&rsquo;ll open the discussion with</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/colin-crain/perl/ch-1.pl"><strong>My Own Solution</strong></a></p>
<p>It&rsquo;s pretty simple, really.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span> $product <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    $product <span style="color:#f92672">*=</span> $_ <span style="color:#66d9ef">for</span> @input;

    <span style="color:#66d9ef">my</span> @output <span style="color:#f92672">=</span> map { $product <span style="color:#f92672">/</span> $_ } @input;
</code></pre></div><p>If we add <code>product</code> from <code>List::Util</code> things get even simpler, and faster as that&rsquo;s interfaced to compiled C code.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/alexander-pankoff/perl/ch-1.pl"><strong>Alexander Pankoff</strong></a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span> $total <span style="color:#f92672">=</span> product(@arr);
    <span style="color:#66d9ef">my</span> @out <span style="color:#f92672">=</span> map { $total <span style="color:#f92672">/</span> $_ } @arr;
</code></pre></div><p>Does it get any more compact than that? Not really.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/jo-37/perl/ch-1.pl"><strong>Jorg Sommrey</strong></a></p>
<p>seems to have eliminated a few characters, while adding a bogus data clause. It&rsquo;s not always necessary to pass a proper block to <code>map</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">prod_arr</span> {
        <span style="color:#66d9ef">my</span> $prod <span style="color:#f92672">=</span> product @_;
        die <span style="color:#e6db74">&#34;invalid data&#34;</span> <span style="color:#66d9ef">unless</span> $prod;

        map $prod <span style="color:#f92672">/</span> $_, @_
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/arne-sommer/perl/ch-1.pl"><strong>Arne Sommer</strong></a></p>
<p>went with <code>reduce</code>, instead of <code>product</code>, to the same effect:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span> $product <span style="color:#f92672">=</span> reduce { $a <span style="color:#f92672">*</span> $b } @N;

    <span style="color:#66d9ef">my</span> @M <span style="color:#f92672">=</span> map { $product <span style="color:#f92672">/</span> $_ } @N;
</code></pre></div><p>And</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/jeongoon/perl/ch-1.pl"><strong>Myoungjin Jeon</strong></a></p>
<p>wraps his <code>map</code> up directly into his output IO, like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span> $p <span style="color:#f92672">=</span> product @n;

    say <span style="color:#e6db74">&#34;[&#34;</span>,
        join( <span style="color:#e6db74">&#34;,&#34;</span>,
              map { $p <span style="color:#f92672">/</span> $_ } @n ),
        <span style="color:#e6db74">&#34;]&#34;</span>;
</code></pre></div><p>In a final note, we have a well-annotated submission from</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/sgreen/perl/ch-1.pl"><strong>Simon Green</strong></a></p>
<p>In addition to some basic input validation, Simon has chosen to include a special case for when @N only has one element, deciding this should return 0. Hmmm&hellip; Ok, he says&hellip; As with Julio, above, I&rsquo;m not convinced such a case can even be considered to be meaningful in the context of the challenge as given. I mean, if you have one element, what <em>is</em> the product of the list excluding that element, being the entirety of the list? I find contemplating the whole idea of calculating the product of «nothing» immediately leads me into deeply vague ontological territory. I&rsquo;ve written here before in a similar vein about leading zeros and placeholders for nothingness, but this takes that discussion to a whole new level. There&rsquo;s even a seemingly mystical resonance to this particular instance as well, much like the sound of one hand clapping. I don&rsquo;t think a solid answer is within the scope of this report, so, as I said before, make sure it makes it to the documentation.</p>
<p>In other remarks I must applaud his commenting. Code may well be self-explanatory, but it&rsquo;s hubris to <em>assume</em> it is, and a little guidance and consideration can go a long way in this world. So be like Simon. Simon&rsquo;s got it going on.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#75715e"># Special case if there is only one number</span>
    <span style="color:#66d9ef">if</span> ( scalar(@N) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> ) {
        say <span style="color:#e6db74">&#39;0&#39;</span>;
        <span style="color:#66d9ef">return</span>;
    }

    <span style="color:#75715e"># Calculate the product of all numbers</span>
    <span style="color:#66d9ef">my</span> $product <span style="color:#f92672">=</span> product(@N);

    <span style="color:#75715e"># The solution for each number is product divided by the number</span>
    say join <span style="color:#e6db74">&#39;, &#39;</span>, map { $product <span style="color:#f92672">/</span> $_ } @N;
</code></pre></div><h2 id="off-the-beaten-path-into-the-wilderness-onward">off the BEATEN PATH, into the WILDERNESS! ONWARD!</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/abigail/perl/ch-1.pl"><strong>Abigail</strong></a> and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/polettix/perl/ch-1.pl"><strong>Flavio Poletti</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/wlmb/perl/ch-1.pl"><strong>W. Luis Mochan</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/cheok-yin-fung/perl/ch-1.pl"><strong>Cheok-Yin Fung</strong></a></p>
<p>There were two submissions explicitly grappling with the idea of overflowing integers, coming to essentially the same unusual methodology.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/abigail/perl/ch-1.pl"><strong>Abigail</strong></a></p>
<p>Abigail has given us an interesting strategy to avoid possible overflows by calculating each successive instance of @M from the previous. First he calculates $M[0] from multiplying out the array slice following the first element, using <code>product</code> from <code>List::Util</code>. Then for the following value, he takes this product, divides out $N[$i] (which will compose part of it), then multiplies back in $N[$i-1], the part previously left out. Each successive value is then calculated from the previous in this manner. The active principle here being to never exceed the maximum value contained in the result @M at any intermediate point within the calculation.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">&lt;&gt;</span>) {
        <span style="color:#75715e"># Read in a line of data.</span>
        <span style="color:#66d9ef">my</span> @N <span style="color:#f92672">=</span> <span style="color:#e6db74">/[1-9][0-9]*/g</span>;
        <span style="color:#75715e"># Calculate M [0], and print it.</span>
        printf <span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#66d9ef">my</span> $P <span style="color:#f92672">=</span> product @N [<span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> $#N];
        <span style="color:#75715e"># For each i &gt; 0, calculate M [i] from M [i - 1], N [i] and N [i - 1],</span>
        <span style="color:#75715e"># and print it.</span>
        printf <span style="color:#e6db74">&#34;, %d&#34;</span>, $P <span style="color:#f92672">=</span> $P <span style="color:#f92672">/</span> $N [$_] <span style="color:#f92672">*</span> $N [$_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#66d9ef">for</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> $#N;
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;\n&#34;</span>;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/polettix/perl/ch-1.pl"><strong>Flavio Poletti</strong></a></p>
<p>Flavio has, alternately, given us three solutions, running the full gamut of approaches. These are two submissions expressing both of the archetypical additive and subtractive solutions, with their faults noted, as well as an overflow protective method that closely aligns with Abigail&rsquo;s. I have to say combining the mathematical efficiency of the divisive solution while avoiding the overhead required makes a convincing case for the method.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">array_of_product</span> (@N) {
       <span style="color:#66d9ef">my</span> $p <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
       $p <span style="color:#f92672">*=</span> $_ <span style="color:#66d9ef">for</span> @N[<span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $#N <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
       <span style="color:#66d9ef">return</span> map {$p <span style="color:#f92672">=</span> $N[$_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> ($p <span style="color:#f92672">/</span> $N[$_]) } <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $#N;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/cheok-yin-fung/perl/ch-1.pl"><strong>Cheok-Yin Fung</strong></a></p>
<p>CY has given us a unique version of a filtered constructive solution, in the form of one-liner:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">perl -e <span style="color:#e6db74">&#39;for $j (0..scalar @ARGV-1) {$a = 1; eval {$a *= $ARGV[$_] if $_ != $j} for (0..scalar @ARGV-1); print &#34;$a &#34;; }&#39;</span> <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">4</span> <span style="color:#ae81ff">3</span>
</code></pre></div><p>It&rsquo;s nice. I like it.</p>
<p>And finally, someone has brought us a solution using the Perl Data Language!</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/wlmb/perl/ch-1.pl"><strong>W. Luis Mochan</strong></a></p>
<p>I&rsquo;m always excited when the enormous power of the PDL is brought to bear on our little tasks. Somewhat akin to putting advanced rocket fuels in a go-kart, or perhaps bringing a hand grenade to a knife-fight, the PDL appears to be able to make short work of arbitrarily complex problems in a seemingly effortless manner.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">array_of_products</span> {
        <span style="color:#66d9ef">use</span> PDL;                                        <span style="color:#75715e">#use the perl data language</span>
        <span style="color:#66d9ef">use</span> PDL::NiceSlice;
        <span style="color:#66d9ef">my</span> $input <span style="color:#f92672">=</span> pdl(@_);                            <span style="color:#75715e">#input piddle (PDL array)</span>
        <span style="color:#66d9ef">my</span> $matrix <span style="color:#f92672">=</span> $input(:,<span style="color:#f92672">*</span>$input<span style="color:#f92672">-&gt;</span>dim(<span style="color:#ae81ff">0</span>))<span style="color:#f92672">-&gt;</span>copy;   <span style="color:#75715e">#replicate row to produce a matrix</span>
        $matrix<span style="color:#f92672">-&gt;</span>diagonal(<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>) <span style="color:#f92672">.=</span> <span style="color:#ae81ff">1</span>;                    <span style="color:#75715e">#replace diagonal by 1&#39;s</span>
        <span style="color:#66d9ef">my</span> $output <span style="color:#f92672">=</span> $matrix<span style="color:#f92672">-&gt;</span>prodover;                 <span style="color:#75715e">#multiply elements row-wise</span>
        <span style="color:#66d9ef">return</span> $output<span style="color:#f92672">-&gt;</span>list;                           <span style="color:#75715e">#convert to perl list</span>
    }
</code></pre></div><p>I think interested parties should be able to follow the action quite nicely. Replacing the diagonal with 1s is an amazing piece of functionality that eliminates one value from the product of each row in a progressive manner, being exactly what we want. It&rsquo;s a beautiful thing to behold.</p>
<p>For a more detailed introduction to and description of advanced rocket fuels, poke around and locate a copy of  <em>Ignition! An Informal History of Liquid Rocket Propellants</em> by John D. Clark (Rutgers University Press, 1972), which contains many passages like the following tidbit:</p>
<blockquote>
<p>”It [chlorine trifloride, ClF<sub>3</sub>] is, of course, extremely toxic, but that’s the least of the problem. It is hypergolic with every known fuel, and so rapidly hypergolic that no ignition delay has ever been measured. It is also hypergolic with such things as cloth, wood, and test engineers, not to mention asbestos, sand, and water — with which it reacts explosively. It can be kept in some of the ordinary structural metals — steel, copper, aluminium, etc. — because of the formation of a thin film of insoluble metal fluoride which protects the bulk of the metal, just as the invisible coat of oxide on aluminium keeps it from burning up in the atmosphere. If, however, this coat is melted or scrubbed off, and has no chance to reform, the operator is confronted with the problem of coping with a metal-fluorine fire. For dealing with this situation, I have always recommended a good pair of running shoes.”</p>
</blockquote>
<hr>
<h1 id="PWC088TASK2">TASK 2</h1>
<h1 id="spiral-matrix">Spiral Matrix</h1>
<p><em>Submitted by: Mohammad S Anwar</em></p>
<p>You are given m x n matrix of positive integers.</p>
<p>Write a script to print spiral matrix as list.</p>
<h4 id="example-1-1">Example 1:</h4>
<pre><code>    Input:
        [ 1, 2, 3 ]
        [ 4, 5, 6 ]
        [ 7, 8, 9 ]
    Ouput:
        [ 1, 2, 3, 6, 9, 8, 7, 4, 5 ]
</code></pre><h5 id="example-2-1">Example 2:</h5>
<pre><code>    Input:
        [  1,  2,  3,  4 ]
        [  5,  6,  7,  8 ]
        [  9, 10, 11, 12 ]
        [ 13, 14, 15, 16 ]
    Output:
        [ 1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10 ]
</code></pre><h2 id="about-the-solutions-1">about the solutions</h2>
<p>There were 31 submissions for the second task this past week. With that many variations it&rsquo;s unfortunately not possible to review each and every one, but on examination some broader categories emerged.</p>
<p>The basic progression, as specified, was to read along the top, down the right side, reversed along the bottom and then up the left side to complete one looping of the spiral. At that point, once one complete ring was circumnavigated, the process could then be repeated on the inner matrix remaining. The cycling could be tracked to constrict by means of an offset to the edges, or a dummy parallel matrix identifying boundaries, or in some methods the cells were physically removed. In any case the process is repeated, either through a loop or recursion, until there are no more cells to be read.</p>
<h2 id="take-a-walk">take a WALK</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/dave-jacoby/perl/ch-2.pl"><strong>Dave Jacoby</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/e-choroba/perl/ch-2.pl"><strong>E. Choroba</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/lubos-kolouch/perl/ch-2.pl"><strong>Lubos Kolouch</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/miguel-prz/perl/ch-2.pl"><strong>Miguel Prz</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/perlboy1967/perl/ch-2.pl"><strong>Niels van Dijke</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/pete-houston/perl/ch-2.pl"><strong>Pete Houston</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/roger-bell-west/perl/ch-2.pl"><strong>Roger Bell_West</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/ulrich-rieke/perl/ch-2.pl"><strong>Ulrich Rieke</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/walt-mankowski/perl/ch-2.pl"><strong>Walt Mankowski</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/wanderdoc/perl/ch-2.pl"><strong>Wanderdoc</strong></a></p>
<p>Perhaps the most true to vision version of spiralling enacted by the group was to walk the matrix, so to speak: stepping one step forward and reading a value, turning right whenever we get to a border, closing in those borders as we turn corners and read cells. It&rsquo;s somewhat akin to a simple recursion: we don&rsquo;t necessarily need to know exactly where we are, we only need to know how to take the next step forward and when to stop. We start moving left-to-right across the first row, turn right at the end, and continue turning right at an edge or an already visited cell, stopping when we run out of cells. Think of it like a game of snake, if you will.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/miguel-prz/perl/ch-2.pl"><strong>Miguel Prz</strong></a></p>
<p>To keep track of border detection and visited cells, Miguel constructs an auxiliary matrix of 0s, bounded by a ring of 1s, filling in cells on this matrix with 1s as they are read on the original. Constructing this parallel matrix was a common method, as was the exit case of counting the steps to completion, evaluating against the computed cell count of (rows) × (columns).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    push $aux_matrix<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span>, [ (<span style="color:#ae81ff">1</span>) x ($size_x<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>)   ];
    push $aux_matrix<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span>, [ <span style="color:#ae81ff">1</span>, (<span style="color:#ae81ff">0</span>) x $size_x, <span style="color:#ae81ff">1</span> ] <span style="color:#66d9ef">for</span> ( <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> $size_y );
    push $aux_matrix<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span>, [ (<span style="color:#ae81ff">1</span>)  x ($size_x<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>)  ];

    <span style="color:#66d9ef">my</span> $direction <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">my</span> $visits <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">my</span> ($cx, $cx_1) <span style="color:#f92672">=</span> (<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>);
    <span style="color:#66d9ef">my</span> ($cy, $cy_1) <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>);

    <span style="color:#66d9ef">while</span>( $visits <span style="color:#f92672">&lt;</span> $nodes ) {

        $direction <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> $cx<span style="color:#f92672">++</span>;
        $direction <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> $cy<span style="color:#f92672">++</span>;
        $direction <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">&amp;&amp;</span> $cx<span style="color:#f92672">--</span>;
        $direction <span style="color:#f92672">==</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">&amp;&amp;</span> $cy<span style="color:#f92672">--</span>;

        <span style="color:#66d9ef">if</span>( $aux_matrix<span style="color:#f92672">-&gt;</span>[$cy][$cx] ) {
            $direction <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>$direction % 4;
            ($cx, $cy) <span style="color:#f92672">=</span> ($cx_1, $cy_1);
        }
        <span style="color:#66d9ef">else</span> {
            $aux_matrix<span style="color:#f92672">-&gt;</span>[$cy][$cx] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
            ($cx_1, $cy_1) <span style="color:#f92672">=</span> ($cx, $cy);
            push @result, $matrix[$cy<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][$cx<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
            $visits<span style="color:#f92672">++</span>;
        }
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/sgreen/perl/ch-2.pl"><strong>Simon Green</strong></a></p>
<p>Simon again has delivered a well-commented example, laying out the steps as he moves forward, spiraling in.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span> $rows <span style="color:#f92672">=</span> scalar(@array);
    <span style="color:#66d9ef">my</span> $cols <span style="color:#f92672">=</span> scalar( @{ $array[<span style="color:#ae81ff">0</span>] } );

    <span style="color:#75715e"># Right, down, left and up</span>
    <span style="color:#66d9ef">my</span> @directions <span style="color:#f92672">=</span> ( [ <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span> ], [ <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span> ], [ <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> ], [ <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span> ] );

    <span style="color:#75715e"># Map out the values we&#39;ve used</span>
    <span style="color:#66d9ef">my</span> @used <span style="color:#f92672">=</span> ( map { [ (<span style="color:#ae81ff">0</span>) x $cols ] } ( <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> $rows ) );

    <span style="color:#75715e"># We start at the top left, moving right</span>
    <span style="color:#66d9ef">my</span> $x         <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">my</span> $y         <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">my</span> $direction <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">my</span> @solutions <span style="color:#f92672">=</span> ();

    <span style="color:#75715e"># Loop until we&#39;ve found all the numbers</span>
    <span style="color:#66d9ef">while</span> ( scalar(@solutions) <span style="color:#f92672">&lt;</span> $rows <span style="color:#f92672">*</span> $cols ) {
        push @solutions, $array[$x][$y];
        $used[$x][$y] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;

        <span style="color:#66d9ef">my</span> $next_x <span style="color:#f92672">=</span> $x <span style="color:#f92672">+</span> $directions[$direction][<span style="color:#ae81ff">0</span>];
        <span style="color:#66d9ef">my</span> $next_y <span style="color:#f92672">=</span> $y <span style="color:#f92672">+</span> $directions[$direction][<span style="color:#ae81ff">1</span>];

        <span style="color:#75715e"># If we&#39;ve reached the bounds of our grid, or found a value</span>
        <span style="color:#75715e">#  we&#39;ve already used, we need to switch direction</span>
        <span style="color:#66d9ef">if</span> (   $next_x <span style="color:#f92672">==</span> $cols
            <span style="color:#f92672">or</span> $next_y <span style="color:#f92672">==</span> $rows
            <span style="color:#f92672">or</span> $next_x <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>
            <span style="color:#f92672">or</span> $next_y <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>
            <span style="color:#f92672">or</span> $used[$next_x][$next_y] )
        {
            $direction <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>$direction % 4;
            $next_x    <span style="color:#f92672">=</span> $x <span style="color:#f92672">+</span> $directions[$direction][<span style="color:#ae81ff">0</span>];
            $next_y    <span style="color:#f92672">=</span> $y <span style="color:#f92672">+</span> $directions[$direction][<span style="color:#ae81ff">1</span>];
        }

        $x <span style="color:#f92672">=</span> $next_x;
        $y <span style="color:#f92672">=</span> $next_y;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/roger-bell-west/perl/ch-2.pl"><strong>Roger Bell_West</strong></a></p>
<p>Roger does a fine job of condensing his movement into a tight set of steps.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span> @dir <span style="color:#f92672">=</span> (
        [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>],
        [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>],
        [<span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>],
        [<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>],
             );
    <span style="color:#66d9ef">my</span> ( $x, $y, $d ) <span style="color:#f92672">=</span> ( <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span> );
    <span style="color:#66d9ef">foreach</span> ( <span style="color:#ae81ff">2</span><span style="color:#f92672">..</span>$mx <span style="color:#f92672">*</span> $my ) {
        $v[$x][$y]<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">my</span> ( $nx, $ny );
        <span style="color:#66d9ef">while</span> ( <span style="color:#ae81ff">1</span> ) {
            ( $nx, $ny ) <span style="color:#f92672">=</span> ( $x <span style="color:#f92672">+</span> $dir[$d][<span style="color:#ae81ff">0</span>], $y <span style="color:#f92672">+</span> $dir[$d][<span style="color:#ae81ff">1</span>] );
            <span style="color:#66d9ef">if</span> ( $nx <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> $nx <span style="color:#f92672">&gt;=</span> $mx <span style="color:#f92672">||</span> $ny <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> $ny <span style="color:#f92672">&gt;=</span> $my <span style="color:#f92672">||</span> $v[$nx][$ny]<span style="color:#f92672">==</span><span style="color:#ae81ff">1</span> ) {
                $d<span style="color:#f92672">++</span>;
                $d%<span style="color:#960050;background-color:#1e0010">=</span>4;
            } <span style="color:#66d9ef">else</span> {
                <span style="color:#66d9ef">last</span>;
            }
        }
        ( $x, $y ) <span style="color:#f92672">=</span> ( $nx, $ny );
        push @o, $m<span style="color:#f92672">-&gt;</span>[$x][$y];
    }
</code></pre></div><p>As does</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/pete-houston/perl/ch-2.pl"><strong>Pete Houston</strong></a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span> @turns <span style="color:#f92672">=</span> ([<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>], [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>], [<span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], [<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>]);
    <span style="color:#66d9ef">my</span> @out;

    <span style="color:#75715e"># Start at top left, moving right</span>
    <span style="color:#66d9ef">my</span> ($r, $c) <span style="color:#f92672">=</span> ($rmin, $cmin);
    <span style="color:#66d9ef">my</span> $move <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

    <span style="color:#66d9ef">while</span> ($rmin <span style="color:#f92672">&lt;=</span> $rmax <span style="color:#f92672">&amp;&amp;</span> $cmin <span style="color:#f92672">&lt;=</span> $cmax) {
        push @out, $matrix<span style="color:#f92672">-&gt;</span>[$r][$c];
        <span style="color:#66d9ef">my</span> ($rnext, $cnext) <span style="color:#f92672">=</span> ($r <span style="color:#f92672">+</span> $turns[$move][<span style="color:#ae81ff">0</span>], $c <span style="color:#f92672">+</span> $turns[$move][<span style="color:#ae81ff">1</span>]);
        <span style="color:#66d9ef">if</span> ($rnext <span style="color:#f92672">&lt;</span> $rmin <span style="color:#f92672">||</span>
            $rnext <span style="color:#f92672">&gt;</span> $rmax <span style="color:#f92672">||</span>
            $cnext <span style="color:#f92672">&lt;</span> $cmin <span style="color:#f92672">||</span>
            $cnext <span style="color:#f92672">&gt;</span> $cmax) {
            <span style="color:#75715e"># Turn right</span>
            <span style="color:#66d9ef">if</span>    ($rnext <span style="color:#f92672">&lt;</span> $rmin) { $cmin<span style="color:#f92672">++</span>; }
            <span style="color:#66d9ef">elsif</span> ($rnext <span style="color:#f92672">&gt;</span> $rmax) { $cmax<span style="color:#f92672">--</span>; }
            <span style="color:#66d9ef">elsif</span> ($cnext <span style="color:#f92672">&gt;</span> $cmax) { $rmin<span style="color:#f92672">++</span>; }
            <span style="color:#66d9ef">else</span>                   { $rmax<span style="color:#f92672">--</span>; }
            $move <span style="color:#f92672">=</span> ($move <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) % 4;
            ($r, $c) <span style="color:#f92672">=</span> ($r <span style="color:#f92672">+</span> $turns[$move][<span style="color:#ae81ff">0</span>], $c <span style="color:#f92672">+</span> $turns[$move][<span style="color:#ae81ff">1</span>]);
        } <span style="color:#66d9ef">else</span> {
            ($r, $c) <span style="color:#f92672">=</span> ($rnext, $cnext);
        }
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/perlboy1967/perl/ch-2.pl"><strong>Niels van Dijke</strong></a></p>
<p>Niels avoids the complications of switching movement between row-wise and column-wise paths by converting his matrix into a hash reference data structure. By deleting keys once read, he can know when to change direction and when he has completed the read.</p>
<p>He takes an uncommon approach to changing directions as well, rather than ratcheting the index modulo 4 on a fixed array he continuously cycles through the directions to the next cell by shifting and pushing members of a common direction list, always reading the first element.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span> @dirVector <span style="color:#f92672">=</span> (
        [ <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>],
        [ <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>],
        [ <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>],
        [<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>]
     );

    LOOP:
    <span style="color:#66d9ef">while</span> ( <span style="color:#ae81ff">1</span> ) {
        push( @O, delete( $hrM<span style="color:#f92672">-&gt;</span>{ $r }{ $c } ) );

        <span style="color:#66d9ef">my</span> $rot <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">while</span> ( <span style="color:#f92672">!</span>exists(  $hrM<span style="color:#f92672">-&gt;</span>{ $r <span style="color:#f92672">+</span> $dirVector[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] }{ $c <span style="color:#f92672">+</span> $dirVector[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">1</span>] } )  ) {
            push( @dirVector, shift( @dirVector ) );
            $rot<span style="color:#f92672">++</span>;
            <span style="color:#66d9ef">last</span> LOOP <span style="color:#66d9ef">if</span> ( $rot <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span> );
        }

        $r <span style="color:#f92672">+=</span> $dirVector[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>];
        $c <span style="color:#f92672">+=</span> $dirVector[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">1</span>];
    }
</code></pre></div><h2 id="target-circle-and-close-in">TARGET, CIRCLE and CLOSE IN</h2>
<p>Because of the discreet, two-dimensional nature of a matrix, what we normally think of when we consider the continuous function of a spiral doesn&rsquo;t really map over very well. We can visualize the motion as moving along each face of the matrix in turn: top, right, bottom and left, and once finished in this circumnavigation we have something more resembling a circle than a spiral. Moving inward one square and repeating, the result is easily viewed as a group of discreet concentric rings rather than a continuous function.</p>
<h3 id="using-an-offset">using an OFFSET</h3>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/abigail/perl/ch-2.pl"><strong>Abigail</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/cheok-yin-fung/perl/ch-2.pl"><strong>Cheok-Yin Fung</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/colin-crain/perl/ch-2.pl"><strong>Colin Crain</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/duane-powell/perl/ch-2.pl"><strong>Duane Powell</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/polettix/perl/ch-2.pl"><strong>Flavio Poletti</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/jaldhar-h-vyas/perl/ch-2.pl"><strong>Jaldhar H. Vyas</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/jeongoon/perl/ch-2.pl"><strong>Myoungjin Jeon</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/hstejas/perl/ch-2.pl"><strong>Tejas</strong></a></p>
<p>The upshot of this modeling is that if we know how to scribe a ring, and keep track of the count as we move inwards, we can read all of the data in an orderly fashion.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/polettix/perl/ch-2.pl"><strong>Flavio Poletti</strong></a></p>
<p>Flavio has a triplet of functions to grab either a single row, a single column, or a &lsquo;frame&rsquo; — being an encircling set of cells, which in  turn uses the other two functions in successive reads. By incrementing  the start values by 1 and shrinking the total lengths by 2 at each encirclement, he keeps track of the offset until the unread matrix remaining is a single row or column, or vanishes completely.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">get_row</span> ($M, $r, $c, $n) { $M<span style="color:#f92672">-&gt;</span>[$r]<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">[$</span>c <span style="color:#f92672">..</span> $c <span style="color:#f92672">+</span> $n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] }
    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">get_col</span> ($M, $r, $c, $n) { map { $M<span style="color:#f92672">-&gt;</span>[$r <span style="color:#f92672">+</span> $_][$c] } <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> }
    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">get_frame</span> ($M, $r, $c, $nr, $nc) {
       ($nr, $nc) <span style="color:#f92672">=</span> ($nr <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, $nc <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>); <span style="color:#75715e"># more useful like this</span>
       <span style="color:#66d9ef">return</span> (
          get_row(        $M, $r      , $c      , $nc),
          get_col(        $M, $r      , $c <span style="color:#f92672">+</span> $nc, $nr),
          reverse(get_row($M, $r <span style="color:#f92672">+</span> $nr, $c <span style="color:#f92672">+</span>   <span style="color:#ae81ff">1</span>, $nc)),
          reverse(get_col($M, $r <span style="color:#f92672">+</span>   <span style="color:#ae81ff">1</span>, $c      , $nr)),
       );
    }

    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">spiral_matrix</span> ($M) {
       <span style="color:#66d9ef">my</span> ($rows, $cols) <span style="color:#f92672">=</span> (scalar($M<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span>), scalar($M<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span>));
       <span style="color:#66d9ef">my</span> ($sr, $sc) <span style="color:#f92672">=</span> (<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>);
       <span style="color:#66d9ef">my</span> @v;
       <span style="color:#66d9ef">while</span> ($rows <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> $cols <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
          <span style="color:#66d9ef">if</span> ($rows <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>)    { push @v, get_row($M, $sr, $sc, $cols) }
          <span style="color:#66d9ef">elsif</span> ($cols <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) { push @v, get_col($M, $sr, $sc, $rows) }
          <span style="color:#66d9ef">else</span> {               push @v, get_frame($M, $sr, $sc, $rows, $cols) }
          ($sr, $sc, $rows, $cols) <span style="color:#f92672">=</span> ($sr <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, $sc <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, $rows <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>, $cols <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>);
       }
       <span style="color:#66d9ef">return</span> @v;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/colin-crain/perl/ch-2.pl"><strong>My Own Solution</strong></a></p>
<p>For my own solution I march around the perimeter in ever tightening rings, keeping track of the offsets with a single <code>$rank</code> paremeter that gets incremented at every iteration. For those wondering, the unary negation on <code>-spiraling</code> turns the bareword into a number before the compiler can choke on it. It&rsquo;s a way to be more informative than <code>while (1) { ... }</code>, as whatever that number is, it won&rsquo;t be 0, and I think it reads well. I&rsquo;m open to input on whether this hack is good practice.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">spiralize</span> {
        <span style="color:#66d9ef">my</span> ($mat) <span style="color:#f92672">=</span> @_;
        <span style="color:#66d9ef">my</span> $cols  <span style="color:#f92672">=</span> $mat<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>
        my $rows  <span style="color:#f92672">=</span> $mat<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>
        my $rank  <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;           <span style="color:#75715e">## loop count of spiral, 0-based</span>
        <span style="color:#66d9ef">my</span> $out   <span style="color:#f92672">=</span> <span style="color:#f92672">[]</span>;

        <span style="color:#66d9ef">while</span> (<span style="color:#f92672">-</span>spiraling) {
            <span style="color:#75715e">## upper - left to right</span>
            <span style="color:#66d9ef">return</span> $out <span style="color:#66d9ef">if</span> $rank <span style="color:#f92672">&gt;</span> ceil( $rows <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
            push $out<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span>, $mat<span style="color:#f92672">-&gt;</span>[$rank]<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">[$</span>rank<span style="color:#f92672">..</span>$cols<span style="color:#f92672">-</span>$rank<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];

            <span style="color:#75715e">## right - top to bottom</span>
            <span style="color:#66d9ef">return</span> $out <span style="color:#66d9ef">if</span> $rank <span style="color:#f92672">&gt;</span> ceil( $cols <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
            <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $row ( $rank<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$rows<span style="color:#f92672">-</span>$rank<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span> ) {
                push $out<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span>, $mat<span style="color:#f92672">-&gt;</span>[$row][$cols<span style="color:#f92672">-</span>$rank<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
            }

            <span style="color:#75715e">## lower - right to left</span>
            <span style="color:#66d9ef">return</span> $out <span style="color:#66d9ef">if</span> $rank <span style="color:#f92672">&gt;</span> floor( $rows <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
            push $out<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span>, reverse $mat<span style="color:#f92672">-&gt;</span>[$rows<span style="color:#f92672">-</span>$rank<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">[$</span>rank<span style="color:#f92672">..</span>$cols<span style="color:#f92672">-</span>$rank<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] ;

            <span style="color:#75715e">## left - bottom to top</span>
            <span style="color:#66d9ef">return</span> $out <span style="color:#66d9ef">if</span> $rank <span style="color:#f92672">&gt;</span> floor( $cols <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
            <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $row ( reverse $rank<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$rows<span style="color:#f92672">-</span>$rank<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span> ) {
                push $out<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span>, $mat<span style="color:#f92672">-&gt;</span>[$row][$rank];
            }
            $rank<span style="color:#f92672">++</span>
        }
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/duane-powell/perl/ch-2.pl"><strong>Duane Powell</strong></a></p>
<p>Duane gives us a nicely commented solution, with a &lsquo;bounding box&rsquo; comprising four separate variables to constrict the rings.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">matrix_spiral</span> {
        <span style="color:#66d9ef">my</span> $matrix <span style="color:#f92672">=</span> shift;

        <span style="color:#75715e"># Spiral around the matrix by traversing: east, south, west and then north.</span>
        <span style="color:#75715e"># We will contract the bounding box when we turn north.</span>
            <span style="color:#75715e"># Determine dimensions of this matrix and its bounding box.</span>
        <span style="color:#66d9ef">my</span> ($a, $b, $c, $d) <span style="color:#f92672">=</span> (<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, scalar( @{$matrix} )<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, scalar( @{$matrix<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>]} )<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);

        <span style="color:#66d9ef">my</span> $out; <span style="color:#75715e"># printed output</span>
        <span style="color:#66d9ef">my</span> $element_max <span style="color:#f92672">=</span> ($c <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> ($d <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>); <span style="color:#75715e"># total possible element of the spiral</span>
        <span style="color:#66d9ef">my</span> $element_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

        <span style="color:#75715e"># (x,y) are the current element.</span>
        <span style="color:#75715e"># Start traversing from just outside the matrix at north-west corner (-1, d+1)</span>
        <span style="color:#66d9ef">my</span> ($x, $y) <span style="color:#f92672">=</span> (<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, $d<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
        LAST: <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>) {
            <span style="color:#75715e"># traverse east</span>
            ($x, $y) <span style="color:#f92672">=</span> ($x<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, $y<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>); <span style="color:#75715e"># (x,y) = (0,d) if this is the very first element</span>
            <span style="color:#66d9ef">while</span> ($x <span style="color:#f92672">&lt;=</span> $c) {
                $out <span style="color:#f92672">.=</span> $matrix<span style="color:#f92672">-&gt;</span>[$y][$x] <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34;,&#34;</span>;
                <span style="color:#66d9ef">last</span> LAST <span style="color:#66d9ef">if</span> (<span style="color:#f92672">++</span>$element_count <span style="color:#f92672">==</span> $element_max);
                $x<span style="color:#f92672">++</span>;
            }
            <span style="color:#75715e"># traverse south</span>
            ($x, $y) <span style="color:#f92672">=</span> ($c, $y<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
            <span style="color:#66d9ef">while</span> ($y <span style="color:#f92672">&gt;=</span> $b) {
                $out <span style="color:#f92672">.=</span> $matrix<span style="color:#f92672">-&gt;</span>[$y][$x] <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34;,&#34;</span>;
                <span style="color:#66d9ef">last</span> LAST <span style="color:#66d9ef">if</span> (<span style="color:#f92672">++</span>$element_count <span style="color:#f92672">==</span> $element_max);
                $y<span style="color:#f92672">--</span>;
            }
            <span style="color:#75715e"># traverse west</span>
            ($x, $y) <span style="color:#f92672">=</span> ($x<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, $y<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
            <span style="color:#66d9ef">while</span> ($x <span style="color:#f92672">&gt;=</span> $a) {
                $out <span style="color:#f92672">.=</span> $matrix<span style="color:#f92672">-&gt;</span>[$y][$x] <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34;,&#34;</span>;
                <span style="color:#66d9ef">last</span> LAST <span style="color:#66d9ef">if</span> (<span style="color:#f92672">++</span>$element_count <span style="color:#f92672">==</span> $element_max);
                $x<span style="color:#f92672">--</span>;
            }

            <span style="color:#75715e"># tighten the spiral&#39;s bounding box</span>
            $a<span style="color:#f92672">++</span>; $b<span style="color:#f92672">++</span>, $c<span style="color:#f92672">--</span>; $d<span style="color:#f92672">--</span>;

            <span style="color:#75715e"># traverse north</span>
            ($x, $y) <span style="color:#f92672">=</span> ($x<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, $y<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
            <span style="color:#66d9ef">while</span> ($y <span style="color:#f92672">&lt;=</span> $d) {
                $out <span style="color:#f92672">.=</span> $matrix<span style="color:#f92672">-&gt;</span>[$y][$x] <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34;,&#34;</span>;
                <span style="color:#66d9ef">last</span> LAST <span style="color:#66d9ef">if</span> (<span style="color:#f92672">++</span>$element_count <span style="color:#f92672">==</span> $element_max);
                $y<span style="color:#f92672">++</span>;
            }
        }
        $out <span style="color:#f92672">=</span> join(<span style="color:#e6db74">&#39;, &#39;</span>,split(<span style="color:#e6db74">/,/</span>,$out));
        say <span style="color:#e6db74">&#34;\t[$out]&#34;</span>;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/jaldhar-h-vyas/perl/ch-2.pl"><strong>Jaldhar H. Vyas</strong></a></p>
<p>Jaldhar similarly uses a set of top, right, bottom and left variables to establish his offsets.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">while</span> ($top <span style="color:#f92672">&lt;</span> scalar @matrix <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>) {
    <span style="color:#66d9ef">if</span> ($top <span style="color:#f92672">==</span> $bottom) {
        push @spiral, @{$matrix[$top]}[$left];
    } <span style="color:#66d9ef">else</span> {

        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i ($left <span style="color:#f92672">..</span> $right) {
            push @spiral, @{$matrix[$top]}[$i];
        }

        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i ($top <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> $bottom <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) {
            push @spiral, @{$matrix[$i]}[$right];
        }

        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i (reverse ($left <span style="color:#f92672">..</span> $right)) {
            push @spiral, @{$matrix[$bottom]}[$i];
        }

      <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i (reverse ($top <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> $bottom <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)) {
            push @spiral, @{$matrix[$i]}[$left];
        }
    }

    $top<span style="color:#f92672">++</span>;
    $right<span style="color:#f92672">--</span>;
    $bottom<span style="color:#f92672">--</span>;
    $left<span style="color:#f92672">++</span>;
}
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/cheok-yin-fung/perl/ch-2.pl"><strong>Cheok-Yin Fung</strong></a></p>
<p>CY gives us another circle and offset solution, but adds two interesting variations no one else thought to provide: in one she makes allowance to spiral in the anticlockwise direction, in the other, she provides an undoing function that will take a spiralized list and roll it back up (clockwise) into a multidimensional matrix. In this case, to misquote Lady Macbeth, what&rsquo;s done <em>can</em> be undone.</p>
<p>Her methodology is somewhat different than the pack as well; this is the reverse version, which accepts an unwound matrix and coils it back up. The spiralizing complement function, <code>flat</code>, works in a very similar fashion.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">matrixize</span> {
        <span style="color:#66d9ef">my</span> @list <span style="color:#f92672">=</span> @{$_[<span style="color:#ae81ff">0</span>]};
        <span style="color:#66d9ef">my</span> $M <span style="color:#f92672">=</span> $_[<span style="color:#ae81ff">1</span>];
        <span style="color:#66d9ef">my</span> $N <span style="color:#f92672">=</span> $_[<span style="color:#ae81ff">2</span>];
        <span style="color:#66d9ef">my</span> @mat;
        <span style="color:#66d9ef">my</span> @helper_mat;
        push @helper_mat, [(<span style="color:#e6db74">&#34;0&#34;</span>) x $N] <span style="color:#66d9ef">for</span> (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$M<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);

        <span style="color:#66d9ef">my</span> @row_dir <span style="color:#f92672">=</span> (  <span style="color:#ae81ff">0</span>, <span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,  <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> );
        <span style="color:#66d9ef">my</span> @col_dir <span style="color:#f92672">=</span> ( <span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,  <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,  <span style="color:#ae81ff">0</span> );

        <span style="color:#66d9ef">my</span> ($r, $c) <span style="color:#f92672">=</span> ( <span style="color:#ae81ff">0</span> , <span style="color:#ae81ff">0</span> );
        ${$mat[$r]}[$c] <span style="color:#f92672">=</span> $list[<span style="color:#ae81ff">0</span>];
        ${$helper_mat[$r]}[$c] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;

        <span style="color:#66d9ef">my</span> @numbering <span style="color:#f92672">=</span> (
            [<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$N<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>],
            [$N<span style="color:#f92672">..</span>$N<span style="color:#f92672">+</span>$M<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>],
            [$N<span style="color:#f92672">+</span>$M<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$N<span style="color:#f92672">+</span>$M<span style="color:#f92672">+</span>$N<span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>],
            [$N<span style="color:#f92672">+</span>$M<span style="color:#f92672">+</span>$N<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span><span style="color:#f92672">..</span>($M<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span><span style="color:#f92672">+</span>($N<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
        );

        <span style="color:#66d9ef">my</span> $count <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $q (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">3</span>) {
            <span style="color:#66d9ef">for</span> (@{$numbering[$q]}) {
                $r <span style="color:#f92672">+=</span> $row_dir[$q];
                $c <span style="color:#f92672">+=</span> $col_dir[$q];
                ${$mat[$r]}[$c] <span style="color:#f92672">=</span> $list[$count];
                ${$helper_mat[$r]}[$c] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
                $count<span style="color:#f92672">++</span>;
            }
        }

        <span style="color:#66d9ef">my</span> $time_now <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
        <span style="color:#66d9ef">my</span> $success_click <span style="color:#f92672">=</span> undef;
        <span style="color:#66d9ef">while</span> ($count <span style="color:#f92672">&lt;</span> $M<span style="color:#f92672">*</span>$N) {
            <span style="color:#66d9ef">if</span> ($success_click) {
                $r <span style="color:#f92672">+=</span> $row_dir[$time_now];
                $c <span style="color:#f92672">+=</span> $col_dir[$time_now];
                <span style="color:#66d9ef">if</span> (${$helper_mat[$r]}[$c] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
                    ${$mat[$r]}[$c] <span style="color:#f92672">=</span> $list[$count];
                    ${$helper_mat[$r]}[$c] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
                    $success_click <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
                    $count<span style="color:#f92672">++</span>;
                } <span style="color:#66d9ef">else</span>
                {
                    $success_click <span style="color:#f92672">=</span> undef;
                    $r <span style="color:#f92672">-=</span> $row_dir[$time_now];
                    $c <span style="color:#f92672">-=</span> $col_dir[$time_now];
                }
            } <span style="color:#66d9ef">else</span>
            {
                $time_now <span style="color:#f92672">=</span> ($time_now<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) % 4;
                $success_click <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
            }
        }
        <span style="color:#66d9ef">return</span> @mat;
    }
</code></pre></div><h3 id="removing-values-as-we-read-them">REMOVING values as we READ THEM</h3>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/adam-russell/perl/ch-2.pl"><strong>Adam Russell</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/alexander-pankoff/perl/ch-2.pl"><strong>Alexander Pankoff</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/athanasius/perl/ch-2.pl"><strong>Athanasius</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/duncan-c-white/perl/ch-2.pl"><strong>Duncan C. White</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/james-smith/perl/ch-2.pl"><strong>James Smith</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/laurent-rosenfeld/perl/ch-2.pl"><strong>Laurent Rosenfeld</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/nunovieira220/perl/ch-2.pl"><strong>Nuno Vieira</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/samir-parikh/perl/ch-2.pl"><strong>Samir Parikh</strong></a></p>
<p>After examining many variants, I appears that physically removing elements after reading led to quite a bit of simplification. To wit: there&rsquo;s no danger of accidentally reading the wrong ring of cells if they quite literally aren&rsquo;t present. Perl arrays always know their own length, so removing cells as they are read essentially offloads the bookkeeping for an offset onto the data structure itself, which is nice and clean.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/james-smith/perl/ch-2.pl"><strong>James Smith</strong></a></p>
<p>James demonstrates how simple the &lsquo;destructive method&rsquo; as he puts it, can be.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">spiral_matrix</span> {
      <span style="color:#66d9ef">my</span> @rows <span style="color:#f92672">=</span> map { [@{$_}] } @_;
      <span style="color:#75715e">## Note this is a destructive method... So we take a copy of the elements of the array ## o/w we will blow contents of sub-arrays away.</span>
      <span style="color:#66d9ef">my</span> @res;
      <span style="color:#66d9ef">while</span>( @rows <span style="color:#f92672">&amp;&amp;</span> @{$rows[<span style="color:#ae81ff">0</span>]} ) {
        <span style="color:#75715e">## We work around the square.....</span>
        <span style="color:#75715e">## TOP      &gt;&gt;&gt;&gt; we just push to the answers... (and remove them from the array!)</span>
        <span style="color:#75715e">## RIGHT    vvvv Remaining rows we take off the last element... and push to the answer array</span>
        <span style="color:#75715e">## BOTTOM   &lt;&lt;&lt;&lt; (if there is one) we add it to the answers in reverse and remove from the array</span>
        <span style="color:#75715e">## LEFT     ^^^^ Finally we push the first element of each row into the answers {note we go up the array</span>
        <span style="color:#75715e">## Repeat until the array is empty (either has no rows or no columns [entries in first row])</span>
        push @res,         @{shift @rows};
        push @res, pop     @{$_         } <span style="color:#66d9ef">foreach</span> grep { @{$_} }         @rows;
        push @res, reverse @{pop   @rows} <span style="color:#66d9ef">if</span>                             @rows;
        push @res, shift   @{$_         } <span style="color:#66d9ef">foreach</span> grep { @{$_} } reverse @rows;
      }
      <span style="color:#66d9ef">return</span> <span style="color:#f92672">\</span>@res;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/samir-parikh/perl/ch-2.pl"><strong>Samir Parikh</strong></a></p>
<p>Samir gives us a recursive <code>return_spiral</code> variation with exit cases when the matrix is reduced to a either a single row or column, or nothing at all. The commentary gives us the blow-by-blow action.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">return_spiral</span> {
        <span style="color:#66d9ef">my</span> @array <span style="color:#f92672">=</span> @_;
        <span style="color:#66d9ef">my</span> @spiral;
    <span style="color:#75715e"># handle special cases</span>
    <span style="color:#75715e"># just one row</span>
        <span style="color:#66d9ef">if</span> (scalar(@array) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
            <span style="color:#66d9ef">return</span> ( @{$array[<span style="color:#ae81ff">0</span>]} );
    <span style="color:#75715e"># just one column</span>
        } <span style="color:#66d9ef">elsif</span> ( scalar ( @{$array[<span style="color:#ae81ff">0</span>]} ) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> ) {
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">my</span> $i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; $i <span style="color:#f92672">&lt;</span> scalar(@array); $i<span style="color:#f92672">++</span>) {
                push ( @spiral, @{$array[$i]}[<span style="color:#ae81ff">0</span>] );
            }
            <span style="color:#66d9ef">return</span> ( @spiral );
    <span style="color:#75715e"># we have at least a 2 x 2 array</span>
        } <span style="color:#66d9ef">else</span> {
    <span style="color:#75715e"># get first row</span>
            push ( @spiral, @{$array[<span style="color:#ae81ff">0</span>]} );
    <span style="color:#75715e"># get right column</span>
            <span style="color:#66d9ef">my</span> $right_ci <span style="color:#f92672">=</span> scalar ( @{$array[<span style="color:#ae81ff">0</span>]} ) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">my</span> $y <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; $y <span style="color:#f92672">&lt;</span> scalar ( @array ); $y<span style="color:#f92672">++</span>) {
                push ( @spiral, @{$array[$y]}[$right_ci] );
            }
    <span style="color:#75715e"># remove last element from last row</span>
            pop ( @{$array[$#array]} );
    <span style="color:#75715e"># get last row in reversed order</span>
            push ( @spiral, reverse ( @{$array[$#array]} ) );
    <span style="color:#75715e"># get left column</span>
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">my</span> $i <span style="color:#f92672">=</span> ($#array <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>); $i <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>; $i<span style="color:#f92672">--</span>) {
                push ( @spiral, @{$array[$i]}[<span style="color:#ae81ff">0</span>] );
            }
    <span style="color:#75715e"># check if resulting array is empty (i.e. we were originally sent</span>
    <span style="color:#75715e"># just a two-row or two-column array to begin with</span>
            <span style="color:#66d9ef">if</span> (scalar( @array ) <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">||</span> scalar ( @{$array[<span style="color:#ae81ff">0</span>]} ) <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>) {
                <span style="color:#66d9ef">return</span> ( @spiral );
            } <span style="color:#66d9ef">else</span> {
    <span style="color:#75715e"># trim array</span>
    <span style="color:#75715e"># trim top row:</span>
                shift @array;
    <span style="color:#75715e"># trim bottom row:</span>
                pop @array;
    <span style="color:#75715e"># remove first and last element from remaining rows</span>
                <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">my</span> $i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; $i <span style="color:#f92672">&lt;</span> scalar(@array); $i<span style="color:#f92672">++</span>) {
                    shift ( @{$array[$i]} );
                    pop   ( @{$array[$i]} );
                }
                <span style="color:#66d9ef">return</span> ( @spiral, <span style="color:#f92672">&amp;</span>return_spiral(@array) );
            }
        }
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/nunovieira220/perl/ch-2.pl"><strong>Nuno Vieira</strong></a></p>
<p>Nuno chooses a recursive method as well, using <code>splice</code> to do his butchering.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">handleMatrix</span> {
        <span style="color:#66d9ef">my</span> @matrix <span style="color:#f92672">=</span> @_;
        <span style="color:#66d9ef">my</span> @res <span style="color:#f92672">=</span> (  );

        <span style="color:#66d9ef">return</span> @res <span style="color:#66d9ef">if</span>( scalar @matrix <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> );

        <span style="color:#66d9ef">my</span> $firstRow <span style="color:#f92672">=</span> splice( @matrix, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span> );
        push @res, @{ $firstRow };

        <span style="color:#66d9ef">if</span>( scalar @matrix <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> ) {
            <span style="color:#66d9ef">for</span>( <span style="color:#66d9ef">my</span> $i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; $i <span style="color:#f92672">&lt;</span> scalar @matrix <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; $i<span style="color:#f92672">++</span> ) {
                <span style="color:#66d9ef">my</span> $lastElem <span style="color:#f92672">=</span> splice( @{ $matrix[$i] }, scalar( @{ $matrix[$i] } ) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span> );
                push @res, $lastElem;
            }

            <span style="color:#66d9ef">my</span> $lastRow <span style="color:#f92672">=</span> splice( @matrix, scalar( @matrix ) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span> );
            push @res, reverse @{ $lastRow };

            <span style="color:#66d9ef">for</span>( <span style="color:#66d9ef">my</span> $i <span style="color:#f92672">=</span> scalar @matrix <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; $i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; $i<span style="color:#f92672">--</span> ) {
                <span style="color:#66d9ef">my</span> $firstElem <span style="color:#f92672">=</span> splice( @{ $matrix[$i] }, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span> );
                push @res, $firstElem;
            }
        }

        push @res, handleMatrix( @matrix );

        <span style="color:#66d9ef">return</span> @res;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/adam-russell/perl/ch-2.pl"><strong>Adam Russell</strong></a></p>
<p>Adam creates four helper functions to lop off parts of the matrix as they are processed, yielding a very simple core control structure that directly prints the results as they are gathered. His helper functions use a combination of <code>splice</code> and assignment to array slices to remove parts of his matrix once read.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">spiral_print</span>{
        <span style="color:#66d9ef">my</span>(@matrix) <span style="color:#f92672">=</span> @_;
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;[&#34;</span>;
        {
            @matrix <span style="color:#f92672">=</span> print_remove_top(@matrix) <span style="color:#66d9ef">if</span> @matrix;
            @matrix <span style="color:#f92672">=</span> print_remove_right(@matrix) <span style="color:#66d9ef">if</span> @matrix;
            @matrix <span style="color:#f92672">=</span> print_remove_bottom(@matrix) <span style="color:#66d9ef">if</span> @matrix;
            @matrix <span style="color:#f92672">=</span> print_remove_left(@matrix) <span style="color:#66d9ef">if</span> @matrix;
            <span style="color:#66d9ef">redo</span> <span style="color:#66d9ef">if</span> @matrix;
        }
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;\b\b]\n&#34;</span>;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/alexander-pankoff/perl/ch-2.pl"><strong>Alexander Pankoff</strong></a></p>
<p>Alexander does his trimming out-of-order, first the whole of the top and bottom, followed by the sides, while saving the values to temporary arrays. This simplifies things quite a bit, and at the end of every looping the snatched component parts are reassembled in the correct order before assignment to the return value. Recursion completes the looping until the matrix is consumed.</p>
<p>I found in my own solution that the symmetries of taking complete rows and inset columns made reversing the bottom and left sides much cleaner and easier to follow.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">spriral_matrix</span>($matrix) {
        <span style="color:#66d9ef">my</span> @matrix <span style="color:#f92672">=</span> @$matrix;

        <span style="color:#66d9ef">return</span> () <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>@matrix;

        <span style="color:#75715e"># get top and bottom row  an remove them from the input</span>
        <span style="color:#66d9ef">my</span> ( $top, $bot );
        ( $top, @matrix ) <span style="color:#f92672">=</span> @$matrix;
        ( $bot, @matrix ) <span style="color:#f92672">=</span> ( $matrix[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], @matrix[ <span style="color:#ae81ff">0</span> <span style="color:#f92672">...</span> ( $#matrix <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> ) ] );

        <span style="color:#75715e"># get left and right side from the remaining rows</span>
        <span style="color:#66d9ef">my</span> @left_side  <span style="color:#f92672">=</span> map { $_<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] } @matrix;
        <span style="color:#66d9ef">my</span> @right_side <span style="color:#f92672">=</span> map { $_<span style="color:#f92672">-&gt;</span>[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] } @matrix;

        <span style="color:#75715e"># remove left and right side from the matrix</span>
        @matrix <span style="color:#f92672">=</span> map { [ @{$_}[ <span style="color:#ae81ff">1</span> <span style="color:#f92672">...</span> ( $#$_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> ) ] ] } @matrix;

        <span style="color:#66d9ef">return</span> ( @$top, @right_side, reverse( @{ $bot <span style="color:#e6db74">//</span> <span style="color:#f92672">[]</span> } ),
            reverse(@left_side), spriral_matrix( <span style="color:#f92672">\</span>@matrix ) );
    }
</code></pre></div><h2 id="manipulate-the-matrix">manipulate the MATRIX</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/arne-sommer/perl/ch-2.pl"><strong>Arne Sommer</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/juliodcs/perl/ch-2.pl"><strong>Julio de Castro</strong></a></p>
<p>A truly novel approach that worked out quite well is to read and remove the top row of the matrix, then, instead of changing our read direction, simply rotating the matrix underneath our feet one step counterclockwise.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/arne-sommer/perl/ch-2.pl"><strong>Arne Sommer</strong></a></p>
<p>Arne reached for a matrix module to do the transformation, in this case <code>Math::Matrix</code>. From that point the actual manipulation is quite simple. He reads the top row, adds it to the output, deletes it from the matrix, then rotates the matrix 90°. Repeat until the matrix is consumed.
Very nice.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span> $m <span style="color:#f92672">=</span> Math::Matrix<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">new</span>(@rows);
    <span style="color:#66d9ef">my</span> @spiral;

    <span style="color:#66d9ef">while</span> ($m<span style="color:#f92672">-&gt;</span>nrow())
    {
      <span style="color:#66d9ef">my</span> $row <span style="color:#f92672">=</span> $m<span style="color:#f92672">-&gt;</span>getrow(<span style="color:#ae81ff">0</span>);

      push(@spiral, @{@{$row}[<span style="color:#ae81ff">0</span>]});
      $m <span style="color:#f92672">=</span> $m<span style="color:#f92672">-&gt;</span>delrow(<span style="color:#ae81ff">0</span>);
      $m <span style="color:#f92672">=</span> $m<span style="color:#f92672">-&gt;</span>rot90();
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/juliodcs/perl/ch-2.pl"><strong>Julio de Castro</strong></a></p>
<p>Julio came to the same conclusion for his process, but uses his own routine to perform the transformation. As it turns out, this action, rotating a matrix, can be executed in a few short lines of code. His <code>rotator</code> function does the work.</p>
<p>The team visited the idea of rotating matrices back in <a href="https://perlweeklychallenge.org/blog/review-challenge-053/">PWC 053</a>, for those interested in more examples on how to go about this.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">spiral_matrix</span>($matrix, $acc = []) {
    <span style="color:#66d9ef">return</span> $acc <span style="color:#66d9ef">if</span> $matrix<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span> <span style="color:#960050;background-color:#1e0010">==</span> 0;
    <span style="color:#66d9ef">my</span> @new_acc <span style="color:#f92672">=</span> ($acc<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span>, (shift $matrix<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span>)<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span>);

    spiral_matrix(rotator($matrix), <span style="color:#f92672">\</span>@new_acc);
}

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">rotator</span>($matrix) {
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">[]</span> <span style="color:#66d9ef">if</span> $matrix<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span> <span style="color:#960050;background-color:#1e0010">==</span> 0;
    <span style="color:#66d9ef">my</span> $w <span style="color:#f92672">=</span> $matrix<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>

    <span style="color:#960050;background-color:#1e0010">[</span>map {<span style="color:#66d9ef">my</span> $i <span style="color:#f92672">=</span> $_;[ map {$_<span style="color:#f92672">-&gt;</span>[$i]} $matrix<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span> <span style="color:#960050;background-color:#1e0010">]}</span> reverse <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $w <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]
}
</code></pre></div><h2 id="renegades-revelations-and-wandering-ascetic-visionaries">RENEGADES, REVELATIONS and WANDERING ASCETIC VISIONARIES</h2>
<h3 id="unleash-the-pdl">unleash the PDL!</h3>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/jo-37/perl/ch-2.pl"><strong>Jorg Sommrey</strong></a> and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/wlmb/perl/ch-2.pl"><strong>W. Luis Mochan</strong></a></p>
<p>I don&rsquo;t hold back on my pleasure in discovering solutions utilizing the Perl Data Language. Every opportunity dissecting these gems teaches me a little more about the data processing power of this amazing tool.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/jo-37/perl/ch-2.pl"><strong>Jorg Sommrey</strong></a></p>
<p>In our opening argument, Jorg takes his matrix and sections off parts using the PDL <code>slice</code> function, advancing around in a clockwise fashion and reconstructing the matrix along the way from the remaining sections after slicing. This is akin to the archetypical encircle and remove after reading method.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#75715e"># Instructions for the unrolling engine:</span>
    <span style="color:#75715e"># - edge (as slice arg)</span>
    <span style="color:#75715e"># - remaining matrix (as slice arg)</span>
    <span style="color:#75715e"># - affected dimension (row or column)</span>
    <span style="color:#75715e"># by direction.</span>
    <span style="color:#66d9ef">my</span> @instr <span style="color:#f92672">=</span> (
    	[<span style="color:#e6db74">&#39;X,(0)&#39;</span>, <span style="color:#e6db74">&#39;X,1:-1&#39;</span>, <span style="color:#ae81ff">1</span>],		<span style="color:#75715e"># first row, east</span>
    	[<span style="color:#e6db74">&#39;(-1),X&#39;</span>, <span style="color:#e6db74">&#39;0:-2,X&#39;</span>, <span style="color:#ae81ff">0</span>],	<span style="color:#75715e"># last column, south</span>
    	[<span style="color:#e6db74">&#39;-1:0,(-1)&#39;</span>, <span style="color:#e6db74">&#39;X,0:-2&#39;</span>, <span style="color:#ae81ff">1</span>],	<span style="color:#75715e"># last row, west</span>
    	[<span style="color:#e6db74">&#39;(0),-1:0&#39;</span>, <span style="color:#e6db74">&#39;1:-1,X&#39;</span>, <span style="color:#ae81ff">0</span>]);	<span style="color:#75715e"># first column, north</span>

    <span style="color:#75715e"># Unroll given matrix, i.e. return the elements as a 1-d list in</span>
    <span style="color:#75715e"># spiral form.</span>
    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">unroll</span> {
    	<span style="color:#75715e"># Input matrix, starting direction and result.</span>
    	<span style="color:#66d9ef">my</span> ($m, $dir, $unrolled) <span style="color:#f92672">=</span> (long(shift), <span style="color:#ae81ff">0</span>, PDL<span style="color:#f92672">-&gt;</span>null);

    	say $m;
    	die <span style="color:#e6db74">&#34;not a matrix&#34;</span> <span style="color:#66d9ef">unless</span> $m<span style="color:#f92672">-&gt;</span>ndims <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>;

    	<span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>) {
    		<span style="color:#75715e"># Get the instructions.</span>
    		<span style="color:#66d9ef">my</span> ($edge, $remaining, $dim) <span style="color:#f92672">=</span> $instr[$dir]<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>

    		<span style="color:#960050;background-color:#1e0010">#</span> Append current edge to the result<span style="color:#f92672">.</span>
    		$unrolled <span style="color:#f92672">=</span> $unrolled<span style="color:#f92672">-&gt;</span>append($m<span style="color:#f92672">-&gt;</span>slice($edge));

    		<span style="color:#75715e"># Stop if the current edge was the last remaining dimension.</span>
    		<span style="color:#66d9ef">last</span> <span style="color:#66d9ef">if</span> $m<span style="color:#f92672">-&gt;</span>dim($dim) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>;

    		<span style="color:#75715e"># Take the remaining matrix.</span>
    		$m <span style="color:#f92672">=</span> $m<span style="color:#f92672">-&gt;</span>slice($remaining);

    		<span style="color:#75715e"># Switch direction.</span>
    		$dir <span style="color:#f92672">=</span> ($dir <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) % 4;
    	}

    	say $unrolled;
    	$unrolled<span style="color:#f92672">-&gt;</span>unpdl;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/wlmb/perl/ch-2.pl"><strong>W. Luis Mochan</strong></a></p>
<p>Welcoming Luis to the party, we find him bringing us a PDL analogue to the slice and rotate method, reading the top row, removing it, rotating the matrix underfoot and repeating until the matrix is consumed.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">spiral_matrix</span> {
        <span style="color:#66d9ef">use</span> PDL;                                    <span style="color:#75715e"># use the perl data language</span>
        <span style="color:#66d9ef">use</span> PDL::NiceSlice;
        <span style="color:#66d9ef">my</span> $input <span style="color:#f92672">=</span> pdl(@_);                        <span style="color:#75715e"># input piddle (PDL 2D array)</span>
        <span style="color:#66d9ef">my</span> @output;
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">if</span> $input<span style="color:#f92672">-&gt;</span>dim(<span style="color:#ae81ff">1</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>;              <span style="color:#75715e"># 0 rows no elements</span>
        <span style="color:#66d9ef">while</span> ($input<span style="color:#f92672">-&gt;</span>dim(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {                <span style="color:#75715e"># until no more columns</span>
            push @output, $input<span style="color:#f92672">-&gt;</span>(:,(<span style="color:#ae81ff">0</span>))<span style="color:#f92672">-&gt;</span>list;    <span style="color:#75715e"># walk through row</span>
            <span style="color:#66d9ef">last</span> <span style="color:#66d9ef">if</span> $input<span style="color:#f92672">-&gt;</span>dim(<span style="color:#ae81ff">1</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>;            <span style="color:#75715e"># no more rows</span>
            $input <span style="color:#f92672">=</span> $input<span style="color:#f92672">-&gt;</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>:<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>:<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)            <span style="color:#75715e"># reflect rows, remove one row</span>
                <span style="color:#f92672">-&gt;</span>transpose;                        <span style="color:#75715e"># rotate</span>
        }
        <span style="color:#66d9ef">return</span> @output
    }
</code></pre></div><hr>
<h1 id="PWC088BLOGS">BLOGS</h1>
<hr>
<p><strong>That&rsquo;s it for me this week, people! Resolute and unbroken by the torrential influx, I have maintained my bearings. Looking forward to next wave, the perfect wave, I am: your humble servant.</strong></p>
<h2 id="PWC088BLOGS">But if Your <em>THIRST</em> for <em>KNOWLEDGE</em> is not <em>SLAKED</em>,</h2>
<h2 id="then-run-dont-walk-to-the-watering-hole">then <em>RUN</em> <em>(dont walk!)</em> to the <em>WATERING HOLE</em></h2>
<h2 id="and-read-these-blog-links">and <em>READ</em> these <em>BLOG</em> <em>LINKS</em>:</h2>
<p><em><strong>( don&rsquo;t think, trust your training, you&rsquo;re in the zone, just do it &hellip; )</strong></em></p>
<p><strong>Abigail</strong></p>
<ul>
<li><a href="https://wp.me/pcxd30-7I">Perl Weekly Challenge 88, Part 1 – Abigail's Programming Blog</a> ( <em>Perl</em> )</li>
<li><a href="https://wp.me/pcxd30-8Z">Perl Weekly Challenge 88, Part 2 – Abigail's Programming Blog</a> ( <em>Perl</em> )</li>
</ul>
<p><strong>Adam Russell</strong></p>
<ul>
<li><a href="http://www.rabbitfarm.com/cgi-bin/blosxom/perl/2020/11/29">Perl Weekly Challenge 088 - RabbitFarm</a> ( <em>Perl</em> )</li>
<li><a href="http://www.rabbitfarm.com/cgi-bin/blosxom/prolog/2020/11/29">Perl Weekly Challenge 088 - RabbitFarm</a> ( <em>Prolog</em> )</li>
</ul>
<p><strong>Arne Sommer</strong></p>
<ul>
<li><a href="https://raku-musings.com/arrayed-spiral.html">Arrayed Spiral with Raku and Perl</a> ( <em>Perl &amp; Raku</em> )</li>
</ul>
<p><strong>Cheok-Yin Fung</strong></p>
<ul>
<li><a href="http://blogs.perl.org/users/c_y_fung/2020/11/cys-take-on-pwc088.html">CY&rsquo;s Take on PWC#088 | Moments on Perl or other Programming Issues</a> ( <em>Perl</em> )</li>
</ul>
<p><strong>Colin Crain</strong></p>
<ul>
<li><a href="https://colincrain.com/2020/11/29/the-product-of-the-absence-spiralize-the-day-away/">The Product of the Absence – Spiralize the Day Away – Programming Excursions in Perl and Raku</a> ( <em>Perl &amp; Raku</em> )</li>
</ul>
<p><strong>Flavio Poletti</strong></p>
<ul>
<li><a href="https://github.polettix.it/ETOOBUSY/2020/11/26/pwc088-array-of-product/">PWC088 - Array of Product - ETOOBUSY</a> ( <em>Perl</em> )</li>
<li><a href="https://github.polettix.it/ETOOBUSY/2020/11/27/pwc088-spiral-matrix/">PWC088 - Spiral Matrix - ETOOBUSY</a> ( <em>Perl</em> )</li>
</ul>
<p><strong>Jaldhar H. Vyas</strong></p>
<ul>
<li><a href="https://www.braincells.com/perl/2020/11/perl_weekly_challenge_week_88.html">Perl Weekly Challenge: Week 88</a> ( <em>Perl &amp; Raku</em> )</li>
</ul>
<p><strong>Kang-min Liu</strong></p>
<ul>
<li><a href="https://gugod.org/2020/11/pwc-088-en/">Solving Perl Weekly Challenge 088 &ndash; Array of Prodict vs Spiral Matrix.</a> ( <em>Raku</em> )</li>
</ul>
<p><strong>Laurent Rosenfeld</strong></p>
<ul>
<li><a href="http://blogs.perl.org/users/laurent_r/2020/11/perl-weekly-challenge-88-array-of-products-and-spiral-matrices.html">Perl Weekly Challenge 88: Array of Products and Spiral Matrices</a> ( <em>Perl &amp; Raku</em> )</li>
</ul>
<p><strong>Lubos Kolouch</strong></p>
<ul>
<li><a href="https://v.kolouch.org/nextcloud/index.php/apps/cms_pico/pico/lubos/20201128_perl_weekly_088">Lubos Kolouch</a> ( <em>Perl</em> )</li>
</ul>
<p><strong>Roger Bell_West</strong></p>
<ul>
<li><a href="https://blog.firedrake.org/archive/2020/11/Perl_Weekly_Challenge_88__Spiral_Product.html">RogerBW's Blog: Perl Weekly Challenge 88: Spiral Product</a> ( <em>Perl &amp; Raku</em> )</li>
</ul>
<p><strong>Samir Parikh</strong></p>
<ul>
<li><a href="https://samirparikh.com/blog/perl-weekly-challenge-088.html">Perl Weekly Challenge 088</a> ( <em>Perl</em> )</li>
</ul>
<p><strong>Simon Green</strong></p>
<ul>
<li><a href="https://dev.to/simongreennet/weekly-challenge-088-5c5f">Weekly Challenge 088</a> ( <em>Perl</em> )</li>
</ul>
<p><strong>W. Luis Mochán</strong></p>
<ul>
<li><a href="https://wlmb.github.io/PWC/">Perl Weekly Challenge 88</a> ( <em>Perl</em> )</li>
</ul>
<p><strong>Walt Mankowski</strong></p>
<ul>
<li><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/walt-mankowski/README.md">Weekly Challenge 088</a> ( <em>Perl</em> )</li>
</ul>

                </div>
            </div>
        </div>
    </div>
</section>


<!-- Call To Action Section Start -->
<section id="call-to-action">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2 class="title wow fadeInDown" data-wow-delay=".3s" data-wow-duration="500ms">SO WHAT DO YOU THINK ?</h2>
                    <p class="wow fadeInDown" data-wow-delay=".5s" data-wow-duration="500ms">If you have any suggestions or ideas then please do share with us.</p>
                    <a href="/contact" class="btn btn-default btn-contact wow fadeInDown" data-wow-delay=".7s" data-wow-duration="500ms">Contact with me</a>
                </div>
            </div>

        </div>
    </div>
</section>
<!-- Call To Action Section End -->



<!-- Footer Section Start -->
<footer id="footer">
    <div class="container">
        <div class="row content-justify-between">
            <div class="col-md-8 col-12 text-center text-lg-left text-md-left">
                <p class="copyright">Copyright:
                    <span>
                        2019 - 2025
                    </span> The Weekly Challenge. Theme Design and Developed by
                    <a href="http://www.Themefisher.com" rel="noreferrer" rel="noreferrer" target="_blank">Themefisher</a>.
                </p>
            </div>
            <div class="col-md-4 col-12">
                <!-- Social Media -->
                <ul class="social text-center text-md-right text-lg-right">
                    <li>
                        <a href="https://twitter.com/PerlWChallenge" class="twitter" rel="noreferrer" target="_blank" title="Follow us">
                            <i class="ion-social-twitter"></i>
                        </a>
                    </li>
                    <li>
                        <a href="/rss.xml" class="rss" target="_blank" title="RSS Feed">
                            <i class="ion-social-rss"></i>
                        </a>
                    </li>
                </ul>
            </div>
        </div>
    </div>
</footer>
<!-- footer section end -->

<!-- jquery -->
<script src="https://theweeklychallenge.org/plugins/jquery/jquery.min.js"></script>
<!-- Form Validation -->
<script src="https://theweeklychallenge.org/plugins/form-validation/jquery.form.min.js"></script>
<script src="https://theweeklychallenge.org/plugins/form-validation/jquery.validate.min.js"></script>
<!-- slick slider -->
<script src="https://theweeklychallenge.org/plugins/slick/slick.min.js"></script>
<!-- bootstrap js -->
<script src="https://theweeklychallenge.org/plugins/bootstrap/bootstrap.min.js"></script>
<!-- chart js -->
<script src="https://theweeklychallenge.org/plugins/chart/highstock.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/drilldown.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/data.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/chart.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/pwc-challenge.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/gc-challenge.js"></script>
<!-- wow js -->
<script src="https://theweeklychallenge.org/plugins/wow-js/wow.min.js"></script>
<!-- slider js -->
<script src="https://theweeklychallenge.org/plugins/slider/slider.js"></script>
<!-- Fancybox -->
<script src="https://theweeklychallenge.org/plugins/facncybox/jquery.fancybox.js"></script>
<!-- template main js -->

<script src="https://theweeklychallenge.org/js/script.min.js"></script>
<!-- google analitycs -->

<script async src="https://www.googletagmanager.com/gtag/js?id=G-CJTPYM9SB8"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-CJTPYM9SB8');
</script>
</body>

</html>

