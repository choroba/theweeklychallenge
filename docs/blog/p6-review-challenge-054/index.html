<!DOCTYPE html>
<html class="no-js" lang="en-us">
<head>
    <!-- Basic Page Needs -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:title"       content="The Weekly Challenge"/>
    <meta property="og:type"        content="website"/>
    <meta property="og:url"         content="https://theweeklychallenge.org/"/>
    <meta property="og:image"       content="https://theweeklychallenge.org/images/about/about.jpg"/>
    <meta property="og:description" content="You do not have to be an expert."/>
    <meta name="twitter:card"       content="summary" />
    <meta name="twitter:image"      content="https://theweeklychallenge.org/images/about/about.jpg"/>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <meta name="description" content="Laurent Rosenfeld Weekly Review: Challenge - #054.">
    <meta name="author" content="The Weekly Challenge Team">
    <meta name="generator" content="Hugo 0.67.0-DEV" />

    <link rel="me" href="https://fosstodon.org/@manwar">

    <!-- Mobile Specific Metas -->
    <meta name="format-detection" content="telephone=no">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Laurent Rosenfeld Weekly Review: Challenge - 054</title>
    <link rel="icon" href="https://theweeklychallenge.org/images/favicon.ico">

    
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css"/>

    <!-- Twitter Bootstrs CSS -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/bootstrap/bootstrap.min.css">
    <!-- Ionicons Fonts Css -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/ionicons/ionicons.min.css">
    <!-- animate css -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/animate-css/animate.css">
    <!-- Hero area slider css-->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/slider/slider.css">
    <!-- slick slider -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/slick/slick.css">
    <!-- Fancybox -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/facncybox/jquery.fancybox.css">
    <!-- hover -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/hover/hover-min.css">
    <!-- Google fonts -->
    <link href='https://fonts.googleapis.com/css?family=Source Code Pro' rel='stylesheet'>
    <!-- template main css file -->
    
    <link rel="stylesheet" href="https://theweeklychallenge.org/css/style.min.css" integrity="" media="screen">
    <link rel="stylesheet" href="https://theweeklychallenge.org/css/main.css">

    <style>
        #goTopButton {
            display: none;          
            position: fixed;        
            bottom: 20px;           
            right: 30px;            
            z-index: 99;            
            border: none;           
            outline: none;          
            background-color: red;  
            color: white;           
            cursor: pointer;        
            padding: 15px;          
            border-radius: 10px;    
            font-size: 18px;        
        }

        #goTopButton:hover {
              background-color: #555;
        }
    </style>


</head>

<body>

<button onclick="goTop()" id="goTopButton" title="Go to top">Top</button>

<script>

    topButton = document.getElementById("goTopButton");

    
    window.onscroll = function() { scrollFunction() };

    function scrollFunction() {
        if (document.body.scrollTop > 40 || document.documentElement.scrollTop > 40) {
            topButton.style.display = "block";
        } else {
            topButton.style.display = "none";
        }
    }

    
    function goTop() {
        document.body.scrollTop = 0; 
        document.documentElement.scrollTop = 0; 
    }

</script>

<section class="top-bar animated-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-12">
                <nav class="navbar navbar-expand-lg navbar-light bg-light">
                    <a class="navbar-brand" href="https://theweeklychallenge.org/">
                        <img src="https://theweeklychallenge.org/images/logo.svg" alt="logo">
                    </a>
                    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navgation" aria-controls="navigation"
                        aria-expanded="false" aria-label="Toggle navigation">
                        <span class="navbar-toggler-icon"></span>
                    </button>

                    <div class="collapse navbar-collapse" id="navigation">
                        <ul class="navbar-nav ml-auto">
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/">Home</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/about">About</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/chart">Chart</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/champions">Champions</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/team">Team</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/challenges">Challenges</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/p5-reviews">Perl/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/p6-reviews">Raku/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/recaps">Recaps</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/blogs">Blogs</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/faq">FAQ</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/contact">Contact</a>
                            </li>
                            
                        </ul>
                    </div>
                </nav>
            </div>
        </div>
    </div>
</section>


<section class="global-page-header">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2>Laurent Rosenfeld Weekly Review: Challenge - 054</h2>
                    <div class="portfolio-meta">
                        <span>Wednesday, Apr 22, 2020</span>|
                        <span> Tags:
                            Raku
                        </span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

<section class="single-post">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                
                <div style="text-align: center" class="post-img">
                    <img class="img-fluid" alt="" src="https://theweeklychallenge.org/images/blog/p6-review-challenge-054.jpg">
                </div>
                
                <div style="text-align: justify" class="post-content">
                    <hr>
<h1 id="raku-solutions-weekly-review">Raku Solutions Weekly Review</h1>
<hr>
<h2 id="task-2-the-collatz-conjecture">Task #2: The Collatz Conjecture</h2>
<p>This is derived in part from my <a href="http://blogs.perl.org/users/laurent_r/2020/04/perl-weekly-challenge-54-k-th-permutation-sequence-and-the-collatz-conjecture.html">initial blog post</a>and <a href="http://blogs.perl.org/users/laurent_r/2020/04/revisiting-the-collatz-sequence-pwc-54.html">follow-up blog post revisiting the subject</a>  made in answer to the <a href="https://perlweeklychallenge.org/blog/perl-weekly-challenge-054/">Week 54 of the Perl Weekly Challenge</a> organized by  <a href="http://blogs.perl.org/users/mohammad_s_anwar/">Mohammad S. Anwar</a> as well as answers made by others to the same challenge.</p>
<p>The challenge reads as follows:</p>
<p><em>It is thought that the following sequence will always reach 1:</em></p>
<pre><code>$n = $n / 2 when $n is even
$n = 3*$n + 1 when $n is odd
</code></pre>
<p><em>For example, if we start at 23, we get the following sequence:</em></p>
<pre><code>23 → 70 → 35 → 106 → 53 → 160 → 80 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1
</code></pre>
<p><em>Write a function that finds the Collatz sequence for any positive integer. Notice how the sequence itself may go far above the original starting number.</em></p>
<p><em>Extra Credit: have your script calculate the sequence length for all starting numbers up to 1000000 (1e6), and output the starting number and sequence length for the longest 20 sequences.</em></p>
<p>The Collatz conjecture related to a sequence of numbers defined as follows: start with any positive integer <em>n</em>. Then each term is obtained from the previous term as follows: if the previous term is even, the next term is one half of the previous term. If the previous term is odd, the next term is 3 times the previous term plus 1. The conjecture is that, no matter what value of <em>n</em>, the sequence will always reach 1. This conjecture is named after Lothar Collatz who introduced it in 1937. It is sometimes known as the Syracuse problem (and some other names). It is usually believed to be true (and no counter-example has ever been found), but, despite a lot of efforts, nobody has been able to prove it, and this is deemed to be a very difficult problem.</p>
<h2 id="my-solutions">My Solutions</h2>
<h3 id="the-basic-task">The Basic Task</h3>
<p>For the purpose of the basic task, this is fairly straight forward. Here, we write a <code>collatz-seq</code> subroutine that, given an integer computes the next term in the Collatz sequence. And we call that subroutine in a loop until we reach 1:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#66d9ef">use</span> v6;

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">collatz</span>-seq (UInt $in) {
    <span style="color:#66d9ef">my</span> $n <span style="color:#f92672">=</span> $in;
    <span style="color:#66d9ef">my</span> @result <span style="color:#f92672">=</span> gather {
        <span style="color:#66d9ef">while</span> $n <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span> {
            <span style="color:#66d9ef">my</span> $new<span style="color:#f92672">-</span>n <span style="color:#f92672">=</span> $n % 2 ?? <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> $n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">!!</span> $n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
            take $new<span style="color:#f92672">-</span>n;
            $n <span style="color:#f92672">=</span> $new<span style="color:#f92672">-</span>n;
        }
    }
    <span style="color:#66d9ef">return</span> $in, <span style="color:#f92672">|</span>@result;
}
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">MAIN</span> (UInt $in) {
    <span style="color:#66d9ef">my</span> @seq <span style="color:#f92672">=</span> collatz<span style="color:#f92672">-</span>seq $in;
    <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;Collatz sequence for $in: &#34;</span>, @seq, <span style="color:#e6db74">&#34;\n&#34;</span>;
}
</code></pre></div><p>Here are a few sample runs:</p>
<pre><code>$ perl6  collatz_1.p6 8
Collatz sequence for 8: 8 4 2 1

$ perl6  collatz_1.p6 23
Collatz sequence for 23: 23 70 35 106 53 160 80 40 20 10 5 16 8 4 2 1

$ perl6  collatz_1.p6 25
Collatz sequence for 25: 25 76 38 19 58 29 88 44 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1
</code></pre>
<p>Note that I used the <code>print</code> function rather than the <code>say</code> function here, because <code>say</code> would abbreviate long sequences (for example, the sequence for 27 would end with an ellipsis: <code>...</code>).</p>
<h3 id="extra-credit-collatz-sequence-for-all-numbers-up-to-1000000">Extra Credit: Collatz Sequence for all Numbers up to 1,000,000</h3>
<p>In theory, it wouldn&rsquo;t be very complicated to encapsulate the above program into an outer loop to compute the Collatz sequence for any range of numbers. Except that going all the way up to 1,000,000 is probably going to take ages. One of the reason is that we&rsquo;re going to recompute Collatz sequence successors for the same number again and again many times. If you look at the above examples, the sequences all end up with the following sequence: <code>16 8 4 2 1</code>. So, it might be useful, when we reach 16 for the first time, to compute the end of the sequence only once, and to store it in a hash of arrays (or possibly an array of arrays), in order to retrieve it straight from the hash when we reach 16 once more. Similarly, the sequence for 25 end with <code>40 20 10 5 16 8 4 2 1</code>. If we store this sequence somewhere, then we don&rsquo;t have to compute it once more when we reach 40 while computing the Collatz sequence for 27, and, or course, also when we compute the Collatz sequence for 40, 80, 160, as well as 13, 26, 52, etc. Such a strategy is called <em>caching</em> or <em>memoizing</em>: storing in memory the result of a computation that we&rsquo;re likely to have to compute again. It is sometimes described as &ldquo;trading memory for time.&rdquo;</p>
<p>There is a Perl core module, called <a href="https://perldoc.perl.org/Memoize.html">Memoize</a>, written my Mark Jason Dominus, that is very easy to use and can do the caching automatically for you. This module has been <a href="https://modules.raku.org/dist/Memoize:cpan:ELIZABETH">ported to Raku</a>. There is also the Raku <a href="https://docs.raku.org/syntax/cached">:cached</a> experimental feature and the <a href="https://docs.raku.org/routine/is%20cached">is cached</a> trait The problem though is that it wouldn&rsquo;t be very practical to use it here, because we don&rsquo;t want to cache just the next item in the sequence, but all the rest of the sequence down to 1. So it might be better to implement a cache ourselves, manually (that&rsquo;s not very difficult, as we shall see).</p>
<p>There is another problem though, which is much more delicate. Since the requirement is to compute the Collatz sequence for all integers up to 1,000,000, the cache will grow very large (several millions of sequences) and we might run out of memory. In the initial version of the program below, I tried to store all sequences up to one million, and the program turned out to be painfully slow. Looking at the system statistics, I found that, after a while, available memory became exhausted and the system would swap memory on the disk, leading to very slow execution. I made a couple of tests, and found that I could store the sequences for all numbers up to about 200,000 without exceeding the available memory of my computer (YMMV, that number might be different on your computer), thus preventing the process from swapping and getting more or less the best possible performance, hence the <code>MAX</code> constant set to 300,000.</p>
<p>Since I knew from earlier tests that the 20 longest sequences would all have more than 400 items, I also hard-coded a lower limit of 400 items for the sequences whose length had to be recorded. Another possibly better solution might have been to maintain a sliding array of the top 20 sequences, but I feared that maintaining this array many times over the execution of the program would end up impacting performance negatively. Note that a better way would be to use an array of arrays in which the top level array indices are the sequence lengths and the nested arrays contain the numbers for which the Collatz sequence has this count. The final work is then simply to iterate over the reversed top array and pick up sequences until we have 20. Pretty easy. But I thought about that solution only after I made most of the tests below, so the code examples presented here will use the had-coded lower limit explained above.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#66d9ef">use</span> v6;

<span style="color:#66d9ef">my</span> %cache <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">=&gt;</span> [<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>];

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">collatz_seq</span> (UInt $in) {
    <span style="color:#66d9ef">my</span> @result;
    <span style="color:#66d9ef">my</span> $n <span style="color:#f92672">=</span> $in;
    <span style="color:#66d9ef">while</span> $n <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span> {
        <span style="color:#66d9ef">if</span> %cache{$n} :exists {
            push @result, <span style="color:#f92672">|</span>@<span style="color:#960050;background-color:#1e0010">(%</span>cache{$n});
            <span style="color:#66d9ef">last</span>;
        } <span style="color:#66d9ef">else</span> {
            <span style="color:#66d9ef">my</span> $new_n <span style="color:#f92672">=</span> $n % 2 ?? <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> $n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">!!</span> $n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
            push @result, $new_n;
            %cache{$n} <span style="color:#f92672">=</span> [$new_n, <span style="color:#f92672">|</span>%cache{$new_n}]
                <span style="color:#66d9ef">if</span> defined (%cache{$new_n}) <span style="color:#f92672">and</span> $new_n <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">200000</span>;
            $n <span style="color:#f92672">=</span> $new_n<span style="color:#f92672">.</span>Int;
        }
    }
    %cache{$in} <span style="color:#f92672">=</span> @result <span style="color:#66d9ef">if</span> $in <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">200000</span>;
    <span style="color:#66d9ef">return</span> @result;
}

<span style="color:#66d9ef">my</span> @long_seqs;
<span style="color:#66d9ef">for</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">..</span><span style="color:#ae81ff">1000000</span> <span style="color:#f92672">-&gt;</span> $num {
    <span style="color:#66d9ef">my</span> $seq <span style="color:#f92672">=</span> collatz_seq $num;
    push @long_seqs, [ $num, $seq<span style="color:#f92672">.</span>elems] <span style="color:#66d9ef">if</span> $seq<span style="color:#f92672">.</span>elems <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">400</span>;
}
@long_seqs <span style="color:#f92672">=</span> sort { $<span style="color:#960050;background-color:#1e0010">^</span>b[<span style="color:#ae81ff">1</span>] <span style="color:#e6db74">&lt;=&gt;</span> $<span style="color:#960050;background-color:#1e0010">^</span>a[<span style="color:#ae81ff">1</span>]}, @long_seqs;
say  <span style="color:#e6db74">&#34;$_[0]: $_[1]&#34;</span> <span style="color:#66d9ef">for</span> @long_seqs[<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">19</span>];
</code></pre></div><p>This program displays the following output:</p>
<pre><code>$ perl6 collatz.p6
837799: 525
626331: 509
939497: 507
704623: 504
910107: 476
927003: 476
511935: 470
767903: 468
796095: 468
970599: 458
546681: 452
818943: 450
820022: 450
820023: 450
410011: 449
615017: 447
886953: 445
906175: 445
922524: 445
922525: 445
</code></pre>
<p>This program ran in more than 9 minutes. The equivalent Perl program ran in about  1 minute and 7.5 sec. So Raku is still significantly slower than Perl (at least for such CPU intensive computations). But we can improve it.</p>
<h3 id="extra-credit-revisited">Extra Credit Revisited</h3>
<h4 id="changing-the-caching-strategy-caching-sequence-lengths">Changing the Caching Strategy: Caching Sequence Lengths</h4>
<p>A couple of days after I submitted my challenge solution and published my original <a href="http://blogs.perl.org/users/laurent_r/2020/04/perl-weekly-challenge-54-k-th-permutation-sequence-and-the-collatz-conjecture.html">blog post</a>, it occurred to me that my program was doing far too much work: we&rsquo;re only requested to display the 20 numbers having the largest Collatz sequence. We could just memoize the length of each sequence, but we do not need to store the sequence itself. By doing that, we spare a lot of memory and can cache the result for many more numbers without exhausting the memory, and we also reduce significantly the overall overhead. In the program below we store the sequence lengths for numbers up to 2,000,000 (instead of 200,000 in the program above).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#66d9ef">use</span> v6;

<span style="color:#66d9ef">my</span> %cache <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">2</span>;

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">collatz</span>-seq (UInt $in) {
    <span style="color:#66d9ef">my</span> $length <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">my</span> $n <span style="color:#f92672">=</span> $in;
    <span style="color:#66d9ef">while</span> $n <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span> {
        <span style="color:#66d9ef">if</span> %cache{$n} :exists {
            $length <span style="color:#f92672">+=</span> %cache{$n};
            <span style="color:#66d9ef">last</span>;
        } <span style="color:#66d9ef">else</span> {
            <span style="color:#66d9ef">my</span> $new_n <span style="color:#f92672">=</span> $n % 2 ?? <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> $n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">!!</span> $n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
            $length<span style="color:#f92672">++</span>;
            %cache{$n} <span style="color:#f92672">=</span> %cache{$new_n} <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
            	<span style="color:#66d9ef">if</span> defined (%cache{$new_n}) <span style="color:#f92672">and</span> $new_n <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">2000000</span>;
            $n <span style="color:#f92672">=</span> $new_n<span style="color:#f92672">.</span>Int;
        }
    }
    %cache{$in} <span style="color:#f92672">=</span> $length <span style="color:#66d9ef">if</span> $in <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">2000000</span>;
    <span style="color:#66d9ef">return</span> $length;
}

<span style="color:#66d9ef">my</span> @long<span style="color:#f92672">-</span>seqs;
<span style="color:#66d9ef">for</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">..</span><span style="color:#ae81ff">1000000</span> <span style="color:#f92672">-&gt;</span> $num {
    <span style="color:#66d9ef">my</span> $seq<span style="color:#f92672">-</span>length <span style="color:#f92672">=</span> collatz<span style="color:#f92672">-</span>seq $num;
    push @long<span style="color:#f92672">-</span>seqs, [ $num, $seq<span style="color:#f92672">-</span>length] <span style="color:#66d9ef">if</span> $seq<span style="color:#f92672">-</span>length <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">400</span>;
}
@long<span style="color:#f92672">-</span>seqs <span style="color:#f92672">=</span> sort { $<span style="color:#960050;background-color:#1e0010">^</span>b[<span style="color:#ae81ff">1</span>] <span style="color:#e6db74">&lt;=&gt;</span> $<span style="color:#960050;background-color:#1e0010">^</span>a[<span style="color:#ae81ff">1</span>]}, @long<span style="color:#f92672">-</span>seqs;
say  <span style="color:#e6db74">&#34;$_[0]: $_[1]&#34;</span> <span style="color:#66d9ef">for</span> @long<span style="color:#f92672">-</span>seqs[<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">19</span>];
</code></pre></div><p>This new program displays the same output as the previous one, but runs about six times faster:</p>
<pre><code>$ time perl6 collatz2.p6
837799: 525
626331: 509
939497: 507
[Lines omitted for brevity]
906175: 445
922524: 445
922525: 445

real    1m31,660s
user    0m0,000s
sys     0m0,062s
</code></pre>
<h4 id="caching-in-an-array">Caching in an Array</h4>
<p>In our program above, the cache ends up with essentially one entry per input number in the 1..1_000_000 range (plus a relatively large quantity of numbers in the <code>1e6..2e6</code> range). So,  perhaps it might be better to use an array, rather than a hash, for the cache (accessing an array item should be significantly faster than a hash lookup, and our previous program does really a lot of these lookups).</p>
<p>This is the code for this new implementation:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#66d9ef">use</span> v6;

<span style="color:#66d9ef">my</span> @cache <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>;

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">collatz</span>-seq (UInt $in) {
    <span style="color:#66d9ef">my</span> $length <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">my</span> $n <span style="color:#f92672">=</span> $in;
    <span style="color:#66d9ef">while</span> $n <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span> {
        <span style="color:#66d9ef">if</span> defined @cache[$n] {
            $length <span style="color:#f92672">+=</span> @cache[$n];
            <span style="color:#66d9ef">last</span>;
        } <span style="color:#66d9ef">else</span> {
            <span style="color:#66d9ef">my</span> $new_n <span style="color:#f92672">=</span> $n % 2 ?? <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> $n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">!!</span> $n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
            $length<span style="color:#f92672">++</span>;
            @cache[$n] <span style="color:#f92672">=</span> @cache[$new_n] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
                <span style="color:#66d9ef">if</span> defined @cache[$new_n] <span style="color:#f92672">and</span> $new_n <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">2000000</span>;
            $n <span style="color:#f92672">=</span> $new_n<span style="color:#f92672">.</span>Int;
        }
    }
    @cache[$in] <span style="color:#f92672">=</span> $length;
    <span style="color:#66d9ef">return</span> $length;
}

<span style="color:#66d9ef">my</span> @long<span style="color:#f92672">-</span>seqs;
<span style="color:#66d9ef">for</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">..</span><span style="color:#ae81ff">1000000</span> <span style="color:#f92672">-&gt;</span> $num {
    <span style="color:#66d9ef">my</span> $seq<span style="color:#f92672">-</span>length <span style="color:#f92672">=</span> collatz<span style="color:#f92672">-</span>seq $num;
    push @long<span style="color:#f92672">-</span>seqs, [ $num, $seq<span style="color:#f92672">-</span>length] <span style="color:#66d9ef">if</span> $seq<span style="color:#f92672">-</span>length <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">200</span>;
}
@long<span style="color:#f92672">-</span>seqs <span style="color:#f92672">=</span> sort { $<span style="color:#960050;background-color:#1e0010">^</span>b[<span style="color:#ae81ff">1</span>] <span style="color:#e6db74">&lt;=&gt;</span> $<span style="color:#960050;background-color:#1e0010">^</span>a[<span style="color:#ae81ff">1</span>]}, @long<span style="color:#f92672">-</span>seqs;
say  <span style="color:#e6db74">&#34;$_[0]: $_[1]&#34;</span> <span style="color:#66d9ef">for</span> @long<span style="color:#f92672">-</span>seqs[<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">19</span>];
</code></pre></div><p>This new program runs about twice faster than the previous one (and 12 times faster than the original one):</p>
<pre><code>$ time ./perl6 collatz3.p6
837799: 525
626331: 509
[Lines omitted for brevity]
922524: 445
922525: 445

real    0m45,218s
user    0m0,000s
sys     0m0,093s
</code></pre>
<h4 id="further-optimizations">Further Optimizations</h4>
<p>It turns out that unsigned integers (<code>UInt</code>) are slower than regular integers (<code>Int</code>). Changing the <code>collatz-seq</code> signature to:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">collatz</span>-seq (Int $in) {
</code></pre></div><p>improves the duration by about 14%:</p>
<pre><code>real    0m38,944s
user    0m0,015s
sys     0m0,061s
</code></pre>
<p>Using a native <code>int</code> makes the program only very slightly, but not significantly, faster:</p>
<pre><code>real    0m38,580s
user    0m0,000s
sys     0m0,062s
</code></pre>
<p>On April 5, 2020 (one day after my original blog post), <a href="https://www.perlmonks.org/?node_id=1130276">1nick</a> published a very interesting <a href="https://www.perlmonks.org/?node_id=11115088">message</a> on the Perl Monks forum in which he presented another strategy for the Perl version of my program: parallelizing the process using <a href="https://metacpan.org/pod/MCE%3A%3AMap">MCE::Map</a> Each worker is handed only the beginning and end of the chunk of the sequence it will process, and workers communicate amongst themselves to keep track of the overall task. With this change (and no caching), this program ran 5 times faster, on a 12-core machine (the full program is presented in Nick&rsquo;s post). Following that initial post, an extremely interesting discussion emerged between Nick and several other Perl Monks.  I really cannot summarize this discussion here, just follow the link if you&rsquo;re interested (it&rsquo;s really worth the effort). In the context of this discussion, another Perl monk, <a href="https://www.perlmonks.org/?node_id=1005295">Mario Roy</a>, the person who wrote the <a href="https://metacpan.org/pod/MCE%3A%3AMap">MCE::Map</a> used by Nick and a number of other very useful Perl modules for parallel processing, suggested three further optimizations to the Perl version of the program:</p>
<p><em>1. Replaced division by 2.</em></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl">    $n <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>;
</code></pre></div><p><em>2. Removed one level of branching.</em></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl">    <span style="color:#66d9ef">while</span> ($n <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>) {
        $result <span style="color:#f92672">+=</span> $cache[$n], <span style="color:#66d9ef">last</span>
            <span style="color:#66d9ef">if</span> defined $cache[$n];

        <span style="color:#66d9ef">my</span> $new_n <span style="color:#f92672">=</span> $n % 2 ? <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> $n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> : $n <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>;
        $result<span style="color:#f92672">++</span>;
        $cache[$n] <span style="color:#f92672">=</span> $cache[$new_n] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">if</span> defined $cache[$new_n] <span style="color:#f92672">and</span> $n <span style="color:#f92672">&lt;</span> $max;

        $n <span style="color:#f92672">=</span> $new_n;
    }
</code></pre></div><p><em>3. Lastly, reduced the number of loop iterations.</em></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl">    <span style="color:#66d9ef">while</span> ($n <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>) {
        $result <span style="color:#f92672">+=</span> $cache[$n], <span style="color:#66d9ef">last</span>
            <span style="color:#66d9ef">if</span> defined $cache[$n];

        $n % 2 ? ( $result <span style="color:#f92672">+=</span> <span style="color:#ae81ff">2</span>, $new_n <span style="color:#f92672">=</span> (<span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> $n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span> )
               : ( $result <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>, $new_n <span style="color:#f92672">=</span> $n <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span> );

        $cache[$n] <span style="color:#f92672">=</span> $cache[$new_n] <span style="color:#f92672">+</span> ($n % 2 ? <span style="color:#ae81ff">2</span> : <span style="color:#ae81ff">1</span>)
            <span style="color:#66d9ef">if</span> defined $cache[$new_n] <span style="color:#f92672">and</span> $n <span style="color:#f92672">&lt;</span> $max;
        $n <span style="color:#f92672">=</span> $new_n;
    }
</code></pre></div><p>Let&rsquo;s try to port these optimizations to our Raku program one by one.</p>
<p>Using the bit shift operator:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">my</span> $new_n <span style="color:#f92672">=</span> $n % 2 ?? <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> $n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">!!</span> $n <span style="color:#f92672">+&gt;</span> <span style="color:#ae81ff">1</span>;
</code></pre></div><p>provides a significant performance boost (33%):</p>
<pre><code>real    0m25,800s
user    0m0,015s
sys     0m0,030s
</code></pre>
<p>This really surprised me. I had stopped doing this type of low-level optimizations several decades ago, when I figured that the C compiler I was using at the time was doing this type of optimization at least as well and often better than I was able to do. Quite obviously, it is worth the effort in Raku.</p>
<p>The next optimization in Mario&rsquo;s list is to remove one level of branching:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl">    <span style="color:#66d9ef">while</span> $n <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span> {
        $length <span style="color:#f92672">+=</span> @cache[$n], <span style="color:#66d9ef">last</span> <span style="color:#66d9ef">if</span> defined @cache[$n];
        <span style="color:#66d9ef">my</span> $new_n <span style="color:#f92672">=</span> $n % 2 ?? <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> $n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">!!</span> $n <span style="color:#f92672">+&gt;</span> <span style="color:#ae81ff">1</span>;
        $length<span style="color:#f92672">++</span>;
        @cache[$n] <span style="color:#f92672">=</span> @cache[$new_n] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">if</span> defined @cache[$new_n] <span style="color:#f92672">and</span> $new_n <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">2000000</span>;
        $n <span style="color:#f92672">=</span> $new_n<span style="color:#f92672">.</span>Int;
    }
</code></pre></div><p>but that did not bring any performance improvement in my tests with Raku. So, let&rsquo;s forget it.</p>
<p>Another performance optimization is that caching <code>$n</code> within the <code>while</code> loop actually hampers performance. This originally surprised both Mario and myself.  I guess that this is presumably because the cache hit/miss ratio in this part of the code is probably quite low. Let&rsquo;s comment out that statement. So, with this new <code>while</code> loop:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6">    <span style="color:#66d9ef">while</span> $n <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span> {
        <span style="color:#66d9ef">if</span> defined @cache[$n] {
            $length <span style="color:#f92672">+=</span> @cache[$n];
            <span style="color:#66d9ef">last</span>;
        } <span style="color:#66d9ef">else</span> {
            <span style="color:#66d9ef">my</span> $new_n <span style="color:#f92672">=</span> $n % 2 ?? <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> $n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">!!</span> ($n <span style="color:#f92672">+&gt;</span> <span style="color:#ae81ff">1</span>);
            $length<span style="color:#f92672">++</span>;
            <span style="color:#75715e"># @cache[$n] = @cache[$new_n] + 1</span>
            <span style="color:#75715e"># 	 if defined @cache[$new_n] and $new_n &lt;= 2000000;</span>
            $n <span style="color:#f92672">=</span> $new_n<span style="color:#f92672">.</span>Int;
        }
    }
</code></pre></div><p>we shave off five additional seconds (20%):</p>
<pre><code>real    0m20,822s
user    0m0,000s
sys     0m0,062s
</code></pre>
<p>If we remove the two lines commented out above, then we can simplify a bit the code, because we no longer need the temporary <code>$new_n</code> variable. But since that&rsquo;s just a code simplification, not a performance improvement, we&rsquo;ll show that change in the context of the next step.</p>
<p>The next optimization in Mario&rsquo;s list is to reduce the number of loop iterations: when a number is odd, we apply the formula <code>(3 * $n + 1)</code> (leading necessarily to an even number) and perform the division by 2 immediately (and add 2 to <code>$length</code>). We also remove the conversion of $new_n to an integer, as this was useful in some early version of the program (only to prevent a type mismatch), but is no longer needed. The full program now looks as follows:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#66d9ef">use</span> v6;

<span style="color:#66d9ef">my</span> @cache <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>;

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">collatz</span>-seq (int $in) {
    <span style="color:#66d9ef">my</span> $length <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">my</span> $n <span style="color:#f92672">=</span> $in;
    <span style="color:#66d9ef">while</span> $n <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span> {
        <span style="color:#66d9ef">if</span> defined @cache[$n] {
            $length <span style="color:#f92672">+=</span> @cache[$n];
            <span style="color:#66d9ef">last</span>;
        } <span style="color:#66d9ef">else</span> {
            <span style="color:#66d9ef">if</span> $n % 2 {
                $n <span style="color:#f92672">=</span> (<span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> $n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">+&gt;</span> <span style="color:#ae81ff">1</span>;
                $length <span style="color:#f92672">+=</span> <span style="color:#ae81ff">2</span>;
            } <span style="color:#66d9ef">else</span> {
                $n <span style="color:#f92672">=</span> $n <span style="color:#f92672">+&gt;</span> <span style="color:#ae81ff">1</span>;
                $length<span style="color:#f92672">++</span>;
            }
        }
    }
    @cache[$in] <span style="color:#f92672">=</span> $length;
    <span style="color:#66d9ef">return</span> $length;
}

<span style="color:#66d9ef">my</span> @long<span style="color:#f92672">-</span>seqs;
<span style="color:#66d9ef">for</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">..</span><span style="color:#ae81ff">1000000</span> <span style="color:#f92672">-&gt;</span> $num {
    <span style="color:#66d9ef">my</span> $seq<span style="color:#f92672">-</span>length <span style="color:#f92672">=</span> collatz<span style="color:#f92672">-</span>seq $num;
    push @long<span style="color:#f92672">-</span>seqs, [ $num, $seq<span style="color:#f92672">-</span>length] <span style="color:#66d9ef">if</span> $seq<span style="color:#f92672">-</span>length <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">200</span>;
}
@long<span style="color:#f92672">-</span>seqs <span style="color:#f92672">=</span> sort { $<span style="color:#960050;background-color:#1e0010">^</span>b[<span style="color:#ae81ff">1</span>] <span style="color:#e6db74">&lt;=&gt;</span> $<span style="color:#960050;background-color:#1e0010">^</span>a[<span style="color:#ae81ff">1</span>]}, @long<span style="color:#f92672">-</span>seqs;
say  <span style="color:#e6db74">&#34;$_[0]: $_[1]&#34;</span> <span style="color:#66d9ef">for</span> @long<span style="color:#f92672">-</span>seqs[<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">19</span>];
</code></pre></div><p>The duration of the execution is reduced by another 6 seconds (about 30%):</p>
<pre><code>$ time perl6 collatz4.p6
837799: 525
626331: 509
[Lines omitted for brevity]
922524: 445
922525: 445

real    0m14,470s
user    0m0,015s
sys     0m0,046s
</code></pre>
<p>Taken together, these &ldquo;micro-optimizations&rdquo; reduce the execution duration from 45.2 seconds to 14.5 seconds, i.e. 3 times less time. They&rsquo;re well worth the effort, after all.</p>
<p>Since the use of the bit shift operator for the division by 2 offered some significant improvement, I tried to introduce it for the divisibility by 2 test:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl">            <span style="color:#66d9ef">if</span> $n <span style="color:#f92672">+&amp;</span> <span style="color:#ae81ff">1</span> {
                $n <span style="color:#f92672">=</span> (<span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> $n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">+&gt;</span> <span style="color:#ae81ff">1</span>;
                $length <span style="color:#f92672">+=</span> <span style="color:#ae81ff">2</span>;
            } <span style="color:#66d9ef">else</span> { <span style="color:#75715e"># ...</span>
</code></pre></div><p>This brought some additional improvement, but only to a very limited extent (5%):</p>
<pre><code>real    0m13,805s
user    0m0,000s
sys     0m0,077s
</code></pre>
<p>I doubt it is worth the effort, as it makes the code less easy to understand to most people (notably myself: I use those operators so rarely in Perl or in Raku, that I have to look them up in the documentation whenever I see them).</p>
<p>Since, we know that the smallest of our top-ten sequence lengths is 445, we can store in <code>@long-seqs</code> only the sequence lengths larger than 400 (instead of 200 in our code above):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl">    push @long<span style="color:#f92672">-</span>seqs, [ $num, $seq<span style="color:#f92672">-</span>length] <span style="color:#66d9ef">if</span> $seq<span style="color:#f92672">-</span>length <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">400</span>;
</code></pre></div><p>The result seems quite impressive, as we shave off another 5,67 seconds:</p>
<pre><code>real    0m8,810s
user    0m0,000s
sys     0m0,062s
</code></pre>
<p>This looks like an additional 39% improvement, but it is misleading and not really meaningful to express this improvement as a percentage, because we are optimizing here another part of the program, i.e. the final section sorting the results to find the 20 longest sequences, which we hadn&rsquo;t tried to optimize before. If we had done that change in the version of our earlier program presented in the <em>Caching in an Array</em> section above, which lasted 45 seconds, we would also have won 5 to 6 seconds, and our gain would have been only about 10 or 11% of the overall duration. The gain due to this change becomes significant here only because we have so much optimized the other section of the program (the part computing the Collatz sequences) that this final section of the program now accounts for a significant part of the overall duration, where as it was somewhat marginal before.</p>
<p>The next step might be to take advantage of Raku&rsquo;s rich parallel processing capabilities, but I haven&rsquo;t looked at them seriously for at least 4 years and it would take me too long to get back into them and quickly make something really efficient here. Well, to tell the truth, I have quickly tried to use the <code>race</code> and <code>hyper</code> methods, just as an experiment, the computation result was correct (which almost and pleasantly surprised me), but the program ran 30% slower. I intend to investigate further, but at a later point, not in the context of this blog post.</p>
<p>Anyway, it is clear to me that, in this case, a good caching strategy brings a better performance improvement than parallel processing will ever be able to do on my poor four-core computer. But the best of course would be both. So what would be needed for parallel processing to bring further improvement is something that combines efficiently caching and multi-threading. It may not be very easy (sharing a cache between threads looks a bit complicated), but my gut feeling is that it can probably be done. Mario Roy was able to do it in Perl using the <a href="https://metacpan.org/pod/File::Map">File::Map module</a> that makes it possible to share the cache between the threads, as explained in my <a href="http://blogs.perl.org/users/laurent_r/2020/04/revisiting-the-collatz-sequence-pwc-54.html">follow-up post</a> about the Collatz sequence in Perl. As I just said, I&rsquo;ll try to look into that, but that may well take some weeks.</p>
<h2 id="alternative-solutions">Alternative Solutions</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/arne-sommer/raku/ch-2.p6">Arne Sommer</a> used the <code>gather...take</code> construct to solve the basic task.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl">unit <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">MAIN</span> (Int $start where $start &gt;= 1);

my $sequence := gather
{
  take $start;
  <span style="color:#66d9ef">my</span> $prev <span style="color:#f92672">=</span> $start;

  loop
  {
    <span style="color:#66d9ef">last</span> <span style="color:#66d9ef">if</span> $prev <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">my</span> $new <span style="color:#f92672">=</span> $prev %% 2 ?? $prev <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">!!</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> $prev <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
    $prev <span style="color:#f92672">=</span> $new;
    take $new;
  }
}

say $sequence<span style="color:#f92672">.</span>join(<span style="color:#e6db74">&#34;, &#34;</span>);
</code></pre></div><p>Arne also provided a solution for the &ldquo;extra credit&rdquo; case:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl">unit <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">MAIN</span> (Int $limit = 1_000_000, :$verbose, :$chop = 20);

my %length;
for 1 .. $limit
{
  <span style="color:#66d9ef">my</span> @list <span style="color:#f92672">=</span>  collatz($_);
  %length{@list<span style="color:#f92672">.</span>elems}<span style="color:#f92672">.</span>push($_);
  say <span style="color:#e6db74">&#34;_ $_ -&gt; @list[]&#34;</span> <span style="color:#66d9ef">if</span> $verbose;
}
<span style="color:#66d9ef">my</span> $count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#66d9ef">my</span> $elems;
<span style="color:#66d9ef">for</span> %length<span style="color:#f92672">.</span>keys<span style="color:#f92672">.</span>sort({ $<span style="color:#960050;background-color:#1e0010">^</span>b <span style="color:#e6db74">&lt;=&gt;</span> $<span style="color:#960050;background-color:#1e0010">^</span>a }) <span style="color:#f92672">-&gt;</span> $l
{
  $elems <span style="color:#f92672">=</span> %length{$l};
  <span style="color:#66d9ef">for</span> @$elems
  {
    <span style="color:#66d9ef">last</span> <span style="color:#66d9ef">if</span> $count<span style="color:#f92672">++</span> <span style="color:#f92672">&gt;=</span> $chop;
    say <span style="color:#e6db74">&#34;{ $count }: Number $_ (with length $l)&#34;</span>;
  }
}

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">collatz</span> ($start)
{
  <span style="color:#66d9ef">my</span> $sequence :<span style="color:#f92672">=</span> gather
  {
    take $start;
    <span style="color:#66d9ef">my</span> $prev <span style="color:#f92672">=</span> $start;
    loop
    {
      <span style="color:#66d9ef">last</span> <span style="color:#66d9ef">if</span> $prev <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>;
      <span style="color:#66d9ef">my</span> $new <span style="color:#f92672">=</span> $prev %% 2 ?? $prev <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">!!</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> $prev <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
      $prev <span style="color:#f92672">=</span> $new;
      take $new;
    }
  }
  <span style="color:#66d9ef">return</span> $sequence;
}
</code></pre></div><p>So, Arne did not try any caching and just implemented the <code>1..1e6</code> range by inserting his code into an outer loop over the range. His program ran in 21 minutes on his PC.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/ben-davies/raku/ch-2.p6">Ben Davies</a> implemented a simple <code>collatz</code> subroutine to compute the next item in a Collatz sequence:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">collatz</span>(Int:D $n --&gt; Int:D) { $n %% 2 ?? $n div <span style="color:#ae81ff">2</span> <span style="color:#f92672">!!</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> $n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> }
</code></pre></div><p>His extra credit implementation uses <code>react</code> and <code>emit</code>with supplies to use some of the parallel processing capabilities of Raku:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl">unit proto <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">MAIN</span>(|) {<span style="color:#f92672">*</span>}
multi <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">MAIN</span>(Int:D $n where * &gt;= 1) {
    <span style="color:#f92672">.</span>say <span style="color:#66d9ef">for</span> ($n,<span style="color:#f92672">&amp;</span>collatz<span style="color:#f92672">...</span><span style="color:#ae81ff">1</span>);
}
multi <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">MAIN</span>(Bool:D :extra-credit($)!) {
    react whenever supply <span style="color:#66d9ef">for</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">..</span><span style="color:#ae81ff">1_000_000</span> {
        emit ($_,<span style="color:#f92672">&amp;</span>collatz<span style="color:#f92672">...</span><span style="color:#ae81ff">1</span>);
    }<span style="color:#f92672">.</span>map({
        @<span style="color:#960050;background-color:#1e0010">^</span>collatz<span style="color:#f92672">.</span>head <span style="color:#f92672">=&gt;</span> @<span style="color:#960050;background-color:#1e0010">^</span>collatz<span style="color:#f92672">.</span>elems
    })<span style="color:#f92672">.</span>sort({
        $<span style="color:#960050;background-color:#1e0010">^</span>a<span style="color:#f92672">.</span>value <span style="color:#f92672">&lt;</span> $<span style="color:#960050;background-color:#1e0010">^</span>b<span style="color:#f92672">.</span>value
    })<span style="color:#f92672">.</span>head(<span style="color:#ae81ff">20</span>) {
        once printf <span style="color:#e6db74">&#34;%-7s %s$?NL&#34;</span>, <span style="color:#e6db74">&#39;Value&#39;</span>, <span style="color:#e6db74">&#39;Elements&#39;</span>;
        printf <span style="color:#e6db74">&#34;%-7d %d$?NL&#34;</span>, <span style="color:#f92672">.</span>key, <span style="color:#f92672">.</span>value;
    }
}
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">collatz</span>(Int:D $n --&gt; Int:D) { $n %% 2 ?? $n div <span style="color:#ae81ff">2</span> <span style="color:#f92672">!!</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> $n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> }
</code></pre></div><p>I don’t know how well it performs.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/kevin-colyer/raku/ch-2.p6">Kevin Colyer</a> wrote a <code>collatzSeqChain</code> subroutine to find Collatz sequence for a given number:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">collatzSeqChain</span>(Int $n is copy) {
    <span style="color:#66d9ef">my</span> Str $seq <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;$n&#34;</span>;
    <span style="color:#66d9ef">while</span> $n <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span> {
        <span style="color:#66d9ef">if</span> $n <span style="color:#f92672">+&amp;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
            $n<span style="color:#f92672">=</span> $n <span style="color:#f92672">+&gt;</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e"># (1)</span>
        } <span style="color:#66d9ef">else</span> {
            $n <span style="color:#f92672">=</span> $n <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
        }
        $seq <span style="color:#f92672">~=</span> <span style="color:#e6db74">&#34; -&gt; $n&#34;</span>;
    }
    <span style="color:#66d9ef">return</span> $seq;
}
</code></pre></div><p>Note that Kevin is using the <code>+&gt;</code> <em>bit shift</em> and <code>+&amp;</code> <em>bitwise and</em> operators to speed up the subroutine.</p>
<p>For the extra credit part, Kevin is caching the length of the sequences:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">collatzSeqLen</span>(Int $number) returns Int {
    state Int @length;
    <span style="color:#66d9ef">my</span> Int $n<span style="color:#f92672">=</span>$number;
    <span style="color:#66d9ef">my</span> Int $len<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">my</span> Str $seq <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;$n&#34;</span>;
    <span style="color:#66d9ef">while</span> $n <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span> {
        <span style="color:#66d9ef">if</span> @length[$n]:exists {
            $len <span style="color:#f92672">+=</span> @length[$n];
            <span style="color:#66d9ef">last</span>;
        }
        <span style="color:#66d9ef">if</span> $n <span style="color:#f92672">+&amp;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
            $n <span style="color:#f92672">=</span> $n <span style="color:#f92672">+&gt;</span> <span style="color:#ae81ff">1</span>;
        } <span style="color:#66d9ef">else</span> {
            $n <span style="color:#f92672">=</span> $n <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
        }
        $len<span style="color:#f92672">++</span>;
    }
    @length[$number]<span style="color:#f92672">=</span>$len;
    <span style="color:#66d9ef">return</span> $len;
}

multi MAIN (<span style="color:#e6db74">&#39;top&#39;</span>,  Int :$number<span style="color:#f92672">=</span><span style="color:#ae81ff">10_000</span>, Int :$want<span style="color:#f92672">=</span><span style="color:#ae81ff">20</span>) {

    die <span style="color:#e6db74">&#34;Longest chainst WANTed [$want] must be &gt; number in sequence [$number]&#34;</span> <span style="color:#66d9ef">if</span> $want <span style="color:#f92672">&gt;=</span> $number;

    <span style="color:#66d9ef">my</span> Int @chain <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">my</span> Int $topMin <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">my</span> Int @top;
    <span style="color:#66d9ef">my</span> Int @topN;
    <span style="color:#66d9ef">my</span> %ltoi;
    <span style="color:#66d9ef">my</span> $t <span style="color:#f92672">=</span> now<span style="color:#f92672">.</span>Int;
    <span style="color:#66d9ef">my</span> Int $x <span style="color:#f92672">=</span> $number;
    <span style="color:#66d9ef">my</span> Int $l;

    <span style="color:#66d9ef">for</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$x <span style="color:#f92672">-&gt;</span> Int $i {
        $l <span style="color:#f92672">=</span> collatzSeqLen($i);

        <span style="color:#66d9ef">next</span> <span style="color:#66d9ef">if</span> $l <span style="color:#f92672">&lt;</span> $topMin;
        <span style="color:#66d9ef">next</span> <span style="color:#66d9ef">if</span> $l <span style="color:#f92672">==</span> any @top;

        %ltoi{$l} <span style="color:#f92672">=</span> $i;

        @top<span style="color:#f92672">.</span>push: $l;
        @top<span style="color:#f92672">.=</span>sort;
        @top<span style="color:#f92672">.</span>shift <span style="color:#66d9ef">if</span> @top<span style="color:#f92672">.</span>elems <span style="color:#f92672">&gt;</span> $want;
        $topMin <span style="color:#f92672">=</span> @top[<span style="color:#ae81ff">0</span>];
    }

    @top<span style="color:#f92672">.</span>map({ <span style="color:#e6db74">&#34;\n{%ltoi{$_}} length $_ = \n&#34;</span><span style="color:#f92672">~</span>collatzSeqChain( %ltoi{$_} )  })<span style="color:#f92672">&gt;&gt;.</span>say;
    say <span style="color:#e6db74">&#34;\n$x sequences searched in {Rat(now -$t)} seconds&#34;</span>;
}
</code></pre></div><p>On his machine, the code ran in a bit more than 17 seconds. That&rsquo;s pretty good performance, I&rsquo;m impressed.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/luca-ferrari/raku/ch-2.p6">Luca Ferrari</a> wrote a <code>collatz</code> subroutine returning the Collatz sequence for the input number:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">collatz</span>( Int:D $m ) {
    <span style="color:#66d9ef">my</span> @sequence;
    <span style="color:#66d9ef">my</span> $n <span style="color:#f92672">=</span> $m;
    <span style="color:#66d9ef">while</span> ( $n <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span> ) {
        <span style="color:#66d9ef">if</span> ( $n %% 2 ) {
            $n <span style="color:#f92672">/=</span> <span style="color:#ae81ff">2</span>;
        }
        <span style="color:#66d9ef">else</span> {
            $n <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> $n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
        }

        @sequence<span style="color:#f92672">.</span>push: $n;
    }

    @sequence;
}
</code></pre></div><p>Luca also has code for the extra credit:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#75715e"># extra credit</span>
<span style="color:#66d9ef">my</span> %extra;
<span style="color:#66d9ef">for</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> <span style="color:#ae81ff">100000</span> {
    %extra{ $_ } <span style="color:#f92672">=</span> collatz( $_ )<span style="color:#f92672">.</span>elems;
}

<span style="color:#75715e"># sort by the length</span>
<span style="color:#75715e"># prints 20 most length sequences data</span>
<span style="color:#66d9ef">for</span> %extra<span style="color:#f92672">.</span>sort( { $<span style="color:#960050;background-color:#1e0010">^</span>b<span style="color:#f92672">.</span>value <span style="color:#e6db74">&lt;=&gt;</span> $<span style="color:#960050;background-color:#1e0010">^</span>a<span style="color:#f92672">.</span>value } )[<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">20</span>] <span style="color:#f92672">-&gt;</span> $p {
    <span style="color:#e6db74">&#34;Number {$p.key} produces a Collatz sequence of {$p.value} numbers length&#34;</span><span style="color:#f92672">.</span>say;
}
</code></pre></div><p>One very small error is that the program actually prints 21 sequence lengths. The more serious issue is that Luca&rsquo;s program compute the sequence lengths between 1 and 100,000, not 1,000,000. And its execution lasts 52 seconds on my computer. So, with the correct input range, it would probably take more than 10 minutes. In addition, it seems that Luca&rsquo;s sequence lengths are off by one, but, after careful examination, it turns out that it is because the <code>collatz</code> subroutine returns the sequence without the original input number. In other words, Luca doesn&rsquo;t count the input number to be part of the sequence. That&rsquo;s a possible interpretation, but that&rsquo;s not what the task specification called for.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/mark-anderson/raku/ch-2.p6">Mark Anderson</a> used two multi <code>MAIN</code> subroutines, one taking one numeric argument for computing the sequence for a single input number, and the other with no argument for the extra credit. The extra credit version uses a hash to cache the sequence lengths:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6">multi <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">MAIN</span> {
    <span style="color:#66d9ef">my</span> $t <span style="color:#f92672">=</span> now;

    <span style="color:#66d9ef">my</span> %seen;
    %seen{<span style="color:#ae81ff">1</span>} <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">my</span> @collatz <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">1</span>) xx <span style="color:#ae81ff">20</span>;

    <span style="color:#66d9ef">for</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> <span style="color:#ae81ff">1e6</span>) <span style="color:#f92672">-&gt;</span> $start {
        <span style="color:#66d9ef">my</span> $n <span style="color:#f92672">=</span> $start;
        <span style="color:#66d9ef">my</span> $length <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

        loop {
            <span style="color:#66d9ef">if</span> %seen{$n}:exists {
                %seen{$start} <span style="color:#f92672">=</span> %seen{$n} <span style="color:#f92672">+</span> $length;

                <span style="color:#66d9ef">if</span> @collatz[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>value <span style="color:#f92672">&lt;=</span> %seen{$start} {
                    @collatz<span style="color:#f92672">.</span>shift;
                    @collatz<span style="color:#f92672">.</span>push($start <span style="color:#f92672">=&gt;</span> %seen{$start});
                    @collatz <span style="color:#f92672">=</span> @collatz<span style="color:#f92672">.</span>sort({$<span style="color:#960050;background-color:#1e0010">^</span>a<span style="color:#f92672">.</span>value <span style="color:#e6db74">&lt;=&gt;</span> $<span style="color:#960050;background-color:#1e0010">^</span>b<span style="color:#f92672">.</span>value});
                }

                <span style="color:#66d9ef">last</span>;
            }

            $n <span style="color:#f92672">=</span> $n %% 2 ?? $n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">!!</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> $n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
            $length<span style="color:#f92672">++</span>;
        }
    }

    <span style="color:#f92672">.</span>say <span style="color:#66d9ef">for</span> @collatz;

    say now <span style="color:#f92672">-</span> $t;
}
</code></pre></div><p>Mark reports an execution time of 95 seconds on his computer (800 seconds without the cache and without a couple of other optimizations).</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/noud/raku/ch-2.p6">Noud Aldenhoven</a> used a recursive <code>collatz-seq</code> subroutine to compute the Collatz sequence for one input number:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">collatz</span>-seq($n) {
    <span style="color:#66d9ef">if</span> ($n <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
        [<span style="color:#ae81ff">1</span>];
    } <span style="color:#66d9ef">elsif</span> ($n % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
        [$n, <span style="color:#f92672">|</span>(collatz<span style="color:#f92672">-</span>seq($n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>))];
    } <span style="color:#66d9ef">else</span> {
        [$n, <span style="color:#f92672">|</span>(collatz<span style="color:#f92672">-</span>seq(<span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> $n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>))];
    }
}
</code></pre></div><p>For the extra credit, Noud used the <code>is cached</code> experimental trait, along with multi-threading (using channels):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#66d9ef">use</span> experimental :cached;  <span style="color:#75715e"># My favourite Raku feature!</span>

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">collatz</span>-length($n) is cached {
    <span style="color:#66d9ef">if</span> ($n <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
        <span style="color:#ae81ff">0</span>;
    } <span style="color:#66d9ef">elsif</span> ($n % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
        collatz<span style="color:#f92672">-</span>length($n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
    } <span style="color:#66d9ef">else</span> {
        collatz<span style="color:#f92672">-</span>length(<span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> $n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
    }
}

<span style="color:#66d9ef">my</span> $collatz<span style="color:#f92672">-</span>list <span style="color:#f92672">=</span> Channel<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>;
await (<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span><span style="color:#ae81ff">1e6</span>)<span style="color:#f92672">.</span>map: <span style="color:#f92672">-&gt;</span> $n {
    start {
        $collatz<span style="color:#f92672">-</span>list<span style="color:#f92672">.</span>send((collatz<span style="color:#f92672">-</span>length($n), $n));
    }
}
$collatz<span style="color:#f92672">-</span>list<span style="color:#f92672">.</span>close();

<span style="color:#66d9ef">for</span> $collatz<span style="color:#f92672">-</span>list<span style="color:#f92672">.</span>list<span style="color:#f92672">.</span>sort<span style="color:#f92672">.</span>tail(<span style="color:#ae81ff">20</span>) <span style="color:#f92672">-&gt;</span> ($l, $n) {
    say $n, <span style="color:#e6db74">&#39; &#39;</span>, $l;
}
</code></pre></div><p>In the comments of his program, Noud said that he was surprised that caching works well with multi-threading. I&rsquo;m not sure that it works so well as he claims, since he also said that his program runs in half an hour. I don&rsquo;t have time to test right now, but it would be interesting to test caching and multi-threading separately.</p>
<p>Note that Noud apparently has the same interpretation as Luca Ferrari: his sequence lengths are off by one (in other words, he doesn&rsquo;t consider the input number to be part of the sequence).</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/simon-proctor/raku/ch-2.p6">Simon Proctor</a> implemented the formulas for the Collatz sequence using two multi subroutines:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6">multi <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">collatz</span>( UInt \n where { n %% 2 } ) { n div <span style="color:#ae81ff">2</span>; }

multi <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">collatz</span>( UInt \n where { n <span style="color:#f92672">!</span>%% 2 } ) { (<span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> n) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; }
</code></pre></div><p>Simon used parallel processing (with promises) for the extra credit:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6">multi <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">MAIN</span>( Bool :v(:$verbose)=False){
    constant MAX<span style="color:#f92672">-</span>VALUE <span style="color:#f92672">=</span> <span style="color:#ae81ff">1000000</span>;

    <span style="color:#66d9ef">my</span> <span style="color:#f92672">\</span>batch<span style="color:#f92672">-</span>size <span style="color:#f92672">=</span> MAX<span style="color:#f92672">-</span>VALUE div <span style="color:#ae81ff">10</span>;

    <span style="color:#66d9ef">my</span> @promises;
    <span style="color:#66d9ef">my</span> $start <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;

    <span style="color:#66d9ef">for</span> (<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span><span style="color:#ae81ff">10</span>) {
        <span style="color:#66d9ef">my</span> $s <span style="color:#f92672">=</span> $start;
        <span style="color:#66d9ef">my</span> $e <span style="color:#f92672">=</span> $start<span style="color:#f92672">+</span>batch<span style="color:#f92672">-</span>size<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
        @promises<span style="color:#f92672">.</span>push( start chain<span style="color:#f92672">-</span>batch($s,$e,$verbose) );
        $start<span style="color:#f92672">+=</span>batch<span style="color:#f92672">-</span>size;
    }

    await @promises;

    <span style="color:#66d9ef">my</span> @largest <span style="color:#f92672">=</span> @promises<span style="color:#f92672">.</span>map( <span style="color:#f92672">|*.</span>result )<span style="color:#f92672">.</span>sort({$<span style="color:#960050;background-color:#1e0010">^</span>b<span style="color:#f92672">.</span>elems <span style="color:#e6db74">&lt;=&gt;</span> $<span style="color:#960050;background-color:#1e0010">^</span>a<span style="color:#f92672">.</span>elems})<span style="color:#f92672">.</span>[<span style="color:#f92672">^</span><span style="color:#ae81ff">20</span>];

    <span style="color:#f92672">.</span>say <span style="color:#66d9ef">for</span> @largest<span style="color:#f92672">.</span>map( { <span style="color:#e6db74">&#34;{$_.join(&#34;</span><span style="color:#f92672">-&gt;</span><span style="color:#e6db74">&#34;)} : {$_.elems} steps&#34;</span> } );
}

multi <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">chain</span>( 1 ) { <span style="color:#ae81ff">1</span> }

multi <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">chain</span>( UInt \n where { n %% 2 } ) is pure { ( n, <span style="color:#f92672">|</span>chain( n div <span style="color:#ae81ff">2</span> ) ); }

multi <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">chain</span>( UInt \n where { n <span style="color:#f92672">!</span>%% 2 <span style="color:#f92672">&amp;&amp;</span> n <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span> } ) is pure { ( n, <span style="color:#f92672">|</span>chain( (<span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> n) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> ) ); }


<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">chain</span>-batch( UInt $start is copy, UInt $end is copy, Bool \verbose ) {
    <span style="color:#66d9ef">my</span> @largest <span style="color:#f92672">=</span> <span style="color:#f92672">[]</span>;
    <span style="color:#66d9ef">my</span> $shortest <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

    say <span style="color:#e6db74">&#34;got {$start} to {$end}&#34;</span> <span style="color:#66d9ef">if</span> verbose;

    <span style="color:#66d9ef">for</span> ($start<span style="color:#f92672">..</span>$end)<span style="color:#f92672">.</span>reverse <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">\</span>val {
        <span style="color:#66d9ef">my</span> $collatz <span style="color:#f92672">=</span> chain(val);
        <span style="color:#66d9ef">if</span> $collatz<span style="color:#f92672">.</span>elems <span style="color:#f92672">&gt;=</span> $shortest {
            @largest <span style="color:#f92672">=</span> @largest<span style="color:#f92672">.</span>push($collatz)<span style="color:#f92672">.</span>sort( { $<span style="color:#960050;background-color:#1e0010">^</span>b<span style="color:#f92672">.</span>elems <span style="color:#e6db74">&lt;=&gt;</span> $<span style="color:#960050;background-color:#1e0010">^</span>a<span style="color:#f92672">.</span>elems} )<span style="color:#f92672">.</span>[<span style="color:#f92672">^</span><span style="color:#ae81ff">20</span>]<span style="color:#f92672">.</span>grep(<span style="color:#f92672">*.</span>defined);
            <span style="color:#66d9ef">if</span> @largest<span style="color:#f92672">.</span>elems <span style="color:#f92672">==</span> <span style="color:#ae81ff">20</span> {
                $shortest <span style="color:#f92672">=</span> @largest[<span style="color:#f92672">*-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>elems;
            }
        }
        say <span style="color:#e6db74">&#34;{val} : {$collatz.elems} : $shortest&#34;</span> <span style="color:#66d9ef">if</span> verbose;
    }

    <span style="color:#66d9ef">return</span> @largest;
}
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/athanasius/raku/ch-2.p6">Athanasius</a> used multi <code>MAIN</code> subroutines to separate the basic case and the extra credit case. His basic case is as follows:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6">multi <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">MAIN</span>
(
    UInt:D $N where $_ &gt; 0   #= Find the Collatz sequence for positive integer N
)
{
    <span style="color:#e6db74">&#34;Challenge 054, Task #2: Collatz Conjecture (Raku)\n&#34;</span><span style="color:#f92672">.</span>put;
    <span style="color:#66d9ef">my</span> UInt @seq <span style="color:#f92672">=</span> $N;
    <span style="color:#66d9ef">my</span> UInt $n   <span style="color:#f92672">=</span> $N;
    <span style="color:#66d9ef">while</span> $n <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>
    {
        $n <span style="color:#f92672">=</span> ($n % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) ?? ($n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>    )<span style="color:#f92672">.</span>UInt
                           <span style="color:#f92672">!!</span> ($n <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
        @seq<span style="color:#f92672">.</span>push: $n;
    }
    <span style="color:#66d9ef">my</span> UInt $terms <span style="color:#f92672">=</span> @seq<span style="color:#f92672">.</span>elems;
    <span style="color:#e6db74">&#34;The Collatz sequence (of %d term%s) for N = %s:\n%s\n&#34;</span><span style="color:#f92672">.</span>printf:
        $terms, ($terms <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> ?? <span style="color:#e6db74">&#39;&#39;</span> <span style="color:#f92672">!!</span> <span style="color:#e6db74">&#39;s&#39;</span>), comma($N), @seq<span style="color:#f92672">.</span>join: <span style="color:#e6db74">&#39; -&gt; &#39;</span>;
}
</code></pre></div><p>When called for the extra credit, the <code>MAIN</code> subroutine calls the <code>find-longest-seqs</code> subroutine, which itself calls the recursive <code>count-terms</code> subroutine. This latter subroutine is caching the results into the <code>%chains</code> hash:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">find</span>-longest-seqs( --&gt; Array:D )
{
    <span style="color:#66d9ef">my</span> $longest<span style="color:#f92672">-</span>seqs <span style="color:#f92672">=</span> List::Priority<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>(capacity <span style="color:#f92672">=&gt;</span> MAX<span style="color:#f92672">-</span>TERMS);
    $longest<span style="color:#f92672">-</span>seqs<span style="color:#f92672">.</span>insert(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>);

    <span style="color:#66d9ef">my</span> UInt $max <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>                         <span style="color:#66d9ef">if</span> DEBUG;
    <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;Max seq length: [  1,       1]\n&#34;</span> <span style="color:#66d9ef">if</span> DEBUG;
    <span style="color:#66d9ef">for</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">..</span> MAX<span style="color:#f92672">-</span>N <span style="color:#f92672">-&gt;</span> UInt $start
    {
        <span style="color:#66d9ef">my</span> UInt $terms <span style="color:#f92672">=</span> count<span style="color:#f92672">-</span>terms($start);

        <span style="color:#66d9ef">if</span> (DEBUG <span style="color:#f92672">&amp;&amp;</span> $terms <span style="color:#f92672">&gt;</span> $max)
        {
            $max <span style="color:#f92672">=</span> $terms;
            <span style="color:#e6db74">&#34;Max seq length: [%3d, %7d]\n&#34;</span><span style="color:#f92672">.</span>printf: $terms, $start;
        }
        $longest<span style="color:#f92672">-</span>seqs<span style="color:#f92672">.</span>insert($terms, $start);
    }
    <span style="color:#66d9ef">my</span> @longest<span style="color:#f92672">-</span>seqs;
    <span style="color:#66d9ef">while</span> $longest<span style="color:#f92672">-</span>seqs<span style="color:#f92672">.</span>size <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>
    {
        <span style="color:#66d9ef">my</span> UInt $seq<span style="color:#f92672">-</span>len <span style="color:#f92672">=</span> $longest<span style="color:#f92672">-</span>seqs<span style="color:#f92672">.</span>highest_priority<span style="color:#f92672">.</span>UInt;
        <span style="color:#66d9ef">my</span> UInt $start   <span style="color:#f92672">=</span> $longest<span style="color:#f92672">-</span>seqs<span style="color:#f92672">.</span>pop;

        push @longest<span style="color:#f92672">-</span>seqs, [ $start, $seq<span style="color:#f92672">-</span>len ];
    }
    <span style="color:#66d9ef">return</span> @longest<span style="color:#f92672">-</span>seqs;
}
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">count</span>-terms( UInt:D $n --&gt; UInt:D )
{
    state  %chains <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">1</span>;            <span style="color:#75715e"># Memoize</span>

    <span style="color:#66d9ef">return</span> %chains{$n}                                  <span style="color:#66d9ef">if</span> %chains{$n}:exists;
    <span style="color:#66d9ef">return</span> %chains{$n} <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> count<span style="color:#f92672">-</span>terms(($n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>)<span style="color:#f92672">.</span>UInt) <span style="color:#66d9ef">if</span> $n % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">return</span> %chains{$n} <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> count<span style="color:#f92672">-</span>terms( $n <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> );
}
</code></pre></div><p>In a comment to his program, Athanasius reports that his program takes 20 minutes to complete for the <code>1..1e6</code> range. That’s really too slow, there must be something wrong in the caching implementation.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/colin-crain/raku/ch-2.p6">Colin Crain</a> used a <code>next-collatz</code> subroutine to compute the next term in a given sequence, and used this in the <code>make_collatz_sequence</code> subroutine to compute a full sequence:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">make_collatz_sequence</span> ( $start ) {
    <span style="color:#66d9ef">my</span> $current <span style="color:#f92672">=</span> $start;
    <span style="color:#66d9ef">my</span> @seq <span style="color:#f92672">=</span> ($current);
    <span style="color:#66d9ef">my</span> $next;

    <span style="color:#66d9ef">while</span> ($current <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>) {
        $next <span style="color:#f92672">=</span> next_collatz($current);
        @seq<span style="color:#f92672">.</span>push: $next;
        $current <span style="color:#f92672">=</span> $next;
    }

    <span style="color:#66d9ef">return</span> @seq;
}

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">next_collatz</span> (Int:D  $n ) {
    $n %% 2  ??   ($n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>)<span style="color:#f92672">.</span>Int
             <span style="color:#f92672">!!</span>   <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> $n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
}
</code></pre></div><p>The extra credit task is performed in the following <code>get_collatz_metadata</code> subroutine:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">get_collatz_metadata</span> ( %data, %sequences ) {
<span style="color:#75715e">## run metaanalysis on the first 1,000,000 Collatz sequences</span>
    <span style="color:#66d9ef">my</span> $then <span style="color:#f92672">=</span> now;
    <span style="color:#66d9ef">for</span> (<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span><span style="color:#ae81ff">1000000</span>) <span style="color:#f92672">-&gt;</span> $number {
        <span style="color:#66d9ef">my</span> $prev <span style="color:#f92672">=</span> $number;
        <span style="color:#66d9ef">my</span> $len  <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">my</span> $next;

        <span style="color:#66d9ef">while</span> ($prev <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>) {
            $next <span style="color:#f92672">=</span> $prev % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>  ??   $prev <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>
                                    <span style="color:#f92672">!!</span>   <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> $prev <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
            $prev <span style="color:#f92672">=</span> $next;
            <span style="color:#66d9ef">if</span> ($next <span style="color:#f92672">&gt;</span> %data<span style="color:#e6db74">&lt;highest_value&gt;</span>) {
                %data<span style="color:#e6db74">&lt;highest_number&gt;</span> <span style="color:#f92672">=</span> $number;
                %data<span style="color:#e6db74">&lt;highest_value&gt;</span>  <span style="color:#f92672">=</span> $next;
            }
            $len<span style="color:#f92672">++</span>;
        }
        %sequences{$number} <span style="color:#f92672">=</span> $len;
    }
    say <span style="color:#e6db74">&#34;time: &#34;</span>, now <span style="color:#f92672">-</span> $then;
}
</code></pre></div><p>Colin&rsquo;s program starts with a lengthy and very useful comment explaining some of the code. Please follow the link to read it. Among other things, Colin was interested to find the highest number found along the computation. The highest number found is &ldquo;56,991,483,520, in the sequence for the number 704,511. Huh.&rdquo; And, interestingly, the sequence for number 704,511 is not anywhere near the 20 longest sequences (it has only 240 numbers, where as the 20 longest sequences are between 445 and 525)).</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/jaldhar-h-vyas/raku/ch-2.p6">Jaldhar H. Vyas</a> made a very concise and creative <code>collatzSequence</code> to compute the Collatz sequence of any number, using the <code>...</code> sequence operator:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">collatzSequence</span>(Int $n) {
    <span style="color:#66d9ef">return</span> ($n, { ($_ % 2) ?? (<span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> $_ <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">!!</span> ($_ <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>) } <span style="color:#f92672">...</span> <span style="color:#ae81ff">1</span>);
}
</code></pre></div><p>This is quite clever, I love the idea.</p>
<p>This is his submission for the extra credit:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6">multi <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">MAIN</span>() {
    <span style="color:#66d9ef">my</span> $maxlength <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">my</span> @longest <span style="color:#f92672">=</span> ();

    <span style="color:#66d9ef">for</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> <span style="color:#ae81ff">1e6</span> <span style="color:#f92672">-&gt;</span> $n {
        <span style="color:#66d9ef">my</span> $length <span style="color:#f92672">=</span> collatzSequence($n)<span style="color:#f92672">.</span>elems;

        <span style="color:#66d9ef">if</span> $length <span style="color:#f92672">&gt;=</span> $maxlength {
            $maxlength <span style="color:#f92672">=</span> (@longest<span style="color:#f92672">.</span>elems) ?? @longest[<span style="color:#f92672">*-</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">!!</span> $length;
            @longest<span style="color:#f92672">.</span>push([$n, $length]);

            @longest <span style="color:#f92672">=</span> @longest<span style="color:#f92672">.</span>sort({ $<span style="color:#960050;background-color:#1e0010">^</span>b[<span style="color:#ae81ff">1</span>] <span style="color:#e6db74">&lt;=&gt;</span> $<span style="color:#960050;background-color:#1e0010">^</span>a[<span style="color:#ae81ff">1</span>] });
            <span style="color:#66d9ef">if</span> (@longest<span style="color:#f92672">.</span>elems <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">20</span>) {
                @longest<span style="color:#f92672">.</span>pop;
            }
        }
    }

    <span style="color:#66d9ef">for</span> @longest <span style="color:#f92672">-&gt;</span> @long {
        say @long[<span style="color:#ae81ff">0</span>], <span style="color:#e6db74">&#39;: &#39;</span>, @long[<span style="color:#ae81ff">1</span>];
    }
}
</code></pre></div><p>It looks fine, but, since there no attempt at either parallelizing or caching, it probably takes quite a long while to execute.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/javier-luque/raku/ch-2.p6">Javier Luque</a> wrote a <code>collatz</code> subroutine to compute the length of the Collatz sequence for any integer:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">collatz</span>($n is copy) {
    <span style="color:#66d9ef">my</span> $length <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

    <span style="color:#66d9ef">while</span> ($n <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>) {
        $length<span style="color:#f92672">++</span>;

        $n <span style="color:#f92672">=</span> ($n % 2) ??
            <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> $n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>  <span style="color:#f92672">!!</span>
            $n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
    }

    <span style="color:#66d9ef">return</span> $length<span style="color:#f92672">.</span>Int;
}
</code></pre></div><p>To me, Javier&rsquo;s computation of the sequence length is off by one, just as some others challengers before, except that, looking at his code,  Javier seems to consider that the final number, 1, isn&rsquo;t part of the sequence.</p>
<p>He then used a brute force approach to solve the extra credit task:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6">    <span style="color:#66d9ef">for</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> <span style="color:#ae81ff">1_000_000</span>) <span style="color:#f92672">-&gt;</span> $i {
        <span style="color:#66d9ef">my</span> $length <span style="color:#f92672">=</span> collatz($i);
        %lengths{$i} <span style="color:#f92672">=</span> $length
            <span style="color:#66d9ef">if</span> ($length <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">440</span>);
    }

    <span style="color:#75715e"># Grab the 22 longest numbers</span>
    <span style="color:#66d9ef">my</span> @keys <span style="color:#f92672">=</span> %lengths<span style="color:#f92672">.</span>keys<span style="color:#f92672">.</span>sort(
        { %lengths<span style="color:#f92672">.</span>{$<span style="color:#960050;background-color:#1e0010">^</span>b} <span style="color:#e6db74">&lt;=&gt;</span> %lengths<span style="color:#f92672">.</span>{$<span style="color:#960050;background-color:#1e0010">^</span>a} }
    )<span style="color:#f92672">.</span>[<span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> <span style="color:#ae81ff">21</span>];

    <span style="color:#75715e"># Output the lengths</span>
    <span style="color:#66d9ef">for</span> ( @keys ) <span style="color:#f92672">-&gt;</span> $i {
        say <span style="color:#e6db74">&#34;$i : Length &#34;</span> <span style="color:#f92672">~</span> %lengths{$i};
    }
</code></pre></div><p>By Javier&rsquo;s own admission in his blog post: &ldquo;Warning: Raku solution is slow. &hellip; Very slow. Like really really slow.&rdquo; Unfortunately, Javier did not provide any figure.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/markus-holzer/raku/ch-2.p6">Markus Holzer</a> used the sequence operator (just as Jaldhar) to build the Collatz sequence of an input number:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">collatz</span>( Int $n ) is pure
{
    $n, { $<span style="color:#960050;background-color:#1e0010">^</span>n %% 2 ?? $<span style="color:#960050;background-color:#1e0010">^</span>n div <span style="color:#ae81ff">2</span> <span style="color:#f92672">!!</span> $<span style="color:#960050;background-color:#1e0010">^</span>n <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> } <span style="color:#f92672">...</span> { $<span style="color:#960050;background-color:#1e0010">^</span>n <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> }
}
</code></pre></div><p>As I already said about Jaldhar&rsquo;s solution, I really like this idea.</p>
<p>For the extra credit, Markus uses a <code>$cache</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6">    <span style="color:#66d9ef">for</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$N <span style="color:#f92672">-&gt;</span> $n
    {
        <span style="color:#66d9ef">my</span> Int $count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">my</span> Int $cache <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

        <span style="color:#66d9ef">my</span> @new <span style="color:#f92672">=</span> gather <span style="color:#66d9ef">for</span> collatz( $n ) <span style="color:#f92672">-&gt;</span> $collatz
        {
            <span style="color:#75715e"># Dynamic programming:</span>
            <span style="color:#75715e"># see what you have computed so far, so you</span>
            <span style="color:#75715e"># don&#39;t have to compute it again</span>
            <span style="color:#66d9ef">if</span> %result{ $collatz }:exists
            {
                $hits <span style="color:#f92672">+=</span> $cache <span style="color:#f92672">=</span> %result{ $collatz };
                <span style="color:#66d9ef">last</span>;
            }
            $miss<span style="color:#f92672">++</span>;
            take $collatz, $count<span style="color:#f92672">++</span>;
        }

        %result{ <span style="color:#f92672">.</span>[<span style="color:#ae81ff">0</span>] } <span style="color:#f92672">=</span> @new<span style="color:#f92672">.</span>elems <span style="color:#f92672">-</span> <span style="color:#f92672">.</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> $cache
            <span style="color:#66d9ef">for</span> @new;
    }
</code></pre></div><p>But if I understand correctly, I&rsquo;m afraid his caching approach doesn&rsquo;t bring a really significant advantage, as the program does compute the full Collatz sequence for every number in the input range, and apparently only caches the length of the sequence. For the range ten times smaller (<code>1..1e5</code>) than the requirement, the program runs in 21 seconds on my computer. It appears that the caching approach is not very efficient.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/mohammad-anwar/raku/ch-2.p6">Mohammad Anwar</a> cleverly used a multi subroutine to handle the two cases when computing the next term in the Collatz sequence:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">MAIN</span>(Int $n is copy where $n &gt; 0) {
    <span style="color:#66d9ef">my</span> @collatz <span style="color:#f92672">=</span> ($n);
    <span style="color:#66d9ef">while</span> $n <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span> {
        $n <span style="color:#f92672">=</span> collatz<span style="color:#f92672">-</span>sequence($n);
        push @collatz, $n;
    }
    say @collatz<span style="color:#f92672">.</span>join(<span style="color:#e6db74">&#34; -&gt; &#34;</span>);
}
multi <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">collatz</span>-sequence(Int $n where $n  %% 2) { $n div <span style="color:#ae81ff">2</span>   }

multi <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">collatz</span>-sequence(Int $n where $n !%% 2) { <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> $n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> }
</code></pre></div><p>Mohammad did not try to implement the extra credit.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/roger-bell-west/raku/ch-2.p6">Roger Bell West</a> implemented a <code>while</code> loop to process any list of numbers and provide the Collatz sequence for each:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">my</span> $n<span style="color:#f92672">=</span>shift @<span style="color:#960050;background-color:#1e0010">*</span>ARGS) {
  <span style="color:#66d9ef">my</span> @k<span style="color:#f92672">=</span>($n);
  <span style="color:#66d9ef">while</span> ($n <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>) {
    <span style="color:#66d9ef">if</span> ($n % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
      $n<span style="color:#f92672">/=</span><span style="color:#ae81ff">2</span>;
    } <span style="color:#66d9ef">else</span> {
      $n<span style="color:#f92672">*=</span><span style="color:#ae81ff">3</span>;
      $n<span style="color:#f92672">++</span>;
    }
    push @k,$n;
  }
  say join(<span style="color:#e6db74">&#39;, &#39;</span>,@k);
}
</code></pre></div><p>Roger did not implement the extra credit task.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/ruben-westerberg/raku/ch-2.p6">Ruben Westerberg</a> used the <code>hyper</code> operator to parallelize the processing:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#66d9ef">my</span> $max<span style="color:#f92672">=</span>@<span style="color:#960050;background-color:#1e0010">*</span>ARGS[<span style="color:#ae81ff">0</span>]<span style="color:#e6db74">//</span><span style="color:#ae81ff">23</span>;         <span style="color:#75715e">#sane default without cmd line args</span>
<span style="color:#66d9ef">my</span> @seqs<span style="color:#f92672">=</span>( <span style="color:#f92672">[]</span> xx <span style="color:#ae81ff">20</span>);        <span style="color:#75715e">#Initalise the largest 20 sequences found</span>
<span style="color:#66d9ef">my</span> $l<span style="color:#f92672">=</span>Lock<span style="color:#f92672">.</span><span style="color:#66d9ef">new</span>;            <span style="color:#75715e">#Create a lock to allow sequential access to top 20</span>

(<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$max)<span style="color:#f92672">.</span>hyper(batch<span style="color:#f92672">=&gt;</span><span style="color:#ae81ff">1000</span>, degree<span style="color:#f92672">=&gt;</span><span style="color:#ae81ff">8</span>)<span style="color:#f92672">.</span>map: {
    <span style="color:#66d9ef">my</span> $s<span style="color:#f92672">=</span>collaz([$_ ,]);
    $l<span style="color:#f92672">.</span>protect({
        <span style="color:#66d9ef">for</span> (<span style="color:#ae81ff">0</span><span style="color:#f92672">..^</span>@seqs) <span style="color:#f92672">-&gt;</span> $i {
            <span style="color:#66d9ef">if</span> $s<span style="color:#f92672">.</span>elems  <span style="color:#f92672">&gt;</span> @seqs[$i]<span style="color:#f92672">.</span>elems {
            	@seqs<span style="color:#f92672">.</span>pop <span style="color:#66d9ef">unless</span> @seqs<span style="color:#f92672">.</span>elems <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">20</span>;
            	@seqs<span style="color:#f92672">.</span>splice($i,<span style="color:#ae81ff">0</span>,[$s]);
            	<span style="color:#66d9ef">last</span>;
            }
        }
    });
    ();
};

say <span style="color:#e6db74">&#34;Top 20 Collaz Sequence lengths for starting numbers 1..$max&#34;</span>;
<span style="color:#66d9ef">for</span> @seqs<span style="color:#f92672">.</span>grep: <span style="color:#f92672">*.</span>elems <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
    printf <span style="color:#e6db74">&#34;Starting Number: %10d Sequence Length: %d\n&#34;</span>, <span style="color:#f92672">.</span>[<span style="color:#ae81ff">0</span>],<span style="color:#f92672">.</span>elems;
}



<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">collaz</span> ($seq) {
    given $seq[<span style="color:#f92672">*-</span><span style="color:#ae81ff">1</span>] {
        when $_%%2 {
            $seq<span style="color:#f92672">.</span>push: $_<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>;
        }
        default {
            $seq<span style="color:#f92672">.</span>push: <span style="color:#ae81ff">3</span><span style="color:#f92672">*</span>$_<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
        }
    }
    collaz($seq) <span style="color:#66d9ef">unless</span> $seq[<span style="color:#f92672">*-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">==</span><span style="color:#ae81ff">1</span>;
    $seq;
}
</code></pre></div><p>With a range reduced to <code>1..1e5</code>, the program ran in 41 seconds on my machine. Parallelizing probably brings some advantage over sequential processing, but the performance results are still quite poor.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/ryan-thompson/raku/ch-2.p6">Ryan Thompson</a> provided a very complete solution, including the maintenance of a sliding array of 20 results which I was too lazy too implement. Ryan&rsquo;s program uses a <code>@memo</code> array to cache (well, to memoize) the results. Although the program is a bit long, I think it is well worth to be quoted in its entirety:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#66d9ef">my</span> $top<span style="color:#f92672">-</span>n   <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;   <span style="color:#75715e"># Number of top sequences to list</span>
<span style="color:#66d9ef">my</span> $limit   <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e6</span>;  <span style="color:#75715e"># Highest starting number</span>
<span style="color:#66d9ef">my</span> $mintop  <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;    <span style="color:#75715e"># Minimum value in @top (efficiency/convenience)</span>

<span style="color:#66d9ef">my</span> @top     <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e"># Top N list (start =&gt; seq-len)</span>
<span style="color:#66d9ef">my</span> @memo    <span style="color:#f92672">=</span> (<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>);  <span style="color:#75715e"># Memoization (@memo[start] = seq-len)</span>

<span style="color:#75715e">#| Non extra-credit Collatz sequence</span>
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">collatz</span>( Int $n is copy ) {
    <span style="color:#66d9ef">my</span> @r <span style="color:#f92672">=</span> $n;
    <span style="color:#66d9ef">while</span> ( $n <span style="color:#960050;background-color:#1e0010">≠</span> <span style="color:#ae81ff">1</span> ) {
        $n <span style="color:#f92672">=</span> $n %% 2 ?? ($n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>)<span style="color:#f92672">.</span>Int <span style="color:#f92672">!!</span> (<span style="color:#ae81ff">3</span><span style="color:#f92672">*</span>$n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)<span style="color:#f92672">.</span>Int;
        @r<span style="color:#f92672">.</span>push: $n;
    }
    @r;
}

<span style="color:#75715e"># Iterate through all starting numbers</span>
<span style="color:#66d9ef">for</span> <span style="color:#ae81ff">3</span><span style="color:#f92672">..</span>$limit <span style="color:#f92672">-&gt;</span> $start {
    <span style="color:#66d9ef">my</span> Int $n <span style="color:#f92672">=</span> $start;
    <span style="color:#66d9ef">my</span> Int $len <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

    <span style="color:#75715e"># Keep going through the sequence until we hit a memoized value</span>
    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>@memo[$n]) {
        $len <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> $n % 2;
        $n <span style="color:#f92672">=</span> $n %% 2 ?? ($n <span style="color:#e6db74">/ 2).Int !! ((3*$n + 1) /</span> <span style="color:#ae81ff">2</span>)<span style="color:#f92672">.</span>Int;
    }

    $len <span style="color:#f92672">+=</span> @memo[$n];
    @memo[$start] <span style="color:#f92672">=</span> $len <span style="color:#66d9ef">if</span> $start <span style="color:#f92672">&lt;</span> $limit <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>;

    <span style="color:#75715e"># If the $len is better than the worst value in @top, add it</span>
    top($start, $len)          <span style="color:#66d9ef">if</span>  $len <span style="color:#f92672">&gt;</span> $mintop <span style="color:#f92672">and</span> $start <span style="color:#960050;background-color:#1e0010">≤</span> $limit;
    top($n <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>, @memo[$n] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">if</span> $n <span style="color:#960050;background-color:#1e0010">≤</span> $limit <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">and</span> @memo[$n] <span style="color:#f92672">&gt;</span> $mintop;
}

printf <span style="color:#e6db74">&#34;Start: %6d has %4d steps\n&#34;</span>, <span style="color:#f92672">.</span>key, <span style="color:#f92672">.</span>value <span style="color:#66d9ef">for</span> @top;

<span style="color:#75715e">#| O(n) insert $n =&gt; $len into @top</span>
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">top</span>(Int $n, Int $len) {
    <span style="color:#66d9ef">my</span> $idx <span style="color:#f92672">=</span> @top<span style="color:#f92672">.</span>keys<span style="color:#f92672">.</span>first: { @top[$_]<span style="color:#f92672">.</span>value <span style="color:#f92672">&lt;</span> $len };
    @top<span style="color:#f92672">.</span>splice: $idx<span style="color:#f92672">.</span>Int, <span style="color:#ae81ff">0</span>, $n <span style="color:#f92672">=&gt;</span> $len;
    @top<span style="color:#f92672">.</span>pop <span style="color:#66d9ef">if</span> @top <span style="color:#f92672">&gt;</span> $top<span style="color:#f92672">-</span>n;
    $mintop <span style="color:#f92672">=</span> @top[<span style="color:#f92672">*-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>value;
}
</code></pre></div><p>His program includes a couple of clever optimizations which he explains in <a href="http://ry.ca/2020/04/collatz-conjecture/">his very interesting blog</a>, including the idea of reducing the number of iterations by doing two steps in one go when the number examined is odd, which was also prompted to me by Mario.</p>
<p>To me, this really seems to be the best solution I have seen so far. So, I was interested to benchmark it on my machine, to compare his results with mines.</p>
<p>Ryan&rsquo;s program displays the same result as mine and runs pretty fast:</p>
<pre><code>real    0m20,861s
user    0m0,000s
sys     0m0,061s
</code></pre>
<p>My last solutions were a bit faster, but considering that his solution is more complete (as said, I did not implement a sliding array of results and just hard-coded the lower limit of the 20 sequences), and that I submitted my new results well after the deadline, I must admit that he did a much better job than I did.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/shahed-nooshmand/raku/ch-2.sh">Shahed Nooshmand</a> wrote a Raku one-liner:</p>
<pre><code>raku -e 'put “\e[F\e[K” ~ join “ → ”, (prompt(“\n”).trim-trailing, -&gt; \n { n %% 2 ?? n ÷ 2 !! 3 × n + 1 } … 1)'
</code></pre>
<p>Shahed also suggested a solution for the extra credit task:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#66d9ef">my</span> %hail <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">1</span>;

<span style="color:#66d9ef">for</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">..^</span><span style="color:#ae81ff">1e5</span> {
    <span style="color:#66d9ef">my</span> $n <span style="color:#f92672">=</span> $_;
    <span style="color:#66d9ef">my</span> $i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">until</span> %hail{$n}:exists {
        $n <span style="color:#f92672">=</span> $n %% 2 ?? $n <span style="color:#960050;background-color:#1e0010">÷</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">!!</span> $n <span style="color:#960050;background-color:#1e0010">×</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
        $i<span style="color:#f92672">++</span>
    }
    %hail{$_} <span style="color:#f92672">=</span> $i <span style="color:#f92672">+</span> %hail{$n}
}
<span style="color:#f92672">.</span>put <span style="color:#66d9ef">for</span> %hail<span style="color:#f92672">.</span>sort(<span style="color:#960050;background-color:#1e0010">−</span><span style="color:#f92672">*.</span>value)[<span style="color:#f92672">^</span><span style="color:#ae81ff">20</span>]
</code></pre></div><p>Here, Shahed used the <code>%hail</code> hash to serve both as a cache and as a list of results. Running this program with a range reduced to <code>1..1e5</code> took about 10 seconds on my computer. The slight problem though is that finding the sequences is done quite efficiently, but sorting the hash at the end takes almost much time as finding the sequences. Just to illustrate this, changing the last line to this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#f92672">.</span>put <span style="color:#66d9ef">for</span> %hail<span style="color:#f92672">.</span>grep({$_<span style="color:#f92672">.</span>value <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">300</span>})<span style="color:#f92672">.</span>sort(<span style="color:#960050;background-color:#1e0010">−</span><span style="color:#f92672">*.</span>value)[<span style="color:#f92672">^</span><span style="color:#ae81ff">20</span>];
</code></pre></div><p>considerably reduces the time to sort the data and makes the overall execution almost twice faster.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-054/ulrich-rieke/raku/ch-2.p6">Ulrich Rielke</a> first wrote a <code>findSequence</code> subroutine to compute the Collatz sequence of any input integer:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">findSequence</span>( Int $n is copy ) {
  <span style="color:#66d9ef">my</span> @sequence ;
  <span style="color:#66d9ef">while</span> ( $n <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span> ) {
      @sequence<span style="color:#f92672">.</span>push( $n ) ;
      <span style="color:#66d9ef">if</span> ( $n %% 2 ) {
        $n div<span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> ;
      }
      <span style="color:#66d9ef">else</span> {
        $n <span style="color:#f92672">=</span> $n <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> ;
      }
  }
  @sequence<span style="color:#f92672">.</span>push( $n ) ;
  <span style="color:#66d9ef">return</span> @sequence ;
}
</code></pre></div><p>For the extra credit, the main program then iterates over the <code>1..1000000</code> range and, for each value calls <code>findSequence</code>.</p>
<pre><code>sub MAIN( Int $n ) {
  .say for findSequence( $n ) ;
  my @sequences ;
  for (1..1000000) -&gt; $num {
      my @sequence = findSequence( $num ) ;
      @sequences.push( ($num , @sequence.elems ) ) ;
  }
  my @sorted = @sequences.sort( { $^b[1] &lt;=&gt; $^a[1] } ) ;
  say &quot;The sequence lengths of the longest sequences up to 1000000 are :&quot; ;
  @sorted[0..19].map( { say &quot;$_[0]  $_[1]&quot; } ) ;
}
</code></pre><p>Ulrich did not try to optimize the program, so I&rsquo;m afraid this is quite slow.</p>
<hr>
<h2 id="see-also">SEE ALSO</h2>
<p>Quite a number of blog posts this time:</p>
<ul>
<li>
<p>Arne Sommer: <a href="https://raku-musings.com/sequential-conjectures.html;">https://raku-musings.com/sequential-conjectures.html;</a></p>
</li>
<li>
<p>Kevin Colyer: <a href="https://kevincolyer.wordpress.com/2020/04/05/perl-weekly-challenge-week-54/;">https://kevincolyer.wordpress.com/2020/04/05/perl-weekly-challenge-week-54/;</a></p>
</li>
<li>
<p>Luca Ferrari:  <a href="https://fluca1978.github.io/2020/03/29/PerlWeeklyChallenge54.html#task2;">https://fluca1978.github.io/2020/03/29/PerlWeeklyChallenge54.html#task2;</a></p>
</li>
<li>
<p>Jaldhar H. Vyas: <a href="https://www.braincells.com/perl/2020/04/perl_weekly_challenge_week_54.html;">https://www.braincells.com/perl/2020/04/perl_weekly_challenge_week_54.html;</a></p>
</li>
<li>
<p>Javier Luque: <a href="https://perlchallenges.wordpress.com/2020/03/30/perl-weekly-challenge-054/;">https://perlchallenges.wordpress.com/2020/03/30/perl-weekly-challenge-054/;</a></p>
</li>
<li>
<p>Mohammad Anwar: <a href="https://perlweeklychallenge.org/blog/weekly-challenge-054;">https://perlweeklychallenge.org/blog/weekly-challenge-054;</a></p>
</li>
<li>
<p>Ryan Thompson: <a href="http://ry.ca/2020/04/collatz-conjecture/;">http://ry.ca/2020/04/collatz-conjecture/;</a></p>
</li>
<li>
<p>Shahed Nooshmand: <a href="https://rafraichisso.ir/2020/04/03/pwc-54">https://rafraichisso.ir/2020/04/03/pwc-54</a>.</p>
</li>
</ul>
<h2 id="wrapping-up">Wrapping up</h2>
<p>Please let me know if I forgot any of the challengers or if you think my explanation of your code misses something important (send me an e-mail or just raise an issue against this GitHub page).</p>
<p>If you want to participate to the Perl Weekly Challenge, please connect to <a href="https://perlweeklychallenge.org/">this site</a>.</p>

                </div>
            </div>
        </div>
    </div>
</section>


<!-- Call To Action Section Start -->
<section id="call-to-action">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2 class="title wow fadeInDown" data-wow-delay=".3s" data-wow-duration="500ms">SO WHAT DO YOU THINK ?</h2>
                    <p class="wow fadeInDown" data-wow-delay=".5s" data-wow-duration="500ms">If you have any suggestions or ideas then please do share with us.</p>
                    <a href="/contact" class="btn btn-default btn-contact wow fadeInDown" data-wow-delay=".7s" data-wow-duration="500ms">Contact with me</a>
                </div>
            </div>

        </div>
    </div>
</section>
<!-- Call To Action Section End -->



<!-- Footer Section Start -->
<footer id="footer">
    <div class="container">
        <div class="row content-justify-between">
            <div class="col-md-8 col-12 text-center text-lg-left text-md-left">
                <p class="copyright">Copyright:
                    <span>
                        2019 - 2024
                    </span> The Weekly Challenge. Theme Design and Developed by
                    <a href="http://www.Themefisher.com" rel="noreferrer" rel="noreferrer" target="_blank">Themefisher</a>.
                </p>
            </div>
            <div class="col-md-4 col-12">
                <!-- Social Media -->
                <ul class="social text-center text-md-right text-lg-right">
                    <li>
                        <a href="https://twitter.com/PerlWChallenge" class="twitter" rel="noreferrer" target="_blank" title="Follow us">
                            <i class="ion-social-twitter"></i>
                        </a>
                    </li>
                    <li>
                        <a href="/rss.xml" class="rss" target="_blank" title="RSS Feed">
                            <i class="ion-social-rss"></i>
                        </a>
                    </li>
                </ul>
            </div>
        </div>
    </div>
</footer>
<!-- footer section end -->

<!-- jquery -->
<script src="https://theweeklychallenge.org/plugins/jquery/jquery.min.js"></script>
<!-- Form Validation -->
<script src="https://theweeklychallenge.org/plugins/form-validation/jquery.form.min.js"></script>
<script src="https://theweeklychallenge.org/plugins/form-validation/jquery.validate.min.js"></script>
<!-- slick slider -->
<script src="https://theweeklychallenge.org/plugins/slick/slick.min.js"></script>
<!-- bootstrap js -->
<script src="https://theweeklychallenge.org/plugins/bootstrap/bootstrap.min.js"></script>
<!-- chart js -->
<script src="https://theweeklychallenge.org/plugins/chart/highstock.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/drilldown.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/data.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/chart.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/pwc-challenge.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/gc-challenge.js"></script>
<!-- wow js -->
<script src="https://theweeklychallenge.org/plugins/wow-js/wow.min.js"></script>
<!-- slider js -->
<script src="https://theweeklychallenge.org/plugins/slider/slider.js"></script>
<!-- Fancybox -->
<script src="https://theweeklychallenge.org/plugins/facncybox/jquery.fancybox.js"></script>
<!-- template main js -->

<script src="https://theweeklychallenge.org/js/script.min.js"></script>
<!-- google analitycs -->

<script async src="https://www.googletagmanager.com/gtag/js?id=G-CJTPYM9SB8"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-CJTPYM9SB8');
</script>
</body>

</html>

