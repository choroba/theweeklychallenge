<!DOCTYPE html>
<html class="no-js" lang="en-us">
<head>
    <!-- Basic Page Needs -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:title"       content="The Weekly Challenge"/>
    <meta property="og:type"        content="website"/>
    <meta property="og:url"         content="https://theweeklychallenge.org/"/>
    <meta property="og:image"       content="https://theweeklychallenge.org/images/about/about.jpg"/>
    <meta property="og:description" content="You do not have to be an expert."/>
    <meta name="twitter:card"       content="summary" />
    <meta name="twitter:image"      content="https://theweeklychallenge.org/images/about/about.jpg"/>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <meta name="description" content="Colin Crain › Perl Weekly Review #075">
    <meta name="author" content="The Weekly Challenge Team">
    <meta name="generator" content="Hugo 0.67.0-DEV" />

    <link rel="me" href="https://fosstodon.org/@manwar">

    <!-- Mobile Specific Metas -->
    <meta name="format-detection" content="telephone=no">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Colin Crain › Perl Weekly Review #075</title>
    <link rel="icon" href="https://theweeklychallenge.org/images/favicon.ico">

    
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css"/>

    <!-- Twitter Bootstrs CSS -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/bootstrap/bootstrap.min.css">
    <!-- Ionicons Fonts Css -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/ionicons/ionicons.min.css">
    <!-- animate css -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/animate-css/animate.css">
    <!-- Hero area slider css-->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/slider/slider.css">
    <!-- slick slider -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/slick/slick.css">
    <!-- Fancybox -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/facncybox/jquery.fancybox.css">
    <!-- hover -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/hover/hover-min.css">
    <!-- Google fonts -->
    <link href='https://fonts.googleapis.com/css?family=Source Code Pro' rel='stylesheet'>
    <!-- template main css file -->
    
    <link rel="stylesheet" href="https://theweeklychallenge.org/css/style.min.css" integrity="" media="screen">
    <link rel="stylesheet" href="https://theweeklychallenge.org/css/main.css">

    <style>
        #goTopButton {
            display: none;          
            position: fixed;        
            bottom: 20px;           
            right: 30px;            
            z-index: 99;            
            border: none;           
            outline: none;          
            background-color: red;  
            color: white;           
            cursor: pointer;        
            padding: 15px;          
            border-radius: 10px;    
            font-size: 18px;        
        }

        #goTopButton:hover {
              background-color: #555;
        }
    </style>


</head>

<body>

<button onclick="goTop()" id="goTopButton" title="Go to top">Top</button>

<script>

    topButton = document.getElementById("goTopButton");

    
    window.onscroll = function() { scrollFunction() };

    function scrollFunction() {
        if (document.body.scrollTop > 40 || document.documentElement.scrollTop > 40) {
            topButton.style.display = "block";
        } else {
            topButton.style.display = "none";
        }
    }

    
    function goTop() {
        document.body.scrollTop = 0; 
        document.documentElement.scrollTop = 0; 
    }

</script>

<section class="top-bar animated-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-12">
                <nav class="navbar navbar-expand-lg navbar-light bg-light">
                    <a class="navbar-brand" href="https://theweeklychallenge.org/">
                        <img src="https://theweeklychallenge.org/images/logo.svg" alt="logo">
                    </a>
                    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navgation" aria-controls="navigation"
                        aria-expanded="false" aria-label="Toggle navigation">
                        <span class="navbar-toggler-icon"></span>
                    </button>

                    <div class="collapse navbar-collapse" id="navigation">
                        <ul class="navbar-nav ml-auto">
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/">Home</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/about">About</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/chart">Chart</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/champions">Champions</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/team">Team</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/challenges">Challenges</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/p5-reviews">Perl/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/p6-reviews">Raku/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/recaps">Recaps</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/blogs">Blogs</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/faq">FAQ</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/contact">Contact</a>
                            </li>
                            
                        </ul>
                    </div>
                </nav>
            </div>
        </div>
    </div>
</section>


<section class="global-page-header">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2>Colin Crain › Perl Weekly Review #075</h2>
                    <div class="portfolio-meta">
                        <span>Monday, Sep 7, 2020</span>|
                        <span> Tags:
                            perl
                        </span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

<section class="single-post">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                
                <div style="text-align: center" class="post-img">
                    <img class="img-fluid" alt="" src="https://theweeklychallenge.org/images/blog/p5-review-challenge-075.jpg">
                </div>
                
                <div style="text-align: justify" class="post-content">
                    <p>( <em>&hellip;continues from <a href="/blog/review-challenge-074/">previous week</a>.</em> )</p>
<p>Welcome to the Perl review for <strong>Week 075</strong> of the Weekly Challenge! Here we will take the time to discuss the  submissions offered by the team, factor out the common methodologies that came up in those solutions, and highlight some of the unique approaches and unusual code created.</p>
<p>Or really, talk about pretty much anything that stands out as remarkable or noteworthy.</p>
<p>Every week there is an enormous global collective effort made by the team, analyzing and creatively coding the submissions, and that effort deserves credit due. And that&rsquo;s why I&rsquo;m here, to try and figure out how to do that.</p>
<p>Let&rsquo;s have a look and see what we can find.</p>
<hr>
<p><strong><big>For context</big></strong>  before we begin, you may wish to revisit either of the pages for the <a href="/blog/perl-weekly-challenge-075/"><strong>original tasks</strong></a> or the summary <a href="/blog/recap-challenge-075/"><strong>recap</strong></a> of the challenge. But don&rsquo;t worry, the challenges themselves will be briefly summarized, presented below as we progress from task by task. Oh, and one more thing before we get started:</p>
<h3 id="getting-in-touch-with-us">Getting in Touch with Us</h3>
<p><a href="mailto:pwc.perfectwave@gmail.com"><img src="/images/blog/Email.svg" height="50" width="50"> Email</a> › Please email me (Colin) with any feedback, notes, clarifications or whatnot about this review.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge"><img src="/images/blog/Github.svg" height="50" width="50"> GitHub</a> › Submit a pull request to us for any issues you may find with this page.</p>
<p><a href="https://twitter.com/perlwchallenge"><img src="/images/blog/Twitter.svg" height="50" width="50"> Twitter</a> › Join the discussion on Twitter!</p>
<p>I&rsquo;m always curious as to what the people think of these efforts. Everyone here at the PWC would like to hear any feedback you&rsquo;d like to give.</p>
<p><strong>So finally, without further ado&hellip;</strong></p>
<hr>
<h2 id="---nbsp--nbsp--nbsp---task-1pwc075task1-------nbsp--nbsp--nbsp------nbsp--nbsp--nbsp---task-2pwc075task2---nbsp--nbsp--nbsp----------nbsp--nbsp--nbsp---blogspwc075blogs----nbsp--nbsp--nbsp-------">•             <a href="#PWC075TASK1">Task 1</a>                 •             <a href="#PWC075TASK2">Task 2</a>                 •             <a href="#PWC075BLOGS">BLOGS</a>                  •</h2>
<hr>
<h1 id="PWC075TASK1">TASK #1 › Coins Sum</h1>
<p>You are given a set of coins @C, assuming you have infinite amount of each coin in the set.
Write a script to find how many ways you make sum $S using the coins from the set @C.</p>
<p>Example:
Input:</p>
<pre><code>    @C = (1, 2, 4)
    $S = 6
</code></pre><p>Output: 6
There are 6 possible ways to make sum 6.</p>
<pre><code>    a) (1, 1, 1, 1, 1, 1)
    b) (1, 1, 1, 1, 2)
    c) (1, 1, 2, 2)
    d) (1, 1, 4)
    e) (2, 2, 2)
    f) (2, 4)
</code></pre><h2 id="solution-types">Solution Types</h2>
<p>The 26 solutions given were wide ranging, but did fall into a few basic categories. I&rsquo;ll try and briefly discuss and give representative examples. Wish me luck.</p>
<h2 id="use-a-combinatorics-module">use a Combinatorics Module</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/javier-luque/perl/ch-1.pl"><strong>Javier Luque</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/ulrich-rieke/perl/ch-1.pl"><strong>Ulrich Rieke</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/wanderdoc/perl/ch-1.pl"><strong>Wanderdoc</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/yet-ebreo/perl/ch-1.pl"><strong>Yet Ebreo</strong></a></p>
<p>There was a very straightforward solution available to those in a hurry. The task as stated is essentially a problem in combinatorics; we are looking for combinations with repetition that satisfy a certain requirement. We don&rsquo;t know the length to specify, but we do know both the amount and the value of the smallest coin. Dividing one by the other will give us an upper limit, and we&rsquo;re in business.</p>
<p>Reaching up on the shelf, the go to module of choice around here seems to have settled on <code>Algorithm::Combinatorics</code>, with good reason. It&rsquo;s full-featured and fast, and a personal favorite. The <code>combinations_with_repetition</code> routine, given an array reference and a size, will return an iterator object that when called will produce the next combination of length size of the elements in the array. Here is the core logic demonstrated by</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/wanderdoc/perl/ch-1.pl"><strong>Wanderdoc</strong></a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"> <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $k ( <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span>  $sum<span style="color:#f92672">/</span>$arr[<span style="color:#ae81ff">0</span>])
 {
      <span style="color:#66d9ef">my</span> $iter <span style="color:#f92672">=</span> combinations_with_repetition(<span style="color:#f92672">\</span>@arr, $k);
      <span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">my</span> $p <span style="color:#f92672">=</span> $iter<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">next</span>)
      {
           <span style="color:#66d9ef">print</span> join(<span style="color:#e6db74">&#39;: &#39;</span>, <span style="color:#f92672">++</span>$counter, join(<span style="color:#e6db74">&#39;+&#39;</span>, @$p)), $/ <span style="color:#66d9ef">if</span> sum(@$p) <span style="color:#f92672">==</span> $sum;
      }
 }
</code></pre></div><p>The $counter variable keeps track of the number of hits, and that <code>sum</code> is imported from <code>List::Util</code>. A little support code and that&rsquo;s all we need.</p>
<p>The only real improvement to this method comes in more careful selection in the bounds of the loop. Here the good doctor starts at 1, but that assumes we have a 1-unit cent, copper, jiao, penny or whatnot to work with. This is not a given, so there&rsquo;s room to tune the algorithm.</p>
<p>In that regard, avid golfer
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/yet-ebreo/perl/ch-1.pl"><strong>Yet Ebreo</strong></a>
is back with the following terse gem:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> @C <span style="color:#f92672">=</span> sort {$a<span style="color:#f92672">-</span>$b} (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>);
<span style="color:#66d9ef">my</span> $S <span style="color:#f92672">=</span> <span style="color:#ae81ff">6</span>;
<span style="color:#66d9ef">my</span> $max <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">|</span> $S <span style="color:#f92672">/</span> $C[<span style="color:#ae81ff">0</span>];

<span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $k (<span style="color:#ae81ff">1</span><span style="color:#f92672">+</span>$S<span style="color:#f92672">/</span>$C[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">..</span> $max) {
    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $v ( combinations_with_repetition(<span style="color:#f92672">\</span>@C, $k) ) {
        ($S <span style="color:#f92672">==</span> sum @$v) <span style="color:#f92672">&amp;&amp;</span> say <span style="color:#e6db74">&#34;@$v&#34;</span>
    }
}
</code></pre></div><p>As you can see this optimization in choosig the brackets can get quite involved. The careful observer will notice one glaring weirdness in this code, though: <strong>&ldquo;What&rsquo;s up with that <code>sort</code> function, anyway?&quot;</strong> Yea, somethin&rsquo; just ain&rsquo;t right about that boy&hellip; <em>(shakes head)</em></p>
<p>But the code block works, that it does. Why? Well, it&rsquo;s subtraction: $a - $b will either be positive, negative or zero, which is what <code>sort</code> wants to know. If asked I&rsquo;d say it needed (-1, 0, 1), because, you know, that&rsquo;s what <code>&lt;=&gt;</code> returns, but apparently any positive or negative will do. Never much thought about that detail. Huh. Good to know.</p>
<h2 id="the-odometer-method">the ODOMETER method</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/roger-bell-west/perl/ch-1.pl"><strong>Roger Bell_West</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/walt-mankowski/perl/ch-1.pl"><strong>Walt Mankowski</strong></a></p>
<p>One way to keep track of unknown quantity of a fixed number of types of objects is to assign an array, mapping positions to specific coin values, with the element holding the quantity. In this sense the array resembles, appropriately, a <a href="https://www.wasserstrom.com/restaurant-supplies-equipment/Product?partNumber=283190&amp;gclid=Cj0KCQjw7sz6BRDYARIsAPHzrNIn5-lW-TPENLnU6g6-_wDyyG5awZMlnHdCN_AAF5XAZhp8XiXdnKUaAoe5EALw_wcB">mechanical change maker</a>. By rolling values through this array, incrementing  the smaller value first then carrying over into higher value coins, resetting the smaller value element counters when the target value is exceeded, the array trips somewhat like the odometer in a car. The sum at any given moment can be found by multiplying the quantity at given position by the value of the coin it represents. In this way all the combinations of coins can be systematically rotated through and examined.</p>
<p>Here is <strong>Walt Mankowski&rsquo;s</strong> version laid out:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> @cnt <span style="color:#f92672">=</span> map {<span style="color:#ae81ff">0</span>} <span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$#c;
<span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>) {
    <span style="color:#66d9ef">my</span> $val <span style="color:#f92672">=</span> value(<span style="color:#f92672">\</span>@c, <span style="color:#f92672">\</span>@cnt);
    <span style="color:#66d9ef">if</span> ($val <span style="color:#f92672">&gt;=</span> $s) {
        <span style="color:#66d9ef">if</span> ($val <span style="color:#f92672">==</span> $s) {
            <span style="color:#66d9ef">my</span> @tmp <span style="color:#f92672">=</span> @cnt;
            push @solutions, <span style="color:#f92672">\</span>@tmp;
        }

        <span style="color:#75715e"># rotate &#34;odometer&#34;</span>
        $cnt[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">my</span> $i <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>;
        $cnt[$i]<span style="color:#f92672">++</span>;
        <span style="color:#66d9ef">while</span> ($i <span style="color:#f92672">&gt;=</span> <span style="color:#f92672">-</span>@c <span style="color:#f92672">&amp;&amp;</span> value(<span style="color:#f92672">\</span>@c, <span style="color:#f92672">\</span>@cnt) <span style="color:#f92672">&gt;</span> $s) {
            $cnt[$i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
            $i<span style="color:#f92672">--</span>;
            $cnt[$i]<span style="color:#f92672">++</span> <span style="color:#66d9ef">if</span> $i <span style="color:#f92672">&gt;=</span> <span style="color:#f92672">-</span>@c;
        }
        <span style="color:#66d9ef">last</span> <span style="color:#66d9ef">if</span> $i <span style="color:#f92672">&lt;</span> <span style="color:#f92672">-</span>@c;
    } <span style="color:#66d9ef">else</span> {
        $cnt[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">++</span>;
    }
}
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/roger-bell-west/perl/ch-1.pl"><strong>Roger Bell_West</strong></a> uses a similar mechanism, explaining it further in his <a href="https://blog.firedrake.org/archive/2020/08/Perl_Weekly_Challenge_75__coins_and_rectangles.html">blog</a></p>
<h2 id="use-dynamic-programming">use DYNAMIC programming</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/cheok-yin-fung/perl/ch-1.pl"><strong>Cheok-Yin Fung</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/lubos-kolouch/perl/ch-1.pl"><strong>Lubos Kolouch</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/mohammad-anwar/perl/ch-1.pl"><strong>Mohammad S Anwar</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/nunovieira220/perl/ch-1.pl"><strong>Nuno Vieira</strong></a></p>
<p>The dynamic programming paradigm breaks the problem down into smaller sub-problems, building one upon the work already done by the smaller to produce the answer. There were a few examples taking this strategy;</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/mohammad-anwar/perl/ch-1.pl"><strong>Mohammad S Anwar</strong></a></p>
<p>here lays out his method for determining the <em>number</em> of solutions:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">coins_sum</span> {
    <span style="color:#66d9ef">my</span> ($coins, $sum) <span style="color:#f92672">=</span> @_;
    <span style="color:#66d9ef">my</span> $size <span style="color:#f92672">=</span> $#$coins;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">if</span> ($size <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> $sum <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>);
    <span style="color:#66d9ef">my</span> $matrix;

    <span style="color:#75715e"># Sum of 0 can be achieved in one possible way.</span>
    $matrix<span style="color:#f92672">-&gt;</span>[$_][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">for</span> (<span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $size<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);

    <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $i (<span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $size) {
        <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $j (<span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> $sum) {

            <span style="color:#66d9ef">my</span> $include_current <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
            <span style="color:#66d9ef">my</span> $exclude_current <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

            <span style="color:#66d9ef">if</span> ($coins<span style="color:#f92672">-&gt;</span>[$i] <span style="color:#f92672">&lt;=</span> $j) {
                $include_current <span style="color:#f92672">=</span> $matrix<span style="color:#f92672">-&gt;</span>[$i][$j <span style="color:#f92672">-</span> $coins<span style="color:#f92672">-&gt;</span>[$i]];
            }

            <span style="color:#66d9ef">if</span> ($i <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
                $exclude_current <span style="color:#f92672">=</span> $matrix<span style="color:#f92672">-&gt;</span>[$i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][$j];
            }
            $matrix<span style="color:#f92672">-&gt;</span>[$i][$j] <span style="color:#f92672">=</span> $include_current <span style="color:#f92672">+</span> $exclude_current;
        }
    }
    <span style="color:#66d9ef">return</span> $matrix<span style="color:#f92672">-&gt;</span>[$size][$sum];
}
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/cheok-yin-fung/perl/ch-1.pl"><strong>Cheok-Yin Fung</strong></a>,</p>
<p>also using a dynamic method, and produces the lists of coin solutions as well. Her <code>contain()</code> routine does most of the work.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">contain</span> {
    <span style="color:#66d9ef">my</span> @small <span style="color:#f92672">=</span> @{ $_[<span style="color:#ae81ff">0</span>] };
    <span style="color:#66d9ef">my</span> $size_of_smaller_arr <span style="color:#f92672">=</span> scalar @small;
    <span style="color:#66d9ef">my</span> @set_of_partitions <span style="color:#f92672">=</span> @{ $_[<span style="color:#ae81ff">1</span>] };
    <span style="color:#66d9ef">my</span> $size_of_the_set_of_parts <span style="color:#f92672">=</span> scalar @set_of_partitions;
    <span style="color:#66d9ef">my</span> $index <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">my</span> $tf_found <span style="color:#f92672">=</span> undef;
    <span style="color:#66d9ef">while</span> ( <span style="color:#f92672">not</span>($tf_found) <span style="color:#f92672">&amp;&amp;</span> ($index <span style="color:#f92672">&lt;</span> $size_of_the_set_of_parts) ) {
        <span style="color:#66d9ef">my</span> @a_partition <span style="color:#f92672">=</span> @{ $set_of_partitions[$index] };
        <span style="color:#66d9ef">my</span> $k <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        $tf_found <span style="color:#f92672">=</span> ( scalar @a_partition <span style="color:#f92672">==</span> scalar @a_partition );
        <span style="color:#66d9ef">while</span> ($tf_found <span style="color:#f92672">&amp;&amp;</span> ($k <span style="color:#f92672">&lt;</span> $size_of_smaller_arr)) {
            $tf_found <span style="color:#f92672">=</span> $tf_found <span style="color:#f92672">&amp;&amp;</span> ($a_partition[$k] <span style="color:#f92672">==</span> $small[$k]);
            $k<span style="color:#f92672">++</span>;
        }
        $index<span style="color:#f92672">++</span>;
    }
    <span style="color:#66d9ef">return</span> $tf_found;
}
</code></pre></div><p>She explains some of her reasoning in her <a href="http://blogs.perl.org/users/c_y_fung/2020/08/tc.html">blog</a>, where she also goes in some  rather interesting comparison testing against other languages.</p>
<h2 id="write-a-recursive-routine">write a RECURSIVE routine</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/alexander-pankoff/perl/ch-1.pl"><strong>Alexander Pankoff</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/athanasius/perl/ch-1.pl"><strong>Athanasius</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/colin-crain/perl/ch-1.pl"><strong>Colin Crain</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/dave-jacoby/perl/ch-1.pl"><strong>Dave Jacoby</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/duncan-c-white/perl/ch-1.pl"><strong>Duncan C. White</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/e-choroba/perl/ch-1.pl"><strong>E. Choroba</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/james-smith/perl/ch-1.pl"><strong>James Smith</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/jo-37/perl/ch-1.pl"><strong>Jorg Sommrey</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/laurent-rosenfeld/perl/ch-1.pl"><strong>Laurent Rosenfeld</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/jeongoon/perl/ch-1.pl"><strong>Myoungjin Jeon</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/perlboy1967/perl/ch-1.pl"><strong>Niels van Dijke</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/shawn-wagner/perl/ch-1.pl"><strong>Shawn Wagner</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/sgreen/perl/ch-1.pl"><strong>Simon Green</strong></a></p>
<p>As we wish to build a list, and have no good idea how many elements have, a natural approach is to build a recursive routine to add coins until we finish, building for as long as required.</p>
<p>In the most basic form, this will be adding another coin from a bag to a series of running lists, multiplying out the combinations until each one is deemed to have met or exceeded the desired total. This is perfectly adequate for smaller numbers and lists of coins, but blows up quite quickly for more complex solutions. Not only will we need to examine every possible solution until the sum overruns or a solution is found, but also we will end up generating every permutation of each of these lists and partial lists along the way as well. You can see how would escalate quickly.</p>
<p>About a half a dozen people let this complexity get away from them, whilst submitting fundamentally correct solutions.</p>
<p>There were a few ways to get out of this. We can control repeating work on equivalent permutations, we can avoid computing combinations that will never work, and we can remember the work we have done, in case we need to repeat it. The rest of the solutions in this category used some variation on these methods.</p>
<h3 id="continuous-constraining">continuous CONSTRAINING</h3>
<p>A good plan proved to be to systematically progress through the coin bag in an orderly fashion from high to low or vice versa, restricting the coins passed forward to either those of the same value or further along in the order. This eliminates the permuted solutions and provides a nice visual sort to the output at the same time, revealing the underlying patterns behind the sets.</p>
<p>Here it is, with commentary, explained by <strong>Simon Green</strong>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">_calculate</span> {
    <span style="color:#66d9ef">my</span> ( $coins, $sofar, $remaining_amount ) <span style="color:#f92672">=</span> @_;
    <span style="color:#66d9ef">my</span> @solutions <span style="color:#f92672">=</span> ();

    <span style="color:#75715e"># To ensure we don&#39;t get duplicate results (e.g 2 + 4 / 4 + 2), we</span>
    <span style="color:#75715e">#  only consider coins greater than or equal to the last used coin</span>
    <span style="color:#66d9ef">my</span> $last_coin <span style="color:#f92672">=</span> scalar(@$sofar) ? $sofar<span style="color:#f92672">-&gt;</span>[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] : <span style="color:#ae81ff">0</span>;

    <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $coin (@$coins) {
        <span style="color:#66d9ef">next</span> <span style="color:#66d9ef">if</span> $coin <span style="color:#f92672">&lt;</span> $last_coin;

        <span style="color:#66d9ef">if</span> ( $coin <span style="color:#f92672">&lt;</span> $remaining_amount ) {
            <span style="color:#75715e"># We need to find some more coins</span>
            push @solutions,
              _calculate(
                $coins,
                [ @$sofar, $coin ],
                $remaining_amount <span style="color:#f92672">-</span> $coin
              );
        }
        <span style="color:#66d9ef">elsif</span> ( $coin <span style="color:#f92672">==</span> $remaining_amount ) {
            <span style="color:#75715e"># We have a solution!</span>
            push @solutions, [ @$sofar, $coin ];
            <span style="color:#75715e"># Higher coins will exceed the remaining amount</span>
            <span style="color:#66d9ef">last</span>;
        }
        <span style="color:#66d9ef">else</span> {
            <span style="color:#75715e"># This coin (and all larger coins) will exceed the remaining amount</span>
            <span style="color:#66d9ef">last</span>;
        }
    }
    <span style="color:#66d9ef">return</span> @solutions;
}
</code></pre></div><p>for
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/colin-crain/perl/ch-1.pl"><strong>My Own Solution</strong></a>
I did something similar, restricting the coin bag both by removing coins greater than the running remaining total and then again by filtering the passed-on coins to only those of the currently added coin or smaller.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">get_coin_groups</span> {
    <span style="color:#66d9ef">my</span> ($amt, $group, $bag) <span style="color:#f92672">=</span> @_;
    $group <span style="color:#e6db74">//</span><span style="color:#f92672">=</span> <span style="color:#f92672">[]</span>;
    $bag     <span style="color:#e6db74">//</span><span style="color:#f92672">=</span> <span style="color:#f92672">\</span>@coins;

    <span style="color:#75715e">## base case, cashed out</span>
    <span style="color:#66d9ef">if</span> ($amt <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
        push @solutions, $group;
        <span style="color:#66d9ef">return</span>;
    }

    <span style="color:#75715e">## limit coin bag to those smaller or equal to the current amount</span>
    <span style="color:#66d9ef">my</span> @coin_bag <span style="color:#f92672">=</span> grep { $_ <span style="color:#f92672">&lt;=</span> $amt } $bag<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>

    <span style="color:#960050;background-color:#1e0010">##</span> edge <span style="color:#66d9ef">case</span>, cannot complete group with remaining coins
    <span style="color:#66d9ef">if</span> (@coin_bag <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
        <span style="color:#66d9ef">return</span>;
    }

    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $coin ( @coin_bag ) {
        <span style="color:#75715e">## limit coin bag to this coin or smaller</span>
        <span style="color:#75715e">## keeps groups ordered and disallows duplicate rearrangements</span>
        <span style="color:#66d9ef">my</span> @smaller_coin_bag <span style="color:#f92672">=</span> grep { $_ <span style="color:#f92672">&lt;=</span> $coin } $bag<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>
        get_coin_groups( $amt <span style="color:#f92672">-</span> $coin, [@$group, $coin], <span style="color:#f92672">\</span>@smaller_coin_bag );
    }
}
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/jeongoon/perl/ch-1.pl"><strong>Myoungjin Jeon</strong></a> and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/laurent-rosenfeld/perl/ch-1.pl"><strong>Laurent Rosenfeld</strong></a> constricted their paths along similar lines, controlling the coin bag. Laurent goes into some detail on developing his solution in a <a href="http://blogs.perl.org/users/laurent_r/2020/08/perl-weekly-challenge-75-coin-sums-and-largest-rectangle-histogram.html">blog post on the subject</a></p>
<p>In several of the challenges from previous weeks, a recurring method of nested <code>map</code> functions in a recursion routine often arose to make combination arrays. This too arose here to develop our coin lists.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/jo-37/perl/ch-1.pl"><strong>Jorg Sommrey&rsquo;s</strong></a>
<code>assemble</code> routine
gives us a tight functional example of this type of solution, reducing the available options in the coin bag as recursing progresses.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">assemble</span> {
    <span style="color:#66d9ef">my</span> ($sum, @coins) <span style="color:#f92672">=</span> @_;

    <span style="color:#75715e"># There is no solution if the sum is less than the smallest coin.</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">if</span> $sum <span style="color:#f92672">&lt;</span> min @coins;

    <span style="color:#75715e"># If a coin matches the given sum, this gives one (non-recursive)</span>
    <span style="color:#75715e"># assembly.</span>
    ((any {$sum <span style="color:#f92672">==</span> $_} @coins) ? [$sum] : (),
    <span style="color:#75715e"># Try each coin for further assemblies.</span>
    map {
        <span style="color:#66d9ef">my</span> $coin <span style="color:#f92672">=</span> $_;
        <span style="color:#75715e"># Reduce the sum by the selected coin and combine that one with</span>
        <span style="color:#75715e"># all possible assemblies of the reduced sum using solely coins</span>
        <span style="color:#75715e"># that are not smaller than the selected.</span>
        map [$coin, @$_], assemble $sum <span style="color:#f92672">-</span> $coin, grep $_ <span style="color:#f92672">&gt;=</span> $coin, @coins;
    } @coins);
}
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/james-smith/perl/ch-1.pl"><strong>James Smith&rsquo;s</strong></a> nested maps were considerably condensed even from this, albeit at the cost of clarity:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">csm</span> {
  <span style="color:#66d9ef">my</span> $t <span style="color:#f92672">=</span> shift;
  <span style="color:#66d9ef">return</span> @{$mem{<span style="color:#e6db74">&#34;$t @_&#34;</span>}<span style="color:#f92672">||=</span>[map {<span style="color:#66d9ef">my</span> $a<span style="color:#f92672">=</span>$_; $t<span style="color:#f92672">==</span>$a?[$a]:
    map {[$a,@{$_}]} csm($t<span style="color:#f92672">-</span>$a,grep {$a<span style="color:#f92672">&lt;=</span>$_<span style="color:#f92672">&amp;&amp;</span>$_<span style="color:#f92672">&lt;=</span>$t} @_)} @_] };
}
</code></pre></div><h3 id="memoize-it">MEMOIZE it!</h3>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/athanasius/perl/ch-1.pl"><strong>Athanasius</strong></a>
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/e-choroba/perl/ch-1.pl"><strong>E. Choroba</strong></a></p>
<p>An excellent way to speed things up was to remember the recursions of the driver routine, so should the same conditions arise a second time, the memoized version is returned rather than recomputing the result. This, although not quite as formally, dovetails quite nicely into the dynamic programming examples brought up previously, as we are in the end using the results of smaller parts of the large calculation to assemble solutions.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">use</span> Memoize;                        <span style="color:#75715e"># memoize()</span>
memoize(<span style="color:#e6db74">&#39;count_coin_combinations&#39;</span>);

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">count_coin_combinations</span>         # Recursive function
{
    <span style="color:#66d9ef">my</span> ($target, $coin, @coins) <span style="color:#f92672">=</span> @_;
    <span style="color:#66d9ef">my</span>  $sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

    <span style="color:#66d9ef">if</span> (scalar @coins)              <span style="color:#75715e"># There are more coins to process</span>
    {
        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i (<span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> int($target <span style="color:#f92672">/</span> $coin))
        {
            <span style="color:#66d9ef">my</span> $new_target <span style="color:#f92672">=</span> $target <span style="color:#f92672">-</span> ($i <span style="color:#f92672">*</span> $coin);
            <span style="color:#66d9ef">if</span> ($new_target <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)   <span style="color:#75715e"># Base case 1: target already reached</span>
            {
                <span style="color:#f92672">++</span>$sum;
            }
            <span style="color:#66d9ef">else</span>                    <span style="color:#75715e"># Recursive case</span>
            {
                $sum <span style="color:#f92672">+=</span> count_coin_combinations($new_target, @coins);
            }
        }
    }
    <span style="color:#66d9ef">else</span>                            <span style="color:#75715e"># Base case 2: no more coins</span>
    {
        $sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">if</span> $target % <span style="color:#960050;background-color:#1e0010">$</span>coin <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>;
    }
    <span style="color:#66d9ef">return</span> $sum;
}
</code></pre></div><h2 id="rare-and-unusual-delights">RARE and UNUSUAL DELIGHTS</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/adam-russell/perl/ch-1.pl"><strong>Adam Russell</strong></a></p>
<p>use AI::Prolog;
use Hash::MultiKey;</p>
<p>Adam has given us a Prolog logic program to solve the challenge. I&rsquo;ll have to leave it at that, and point interested parties to it. It&rsquo;s fascinating as far as I&rsquo;mm concerned. As I&rsquo;ve said before, Perl makes the best glue.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">use</span> AI::Prolog;
<span style="color:#66d9ef">use</span> Hash::MultiKey;

MAIN:{
    <span style="color:#66d9ef">my</span> $S <span style="color:#f92672">=</span> $ARGV[<span style="color:#ae81ff">0</span>];
    <span style="color:#66d9ef">my</span> $C <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;[&#34;</span> <span style="color:#f92672">.</span> $ARGV[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34;]&#34;</span>;

    <span style="color:#66d9ef">my</span> $prolog <span style="color:#f92672">=</span> <span style="color:#66d9ef">do</span>{
        local $/;
        <span style="color:#e6db74">&lt;DATA&gt;</span>;
    };
    $prolog <span style="color:#f92672">=~</span> <span style="color:#e6db74">s/_COINS_/$C/g</span>;
    $prolog <span style="color:#f92672">=~</span> <span style="color:#e6db74">s/_SUM_/$S/g</span>;
    $prolog <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> AI::Prolog($prolog);
    $prolog<span style="color:#f92672">-&gt;</span>query(<span style="color:#e6db74">&#34;sum(Coins).&#34;</span>);
    <span style="color:#66d9ef">my</span> %h;
    tie %h, <span style="color:#e6db74">&#34;Hash::MultiKey&#34;</span>;
    <span style="color:#66d9ef">while</span>(<span style="color:#66d9ef">my</span> $result <span style="color:#f92672">=</span> $prolog<span style="color:#f92672">-&gt;</span>results){
        <span style="color:#66d9ef">my</span> @s <span style="color:#f92672">=</span> sort @{$result<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>]};
        $h{<span style="color:#f92672">\</span>@s} <span style="color:#f92672">=</span> undef;
    }
    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $k (keys %h){
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;(&#34;</span> <span style="color:#f92672">.</span> join(<span style="color:#e6db74">&#34;,&#34;</span>, @{$k}) <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34;)&#34;</span>;
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;\n&#34;</span>;
    }
}

__DATA__
member(X,[X<span style="color:#f92672">|</span>_])<span style="color:#f92672">.</span>
member(X,[_<span style="color:#f92672">|</span>T]) :<span style="color:#f92672">-</span> member(X,T)<span style="color:#f92672">.</span>

coins(_COINS_)<span style="color:#f92672">.</span>

sum(Coins):<span style="color:#f92672">-</span>
    sum(<span style="color:#f92672">[]</span>, Coins, <span style="color:#ae81ff">0</span>)<span style="color:#f92672">.</span>

sum(Coins, Coins, _SUM_)<span style="color:#f92672">.</span>

sum(Partial, Coins, Sum):<span style="color:#f92672">-</span>
    Sum <span style="color:#f92672">&lt;</span> _SUM_,
    coins(L),
    member(X,L),
    S is Sum <span style="color:#f92672">+</span> X,
    sum([X <span style="color:#f92672">|</span> Partial], Coins, S)<span style="color:#f92672">.</span>
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/pete-houston/perl/ch-1.pl"><strong>Pete Houston</strong></a></p>
<p>The <a href="https://en.wikipedia.org/wiki/Knapsack_problem">knapsack problem</a>, which we visited once before in PWC #036, asked that given a bunch of items with a given weight, how many objects can be placed in a knapsack without exceeding a limit. This is obviously similar the problem of selecting a set of coins equal to a certain value, and if we constrain the solutions to only those that <em>equal</em> our target value, rather than approach, then any methods to solve the one can solve the other.</p>
<p>Enter the <code>Algorithm::Knapsack</code> module. Pete whips this baby out and neatly fillets the problem into a plate of perfect sashimi bites. All he needs to do is produce a bag containing enough coins of each value to meet the target on their own; providing this to the algorithm produces the best answers. All he needs to do <em>(hint, hint)</em> is filter the results to make sure they do sum to the target, as the classic knapsack problem only wishes to find the <em>best</em> fit, rather than a <em>perfect</em> fit.</p>
<hr>
<h1 id="PWC075TASK2">TASK #2 › Largest Rectangle Histogram</h1>
<p>You are given an array of positive numbers @A.
Write a script to find the larget rectangle histogram created by the
given array.</p>
<p>BONUS: Try to print the histogram as shown in the example, if
possible.</p>
<p><strong>Example 1:</strong></p>
<p>Input: @A = (2, 1, 4, 5, 3, 7)</p>
<pre><code>      7           #
      6           #
      5       #   #
      4     # #   #
      3     # # # #
      2 #   # # # #
      1 # # # # # #
      _ _ _ _ _ _ _
        2 1 4 5 3 7
</code></pre><p>Looking at the above histogram, the largest rectangle (4 x 3) is
formed by columns (4, 5, 3 and 7).</p>
<p>Output: 12</p>
<p><strong>Example 2:</strong></p>
<p>Input: @A = (3, 2, 3, 5, 7, 5)</p>
<pre><code>      7         #
      6         #
      5       # # #
      4       # # #
      3 #   # # # #
      2 # # # # # #
      1 # # # # # #
      _ _ _ _ _ _ _
        3 2 3 5 7 5
</code></pre><p>Looking at the above histogram, the largest rectangle (3 x 5) is
formed by columns (5, 7 and 5).</p>
<p>Output: 15</p>
<h2 id="about-the-solutions">ABOUT the solutions</h2>
<p>The <strong>27</strong> submissions to Challenge #2  were much more wide ranging than I would have expected. It&rsquo;s funny, when you frame a solution out in your mind you naturally assume that the underlying logic will permeate through alternate viewpoints. This mostly bears out in practice, but that supposition hasn&rsquo;t held as true this week as in weeks past, defying easy categorization to the results. So the only thing I can do is touch on a few of the larger points, as there is no way for me to do justice to the full gamut, which is a shame. As the number of submissions increases, I will do my best to highlight what I can, to help people see the different ways to solve the tasks.</p>
<h2 id="iterate-through-slices-find-width-times-the-minimum-height">ITERATE through SLICES, find WIDTH times the MINIMUM HEIGHT</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/adam-russell/perl/ch-2.pl"><strong>Adam Russell</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/james-smith/perl/ch-2.pl"><strong>James Smith</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/laurent-rosenfeld/perl/ch-2.pl"><strong>Laurent Rosenfeld</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/roger-bell-west/perl/ch-2.pl"><strong>Roger Bell_West</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/shawn-wagner/perl/ch-2.pl"><strong>Shawn Wagner</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/sgreen/perl/ch-2.pl"><strong>Simon Green</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/ulrich-rieke/perl/ch-2.pl"><strong>Ulrich Rieke</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/walt-mankowski/perl/ch-2.pl"><strong>Walt Mankowski</strong></a> and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/colin-crain/perl/ch-2.pl"><strong>My Own Solution</strong></a></p>
<p>A very direct and straightforward approach to finding the larget rectangle is to systematically examine every available set of points defining a width, then find the minimum value within that span, which will define the height. Setting up two nested loops to establish the endpoints, we can use these to extract an array slice holding all of the relevant elements.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/roger-bell-west/perl/ch-2.pl"><strong>Roger Bell_West</strong></a>
and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/laurent-rosenfeld/perl/ch-2.pl"><strong>Laurent Rosenfeld</strong></a>
both strip this idea down to the bare essentials. Here&rsquo;s Roger&rsquo;s version, although Laurent&rsquo;s is nearly identical. Once you have things this tight, there often is very little variance.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $a ( <span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$#c <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> ) {
    <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $b ( $a <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$#c ) {
        <span style="color:#66d9ef">my</span> $area <span style="color:#f92672">=</span> ( $b <span style="color:#f92672">-</span> $a <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> )<span style="color:#f92672">*</span>min( @c[$a<span style="color:#f92672">..</span>$b] );
        <span style="color:#66d9ef">if</span> ( $area <span style="color:#f92672">&gt;</span> $bestarea ) {
            $bestarea <span style="color:#f92672">=</span> $area;
            @n <span style="color:#f92672">=</span> ( $a, $b );
        }
    }
}
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/colin-crain/perl/ch-2.pl"><strong>My Own Solution</strong></a></p>
<p>allowed for the option to have multiple rectangles of the same (largest) size, the array structures that keeps all the information to report are kept in the <code>@largest</code> array. I believe only
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/perlboy1967/perl/ch-2.pl"><strong>Niels van Dijke</strong></a>
also did this, but I didn&rsquo;t run that test through everyone&rsquo;s code.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $start (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>@A<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>) {
    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $end ($start<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>@A<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
        <span style="color:#66d9ef">my</span> $min <span style="color:#f92672">=</span> min @A[$start<span style="color:#f92672">..</span>$end];
        push @windows, [$min<span style="color:#f92672">*</span>($end<span style="color:#f92672">-</span>$start<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>), $start, $end, $min];
    }
}

<span style="color:#66d9ef">my</span> @sorted  <span style="color:#f92672">=</span> sort { $b<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] <span style="color:#e6db74">&lt;=&gt;</span> $a<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>]        } @windows;
<span style="color:#66d9ef">my</span> @largest <span style="color:#f92672">=</span> grep { $_<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> $sorted[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] } @sorted;
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/shawn-wagner/perl/ch-2.pl"><strong>Shawn Wagner</strong></a></p>
<p>Shawn took an interesting tangent, using three loops to get he job done: one to incrementally progress from the left edge, another inside to check heights up to the value of the given index, and a third to see how far that window extends to the right.</p>
<p>It&rsquo;s worth mentioning there were answers involving even more looping, but they all worked on the examples given. Generally complexity increases with each loop, leading to bogging down should the dataset get large.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">task2</span> {
  <span style="color:#66d9ef">my</span> @A <span style="color:#f92672">=</span> @_;
  histogram @A;
  <span style="color:#66d9ef">my</span> $maxsize <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $left (<span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $#A) {
    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $top (<span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> $A[$left]) {
      <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $right ($left<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> $#A) {
        <span style="color:#66d9ef">last</span> <span style="color:#66d9ef">if</span> ($A[$right] <span style="color:#f92672">&lt;</span> $top);
        <span style="color:#66d9ef">my</span> $size <span style="color:#f92672">=</span> ($right <span style="color:#f92672">-</span> $left <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> $top;
        $maxsize <span style="color:#f92672">=</span> max $maxsize, $size;
      }
    }
  }
  say <span style="color:#e6db74">&#34;Largest rectangle area: $maxsize&#34;</span>;
}

</code></pre></div><h2 id="find-the-largest-window-around-a-given-index">find the LARGEST WINDOW around a given INDEX</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/athanasius/perl/ch-2.pl"><strong>Athanasius</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/mohammad-anwar/perl/ch-2.pl"><strong>Mohammad S Anwar</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/yet-ebreo/perl/ch-2.pl"><strong>Yet Ebreo</strong></a> , and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/wanderdoc/perl/ch-2.pl"><strong>Wanderdoc</strong></a></p>
<p>Of course examining every possible window and finding the minimum value for a height isn&rsquo;t the only way to do things. There&rsquo;s a lot of checking values larger than the minimum value in the examples above before we decide that there&rsquo;s nothing smaller. It&rsquo;s effective, but perhaps we could reverse this. After all, every minimum found in the end is going to be the value of one position or another. Why not asume each element to be a minimum, and find the area of the largest span with that height? We can do that by looking to the left and the right until we find the last element that is greater than the given value; these will be our boundaries.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/mohammad-anwar/perl/ch-2.pl"><strong>Mohammad S Anwar</strong></a></p>
<p>takes this approach. He creates a pair of matching functions, <code>go_left</code> and <code>go_right</code>, that count the number of positions that can be travelled to the left or right, respectively, before a value less than the of the given index is found. Here&rsquo;s one:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">go_left</span> {
    <span style="color:#66d9ef">my</span> ($i, $list) <span style="color:#f92672">=</span> @_;

    <span style="color:#66d9ef">my</span> $c <span style="color:#f92672">=</span> $list<span style="color:#f92672">-&gt;</span>[$i];
    <span style="color:#66d9ef">my</span> $j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">while</span> ($i <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
        $i<span style="color:#f92672">--</span>;
        <span style="color:#66d9ef">last</span> <span style="color:#66d9ef">if</span> ($list<span style="color:#f92672">-&gt;</span>[$i] <span style="color:#f92672">&lt;</span> $c);
        $j<span style="color:#f92672">++</span>;
    }

    <span style="color:#66d9ef">return</span> $j;
}
</code></pre></div><p>The area can then be found by simply multiplying the height of the element (<em>hint, hint</em>) by the width of the window found.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/wanderdoc/perl/ch-2.pl"><strong>Wanderdoc</strong></a></p>
<p>gave us a very similar solution, here&rsquo;s his corresponding left-hand search:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i ( <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $#arr )
{
     <span style="color:#66d9ef">while</span> ( scalar @left <span style="color:#f92672">and</span> $arr[$i] <span style="color:#f92672">&lt;=</span> $arr[$left[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]] )
     {
          pop @left;
     }

     <span style="color:#66d9ef">if</span> ( <span style="color:#ae81ff">0</span> <span style="color:#f92672">==</span> scalar @left )
     {
          $width[$i] <span style="color:#f92672">+=</span> $i;
     }
     <span style="color:#66d9ef">else</span>
     {
          $width[$i] <span style="color:#f92672">+=</span> $i <span style="color:#f92672">-</span> $left[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
     }
     push @left, $i;
}

</code></pre></div><p>But that wasn&rsquo;t the only way to examine every window of a given height, however.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/yet-ebreo/perl/ch-2.pl"><strong>Yet Ebreo</strong></a></p>
<p>had an interesting variation for us. We start at the beginning of the list, iterating through the elements in the usual manner. Then for each element we traverse the list again, one position at a time. If the value is greater than or equal to the given element, we increment a counter; if not, that is the largest window containing that index. The area is the height, the value of the index, times the counter, or span. The counter is reset after the area is added to a result array and the process continues; in this way we are assured the window over the given element is assessed.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $f (@R) {
    <span style="color:#66d9ef">my</span> $s <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $e (@R) {
        <span style="color:#66d9ef">if</span> ($e <span style="color:#f92672">&gt;=</span> $f) {
            $s<span style="color:#f92672">++</span>
        } <span style="color:#66d9ef">else</span> {
            push @res, $s <span style="color:#f92672">*</span> $f;
            $s <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        }
    }
    push @res, $s <span style="color:#f92672">*</span> $f;
}
</code></pre></div><h2 id="the-on-solution">the O(n) solution</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/e-choroba/perl/ch-2.pl"><strong>E. Choroba</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/javier-luque/perl/ch-2.pl"><strong>Javier Luque</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/lubos-kolouch/perl/ch-2.pl"><strong>Lubos Kolouch</strong></a></p>
<p>There is a best time solution that several people implemented. This is strightforward but not the most intuitive thing. It involves progressing from left to right, keeping a stack containing the indexes of values smaller than the current maximum, and a counter keeping track of how long the current maximum has lasted, being the difference between the current index and the last element on the stack. When incrementing the index <em>decreases</em> the value below the current maximum, the area is calculated for the current maximum times the span and the maximum is reset to the value at the index. The stack is popped, increasing the counter more, until a value less than the new maximum is found. This determines a new height and span, and the new area is calculated, and noted if it exceeds the previous maximum. Depending on whether the next index increases or decreases against the current maximum, the progression continues in this manner. If the end of the array is reached, the maximum goes to minimum, and the second option in the algorithm engages until the stack is empty, indicating we have reached the end and there are no more rectangles to calculate. We are left with the maximum area found.</p>
<p>Whew! Implementation aside, I&rsquo;m pretty sure I got all the salient points across in that. It&rsquo;s quite elegant once you wrap your head around it.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/javier-luque/perl/ch-2.pl"><strong>Javier Luque</strong></a> and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/lubos-kolouch/perl/ch-2.pl"><strong>Lubos Kolouch</strong></a>
gave us very similar solutions; here&rsquo;s Lubos&rsquo; version to peruse:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">while</span> ($index <span style="color:#f92672">&lt;</span> scalar @$histogram) {
    <span style="color:#66d9ef">if</span> ( (<span style="color:#f92672">not</span> @stack) <span style="color:#f92672">or</span> ($histogram<span style="color:#f92672">-&gt;</span>[$stack[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]] <span style="color:#f92672">&lt;=</span> $histogram<span style="color:#f92672">-&gt;</span>[$index]) ) {
        push @stack, $index;
        $index <span style="color:#f92672">++</span>;
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#66d9ef">my</span> $top_of_stack <span style="color:#f92672">=</span> pop @stack;
        <span style="color:#66d9ef">my</span> $area <span style="color:#f92672">=</span> @stack ? $histogram<span style="color:#f92672">-&gt;</span>[$top_of_stack] <span style="color:#f92672">*</span> ($index <span style="color:#f92672">-</span> $stack[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) : $index;

        $max_area <span style="color:#f92672">=</span> max($max_area, $area);
    }
}

<span style="color:#66d9ef">while</span> (@stack) {
        <span style="color:#66d9ef">my</span> $top_of_stack <span style="color:#f92672">=</span> pop @stack;
        <span style="color:#66d9ef">my</span> $area <span style="color:#f92672">=</span> @stack ? $histogram<span style="color:#f92672">-&gt;</span>[$top_of_stack] <span style="color:#f92672">*</span> ($index <span style="color:#f92672">-</span> $stack[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) : $index;

        $max_area <span style="color:#f92672">=</span> max($max_area, $area);
}
printHistogram($histogram);

</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/e-choroba/perl/ch-2.pl"><strong>E. Choroba</strong></a></p>
<p>did things a little bit differently, but close examination will reveal the similarities:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">largest_rectangle</span> {
    <span style="color:#66d9ef">my</span> @columns <span style="color:#f92672">=</span> @_;
    <span style="color:#66d9ef">my</span> @smallest;
    <span style="color:#66d9ef">my</span> $max <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">my</span> $column <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">while</span> ($column <span style="color:#f92672">&lt;=</span> $#columns) {
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span> @smallest <span style="color:#f92672">||</span> $columns[$column] <span style="color:#f92672">&gt;</span> $columns[ $smallest[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] ]) {
            push @smallest, $column<span style="color:#f92672">++</span>;
        } <span style="color:#66d9ef">else</span> {
            _pop(<span style="color:#f92672">\</span>$max, <span style="color:#f92672">\</span>@smallest, <span style="color:#f92672">\</span>@columns, $column);
        }
    }
    _pop(<span style="color:#f92672">\</span>$max, <span style="color:#f92672">\</span>@smallest, <span style="color:#f92672">\</span>@columns, $column) <span style="color:#66d9ef">while</span> @smallest;
    <span style="color:#66d9ef">return</span> $max
}

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">_pop</span> {
    <span style="color:#66d9ef">my</span> ($max, $smallest, $columns, $column) <span style="color:#f92672">=</span> @_;
    <span style="color:#66d9ef">my</span> $s <span style="color:#f92672">=</span> pop @$smallest;
    <span style="color:#66d9ef">my</span> $area <span style="color:#f92672">=</span> $columns<span style="color:#f92672">-&gt;</span>[$s] <span style="color:#f92672">*</span> ($column <span style="color:#f92672">-</span> ($smallest<span style="color:#f92672">-&gt;</span>[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#e6db74">//</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
    $$max <span style="color:#f92672">=</span> $area <span style="color:#66d9ef">if</span> $area <span style="color:#f92672">&gt;</span> $$max;
}

</code></pre></div><h2 id="the-histogram-drawing">the HISTOGRAM DRAWING</h2>
<p>Most who went for the bonus did so by using either looped <code>print</code> or a more complex <code>sprintf</code> statement, starting from the largest value in the input array and decrementing a counter, outputting lines one by one until 0 is reached. In each line, any element whose value exceeds that count gets a &lsquo;#', if not, a space instead. A little careful formatting will keep the #s lined up vertically.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/adam-russell/perl/ch-2.pl"><strong>Adam Russell</strong></a></p>
<p>gives us an example of using <code>print</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">while</span>($x <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">1</span>){
    <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;$x &#34;</span>;
    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $h (@{$values}){
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;# &#34;</span> <span style="color:#66d9ef">if</span> $h <span style="color:#f92672">&gt;=</span> $x;
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;  &#34;</span> <span style="color:#66d9ef">if</span> $h <span style="color:#f92672">&lt;</span> $x;
    }
    <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;\n&#34;</span>;
    $x<span style="color:#f92672">--</span>;
}
</code></pre></div><p>The whole process can even be wrapped up in a mapping operation, as demonstrated here by</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/e-choroba/perl/ch-2.pl"><strong>E. Choroba</strong></a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">say join <span style="color:#e6db74">&#39; &#39;</span>, map {
    sprintf <span style="color:#e6db74">&#34;%${max_length}s&#34;</span>, $columns[$_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">&gt;=</span> $y ? <span style="color:#e6db74">&#39;#&#39;</span> : <span style="color:#e6db74">&#39; &#39;</span>
} <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> @columns;
</code></pre></div><p>Now I don&rsquo;t want to take sides, and apologies to Jorg here, because it was close, but I have to say I think the award for <em>prettiest</em> output has to go to</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/perlboy1967/perl/ch-2.pl"><strong>Niels van Dijke</strong></a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">printHistogram</span> ( \@$$\@ ) {
    <span style="color:#66d9ef">my</span> ( $arA, $surface, $surfaceHeight, $arIndexes ) <span style="color:#f92672">=</span> @_;

    <span style="color:#66d9ef">if</span> ( defined $surfaceHeight ) {
        printf <span style="color:#e6db74">&#34;\nSurface size: %d ( %d x %d )\n\n&#34;</span>,
                     $surface,
                     scalar @$arIndexes, $surfaceHeight;
    }

    <span style="color:#66d9ef">my</span> $max <span style="color:#f92672">=</span> max( @$arA );
    <span style="color:#66d9ef">my</span> $yLw <span style="color:#f92672">=</span> length( $max );

    <span style="color:#66d9ef">my</span> %indexes <span style="color:#f92672">=</span> map {  $_ <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">1</span>  } @$arIndexes;

    <span style="color:#75715e"># Print historgram rows</span>
    <span style="color:#66d9ef">for</span> ( <span style="color:#66d9ef">my</span> $row <span style="color:#f92672">=</span> $max; $row <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>; $row<span style="color:#f92672">--</span> ) {
        <span style="color:#66d9ef">my</span> @row <span style="color:#f92672">=</span> ( sprintf( <span style="color:#e6db74">&#34;%${ yLw }s&#34;</span>, $row ), <span style="color:#e6db74">&#39;|&#39;</span> );
        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $col ( <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> scalar( @$arA ) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> ) {
            <span style="color:#66d9ef">if</span> ( $arA<span style="color:#f92672">-&gt;</span>[$col] <span style="color:#f92672">&lt;</span> $row ) {
                push( @row, <span style="color:#e6db74">&#39; &#39;</span> );
            } <span style="color:#66d9ef">else</span> {
                push( @row, ( <span style="color:#f92672">!</span>exists $indexes{ $col } <span style="color:#f92672">||</span>
                                        $row <span style="color:#f92672">&gt;</span> $surfaceHeight ? <span style="color:#e6db74">&#39;#&#39;</span> : <span style="color:#e6db74">&#39;O&#39;</span> ) );
            }
        }
        <span style="color:#66d9ef">print</span> join( <span style="color:#e6db74">&#34; &#34;</span>, @row )<span style="color:#f92672">.</span><span style="color:#e6db74">&#34;\n&#34;</span>;
    }

    <span style="color:#75715e"># Print X-axis</span>
    <span style="color:#66d9ef">print</span> sprintf( <span style="color:#e6db74">&#34;%${ yLw }s +%s\n&#34;</span>,
                                <span style="color:#e6db74">&#39;&#39;</span>,
                                join( <span style="color:#e6db74">&#39;-&#39;</span>, map {  <span style="color:#e6db74">&#39;-&#39;</span>  } @$arA, <span style="color:#e6db74">&#39;&#39;</span> ) );

    <span style="color:#75715e"># Print X labels</span>
    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $l ( <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $yLw <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> ) {
        <span style="color:#66d9ef">print</span> sprintf( <span style="color:#e6db74">&#34;%${ yLw }s     %s\n&#34;</span>,
                                    <span style="color:#e6db74">&#39;&#39;</span>,
                                    join( <span style="color:#e6db74">&#39; &#39;</span>, map {  substr( $_<span style="color:#f92672">.</span><span style="color:#e6db74">&#39; &#39;</span> x $yLw, $l, <span style="color:#ae81ff">1</span> )  } @$arA ) );
    }
}

</code></pre></div><p>because it looks like this:</p>
<pre><code>Surface size: 18 (3 x 6)

12 |             #
11 |             #
10 |             #
 9 |             #
 8 |             #
 7 |             #
 6 |     #   O O O
 5 |     #   O O O
 4 |     #   O O O   #
 3 |   # #   O O O # #
 2 |   # # # O O O # #
 1 | # # # # O O O # #
   +-------------------
     1 3 6 2 6 6 1 3 4
                 2
</code></pre><p>He even handles multiple equivalent outputs. It just looks&hellip; <em>nice</em>. Well done.</p>
<h2 id="unique-approaches-standing-in-a-field-of-unicorns">UNIQUE approaches STANDING in a FIELD OF UNICORNS</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/alexander-pankoff/perl/ch-2.pl"><strong>Alexander Pankoff</strong></a></p>
<p>Alexander presents us with a very clever recursive solution. Every called execution chooses the largest rectangle between three options: a range, the returned value for a slice removing one element at the beginning, or the same for a slice removing one element at the end. Through this method of division all slices are eventually examined, and the largest propagated out until a winner emerges. Very nice.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">largest_rectangle</span>(@cols) {
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">unless</span> @cols;

    max(
        rectangle_size( @cols ),
        largest_rectangle( @cols[ <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> $#cols ] ),
        largest_rectangle( @cols[ <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> ( $#cols <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> ) ] )
    );
}

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">rectangle_size</span>(@cols) {
    <span style="color:#66d9ef">return</span> scalar @cols <span style="color:#f92672">*</span> min @cols;
}

</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/duncan-c-white/perl/ch-2.pl"><strong>Duncan C. White</strong></a></p>
<p>gives us a nice variant, a State Machine to keep track of when we&rsquo;re in a rectangle to be evaluated:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">fun rectangleareasofheight( $h, @value )
{
    <span style="color:#75715e"># want to locate runs of adjacent values &gt;= $h, each such run has</span>
    <span style="color:#75715e"># a width, that w * h is the area.  use a 2-state state machine:</span>
    <span style="color:#75715e"># state 0 is: not currently in such a run.</span>
    <span style="color:#75715e"># state 1 is: currently in such a run, $area is the current area of the run.</span>
    <span style="color:#66d9ef">my</span> @result;
    <span style="color:#66d9ef">my</span> $state <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">my</span> $area <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $v (@value)
    {
        <span style="color:#75715e">#say &#34;debug: state=$state, v=$v, h=$h, area=$area&#34;;</span>
        <span style="color:#66d9ef">if</span>( $state <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> $v<span style="color:#f92672">&gt;=</span>$h )
        {
            <span style="color:#75715e"># enter state 1, start counting the area</span>
            $state<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>; $area<span style="color:#f92672">=</span>$h;
        } <span style="color:#66d9ef">elsif</span>( $state <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> $v<span style="color:#f92672">&gt;=</span>$h )
        {
            <span style="color:#75715e"># stay in state 1: increase the area</span>
            $area<span style="color:#f92672">+=</span>$h;
        } <span style="color:#66d9ef">elsif</span>( $state <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> $v<span style="color:#f92672">&lt;</span>$h )
        {
            <span style="color:#75715e"># finish one run, revert to state 0</span>
            push @result, $area;
            <span style="color:#75715e">#say &#34;height $h: run area: $area, back to state 0 at value $v&#34;;</span>
            $state <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; $area <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        }
    }
    <span style="color:#75715e"># final possible extra area..</span>
    <span style="color:#66d9ef">if</span>( $state <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> )
    {
        push @result, $area;
        <span style="color:#75715e">#say &#34;height $h: run area: $area&#34;;</span>
    }
    <span style="color:#66d9ef">return</span> @result;
}
</code></pre></div><p>I like this approach.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/jo-37/perl/ch-2.pl"><strong>Jorg Sommrey</strong></a></p>
<p>I knew I couldn&rsquo;t have been the only person who thought to write a Rectangle class to help solve this problem. I toyed with the idea and ultimately abandoned it, but Jorg here has gone and followed through.</p>
<p>**Kurtz: &ldquo;The will to do that! Perfect, genuine, complete, crystalline, pure&hellip; If I had ten divisions of those men, our troubles here would be over very quickly.&rdquo; **</p>
<p>In creating his Rectangle, he provides a few overloaded functions to facilitate working with them, &lt;=&gt; to compare sizes, .= to set the position of the lower right corner, and &quot;&rdquo; to produce a stringified output of descriptives.</p>
<p>Using these tools, the basic algorithm is iterating over the elements left to right, at each point finding the largest span to the right, in this case using <code>List::Util::reduce</code> to look at every end position and propagate the larger area. It&rsquo;s well commented and I encourage others to have a look, but here is a sample for the tasting.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#75715e"># Find the largest rectangle inside a histogram.</span>
<span style="color:#75715e"># The Rectangle constructor, comparator and assignment operator</span>
<span style="color:#75715e"># are specifically designed to offer a terse implementation here.</span>
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">max_rect</span> {

    <span style="color:#75715e"># Slide over all elements seeking for the maximum rectangle</span>
    reduce {
        <span style="color:#66d9ef">my</span> $pos <span style="color:#f92672">=</span> $b;
        <span style="color:#75715e"># Slide over all windows ending at the selected position.</span>
        reduce {
            <span style="color:#75715e"># Get the maximum rectangle over the full window length.</span>
            <span style="color:#66d9ef">my</span> $rect <span style="color:#f92672">=</span> Rectangle<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">new</span>(@_[$b <span style="color:#f92672">..</span> $pos]);
            <span style="color:#75715e"># If the new rectangle is larger than the current maximum,</span>
            <span style="color:#75715e"># set the position and use it as the new maximum.</span>
            $rect <span style="color:#f92672">&gt;</span> $a ? $rect <span style="color:#f92672">.=</span> $pos : $a;
        } $a, <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $b;
    } Rectangle<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">new</span>, <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $#_;
}
</code></pre></div><hr>
<br>
<h1 id="PWC075BLOGS">BLOGS</h1>
<hr>
<p><strong>That&rsquo;s it for me this week, people!</strong></p>
<h2 id="but-if-your-thirst-for-knowledge-is-not-slaked">But if Your <em>THIRST</em> for <em>KNOWLEDGE</em> is not <em>SLAKED</em>,</h2>
<h2 id="then-run-dont-walk-to-the-watering-hole">then <em>RUN</em> <em>(dont walk!)</em> to the <em>WATERING HOLE</em></h2>
<h2 id="and-read-these-blog-links">and <em>READ</em> these <em>BLOG</em> <em>LINKS</em>:</h2>
<p><em><strong>( don&rsquo;t think, trust your training, you&rsquo;re in the zone, just do it &hellip; )</strong></em></p>
<p><strong>Adam Russell</strong></p>
<ul>
<li><a href="https://adamcrussell.livejournal.com/17614.html">All Combinations Equal to a Sum in Perl and Prolog</a> ( <em>Perl</em> )</li>
<li><a href="https://adamcrussell.livejournal.com/17720.html">Largest Rectangle Histogram</a> ( <em>Perl</em> )</li>
</ul>
<p><strong>Andrew Shitov</strong></p>
<ul>
<li><a href="https://andrewshitov.com/2020/08/29/coins-sum-the-raku-challenge-week-75-task-1/">Coins Sum: The Raku Challenge Week 75, task 1</a> ( <em>Raku</em> )</li>
<li><a href="https://andrewshitov.com/2020/08/29/largest-rectangle-histogram-the-raku-challenge-week-75-task-2/">Largest Rectangle Histogram: The Raku Challenge Week 75, task 2</a> ( <em>Raku</em> )</li>
<li><a href="https://andrewshitov.com/2020/08/30/a-more-idiomatic-raku-solution/">A more idiomatic Raku solution</a> ( <em>Raku</em> )</li>
</ul>
<p><strong>Cheok-Yin Fung</strong></p>
<ul>
<li><a href="http://blogs.perl.org/users/c_y_fung/2020/08/tc.html">Time Challenge (CY&rsquo;s Take on PWC#075 Task 1)</a> ( <em>Perl</em> )</li>
<li><a href="http://blogs.perl.org/users/c_y_fung/2020/08/how-and-what.html">How and What to do in Programming (CY&rsquo;s Take on PWC#075 Task 2)</a> ( <em>Perl</em> )</li>
</ul>
<p><strong>Colin Crain</strong></p>
<ul>
<li><a href="https://colincrain.wordpress.com/2020/08/29/throw-the-windows-wide-open-change-is-in-the-air/">Throw the Windows Wide Open -  Change Is In the Air</a> ( <em>Perl &amp; Raku</em> )</li>
</ul>
<p><strong>Javier Luque</strong></p>
<ul>
<li><a href="https://perlchallenges.wordpress.com/2020/08/28/perl-weekly-challenge-075/">PERL WEEKLY CHALLENGE – 075</a> ( <em>Perl &amp; Raku</em> )</li>
</ul>
<p><strong>Laurent Rosenfeld</strong></p>
<ul>
<li><a href="http://blogs.perl.org/users/laurent_r/2020/08/perl-weekly-challenge-75-coin-sums-and-largest-rectangle-histogram.html">Perl Weekly Challenge 75: Coin Sums and Largest Rectangle Histogram</a> ( <em>Perl &amp; Raku</em> )</li>
</ul>
<p><strong>Luca Ferrari</strong></p>
<ul>
<li><a href="https://fluca1978.github.io/2020/08/24/PerlWeeklyChallenge75.html#task1">Perl Weekly Challenge 75: nested loops - Task 1</a> ( <em>Raku</em> )</li>
<li><a href="https://fluca1978.github.io/2020/08/24/PerlWeeklyChallenge75.html#task2">Perl Weekly Challenge 75: nested loops - Task 2</a> ( <em>Raku</em> )</li>
</ul>
<p><strong>Mohammad S Anwar</strong></p>
<ul>
<li><a href="https://perlweeklychallenge.org/blog/weekly-challenge-075/">BLOG: The Weekly Challenge #075</a> ( <em>Perl &amp; Raku</em> )</li>
<li><a href="https://www.youtube.com/watch?v=DQr7xHJYZ5I">Perl Weekly Challenge - 075 (Task #1: Perl) - YouTube</a> ( <em>Perl &amp; Raku</em> )</li>
<li><a href="https://www.youtube.com/watch?v=D8jyGEQOLhk">Perl Weekly Challenge - 075 (Task #2: Perl) - YouTube</a> ( <em>Perl &amp; Raku</em> )</li>
</ul>
<p><strong>Roger Bell_West</strong></p>
<ul>
<li><a href="https://blog.firedrake.org/archive/2020/08/Perl_Weekly_Challenge_75__coins_and_rectangles.html">RogerBW's Blog: Perl Weekly Challenge 75: coins and rectangles</a> ( <em>Perl &amp; Raku</em> )</li>
</ul>
<p><strong>Shahed Nooshmand</strong></p>
<ul>
<li><a href="https://rafraichisso.ir/2020/08/26/pwc-75">The Weekly Challenge: week 75</a> ( <em>Raku</em> )</li>
</ul>
<p><strong>Simon Green</strong></p>
<ul>
<li><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-075/sgreen/README.md">Perl Weekly Challenge 075</a> ( <em>Perl</em> )</li>
</ul>
<p><strong>Walt Mankowski</strong></p>
<ul>
<li><a href="http://www.mawode.com/blog/blog/2020/08/26/perl-weekly-challenge-75/">Perl Weekly Challenge #75</a> ( <em>Perl</em> )</li>
</ul>

                </div>
            </div>
        </div>
    </div>
</section>


<!-- Call To Action Section Start -->
<section id="call-to-action">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2 class="title wow fadeInDown" data-wow-delay=".3s" data-wow-duration="500ms">SO WHAT DO YOU THINK ?</h2>
                    <p class="wow fadeInDown" data-wow-delay=".5s" data-wow-duration="500ms">If you have any suggestions or ideas then please do share with us.</p>
                    <a href="/contact" class="btn btn-default btn-contact wow fadeInDown" data-wow-delay=".7s" data-wow-duration="500ms">Contact with me</a>
                </div>
            </div>

        </div>
    </div>
</section>
<!-- Call To Action Section End -->



<!-- Footer Section Start -->
<footer id="footer">
    <div class="container">
        <div class="row content-justify-between">
            <div class="col-md-8 col-12 text-center text-lg-left text-md-left">
                <p class="copyright">Copyright:
                    <span>
                        2019 - 2025
                    </span> The Weekly Challenge. Theme Design and Developed by
                    <a href="http://www.Themefisher.com" rel="noreferrer" rel="noreferrer" target="_blank">Themefisher</a>.
                </p>
            </div>
            <div class="col-md-4 col-12">
                <!-- Social Media -->
                <ul class="social text-center text-md-right text-lg-right">
                    <li>
                        <a href="https://twitter.com/PerlWChallenge" class="twitter" rel="noreferrer" target="_blank" title="Follow us">
                            <i class="ion-social-twitter"></i>
                        </a>
                    </li>
                    <li>
                        <a href="/rss.xml" class="rss" target="_blank" title="RSS Feed">
                            <i class="ion-social-rss"></i>
                        </a>
                    </li>
                </ul>
            </div>
        </div>
    </div>
</footer>
<!-- footer section end -->

<!-- jquery -->
<script src="https://theweeklychallenge.org/plugins/jquery/jquery.min.js"></script>
<!-- Form Validation -->
<script src="https://theweeklychallenge.org/plugins/form-validation/jquery.form.min.js"></script>
<script src="https://theweeklychallenge.org/plugins/form-validation/jquery.validate.min.js"></script>
<!-- slick slider -->
<script src="https://theweeklychallenge.org/plugins/slick/slick.min.js"></script>
<!-- bootstrap js -->
<script src="https://theweeklychallenge.org/plugins/bootstrap/bootstrap.min.js"></script>
<!-- chart js -->
<script src="https://theweeklychallenge.org/plugins/chart/highstock.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/drilldown.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/data.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/chart.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/pwc-challenge.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/gc-challenge.js"></script>
<!-- wow js -->
<script src="https://theweeklychallenge.org/plugins/wow-js/wow.min.js"></script>
<!-- slider js -->
<script src="https://theweeklychallenge.org/plugins/slider/slider.js"></script>
<!-- Fancybox -->
<script src="https://theweeklychallenge.org/plugins/facncybox/jquery.fancybox.js"></script>
<!-- template main js -->

<script src="https://theweeklychallenge.org/js/script.min.js"></script>
<!-- google analitycs -->

<script async src="https://www.googletagmanager.com/gtag/js?id=G-CJTPYM9SB8"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-CJTPYM9SB8');
</script>
</body>

</html>

