<!DOCTYPE html>
<html class="no-js" lang="en-us">
<head>
    <!-- Basic Page Needs -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:title"       content="Colin Crain › Perl Weekly Review #083"/>
    <meta property="og:type"        content="website"/>
    <meta property="og:url"         content="https://theweeklychallenge.org/blog/review-challenge-083/"/>
    <meta property="og:image"       content="https://theweeklychallenge.org/images/about/about.jpg"/>
    <meta property="og:description" content="Colin Crain › Perl Weekly Review #083"/>
    <meta name="twitter:card"       content="summary" />
    <meta name="twitter:image"      content="https://theweeklychallenge.org/images/about/about.jpg"/>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <meta name="description" content="Colin Crain › Perl Weekly Review #083">
    <meta name="author" content="The Weekly Challenge Team">
    <meta name="generator" content="Hugo 0.67.0-DEV" />

    <link rel="me" href="https://fosstodon.org/@manwar">
    <link rel="canonical" href="https://theweeklychallenge.org/blog/review-challenge-083/" />

    <!-- Mobile Specific Metas -->
    <meta name="format-detection" content="telephone=no">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Colin Crain › Perl Weekly Review #083</title>
    <link rel="icon" href="https://theweeklychallenge.org/images/favicon.ico">

    
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css"/>

    <!-- Twitter Bootstrs CSS -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/bootstrap/bootstrap.min.css">
    <!-- Ionicons Fonts Css -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/ionicons/ionicons.min.css">
    <!-- animate css -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/animate-css/animate.css">
    <!-- Hero area slider css-->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/slider/slider.css">
    <!-- slick slider -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/slick/slick.css">
    <!-- Fancybox -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/facncybox/jquery.fancybox.css">
    <!-- hover -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/hover/hover-min.css">
    <!-- Google fonts -->
    <link href='https://fonts.googleapis.com/css?family=Source Code Pro' rel='stylesheet'>
    <!-- template main css file -->
    
    <link rel="stylesheet" href="https://theweeklychallenge.org/css/style.min.css" integrity="" media="screen">
    <link rel="stylesheet" href="https://theweeklychallenge.org/css/main.css">

    <style>
        #goTopButton {
            display: none;          
            position: fixed;        
            bottom: 20px;           
            right: 30px;            
            z-index: 99;            
            border: none;           
            outline: none;          
            background-color: red;  
            color: white;           
            cursor: pointer;        
            padding: 15px;          
            border-radius: 10px;    
            font-size: 18px;        
        }

        #goTopButton:hover {
              background-color: #555;
        }
    </style>


</head>

<body>

<button onclick="goTop()" id="goTopButton" title="Go to top">Top</button>

<script>

    topButton = document.getElementById("goTopButton");

    
    window.onscroll = function() { scrollFunction() };

    function scrollFunction() {
        if (document.body.scrollTop > 40 || document.documentElement.scrollTop > 40) {
            topButton.style.display = "block";
        } else {
            topButton.style.display = "none";
        }
    }

    
    function goTop() {
        document.body.scrollTop = 0; 
        document.documentElement.scrollTop = 0; 
    }

</script>

<section class="top-bar animated-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-12">
                <nav class="navbar navbar-expand-lg navbar-light bg-light">
                    <a class="navbar-brand" href="https://theweeklychallenge.org/">
                        <img src="https://theweeklychallenge.org/images/logo.svg" alt="logo">
                    </a>

                    <button class="navbar-toggler d-lg-none"
                            type="button"
                            data-toggle="collapse"
                            data-target="#navigation"
                            aria-controls="navigation"
                            aria-expanded="false"
                            aria-label="Toggle navigation">
                        <span class="navbar-toggler-icon"></span>
                    </button>

                    <div class="navbar-collapse" id="navigation">
                        <ul class="navbar-nav ml-auto">
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/">Home</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/about">About</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/chart">Chart</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/champions">Champions</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/team">Team</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/challenges">Challenges</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/p5-reviews">Perl/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/p6-reviews">Raku/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/recaps">Recaps</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/blogs">Blogs</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/faq">FAQ</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/contact">Contact</a>
                            </li>
                            
                        </ul>
                    </div>
                </nav>
            </div>
        </div>
    </div>
</section>


<section class="global-page-header">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2>Colin Crain › Perl Weekly Review #083</h2>
                    <div class="portfolio-meta">
                        <span>Tuesday, Nov 3, 2020</span>|
                        <span> Tags:
                            perl
                        </span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

<section class="single-post">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                
                <div style="text-align: center" class="post-img">
                    <img class="img-fluid" alt="" src="https://theweeklychallenge.org/images/blog/p5-review-challenge-083.jpg">
                </div>
                
                <div style="text-align: justify" class="post-content">
                    <p>( <em>&hellip;continues from <a href="/blog/review-challenge-082/">previous week</a>.</em> )</p>
<p>Welcome to the Perl review for <strong>Week 083</strong> of the Weekly Challenge! Here we will take the time to discuss the  submissions offered by the team, factor out the common methodologies that came up in those solutions, and highlight some of the unique approaches and unusual code created.</p>
<hr>
<h3 id="why-do-we-do-these-challenges">Why do we do these challenges?</h3>
<p>I suppose any answers to that would be as wide ranging and varied as the people who choose to join the team. One thing is clear: it&rsquo;s not a competition, and there are no judges, even if there is a &ldquo;prize&rdquo; of sorts. About that, I think of it more as an honorarium periodically awarded to acknowledge the efforts we make towards this strange goal. So there&rsquo;s no determination to find the <em>fastest</em>, or the <em>shortest</em>, or even, in some abstract way, the <em>best</em> way to go about things, although I&rsquo;m certain the individuals have their own aspirations and personal drives. As Perl is such a wonderfully expressive language, this provides quite a bit of fodder to the core idea of TMTOWTDI, producing a gamut of wonderfully varied techniques and solutions.</p>
<p>Even the tasks themselves are often open to a certain amount of discretionary interpretation. What we end up with is a situation where each participant is producing something in the manner they find the most interesting or satisfying. Some team members focus on carefully crafted complete applications that thoroughly vet input data and handle every use case they can think up. Others chose to apply themselves to the logic of the underlying puzzle and making it work in the most elegant way they can. Some eschew modules they would ordinarily reach for, others embrace them, bringing to light wheels perhaps invented years ago that happen to exactly solve the problem in front of them today.</p>
<p>I&rsquo;ve been considering this question for some time and have found one binding commonality between all of us solving these challenges each week, in that however we normally live our lives, the task in front of us more than likely has nothing to do with any of that . And I think this has great value. We all do what we do, out in the real world, and hopefully we do it well. The Weekly Challenge provides a opportunity to do something germane to that life yet distinctly different; if we only do the things we already know how to do we only do the same things over and over. This is where the &ldquo;challenge&rdquo; aspect comes into play.</p>
<p>So we can consider the Weekly Challenge as providing a problem space outside of our comfort zone, as far out from comfort as we wish to take things. From those reaches we can gather and learn things and bring what we want back into our lives. Personally, I think that&rsquo;s its greatest value of all.**</p>
<hr>
<p>Every week there is an enormous global collective effort made by the team, analyzing and creatively coding the submissions, and that effort deserves credit due. And that&rsquo;s why I&rsquo;m here, to try and figure out how to do that.</p>
<p>Let&rsquo;s have a look and see what we can find.</p>
<hr>
<p><strong><big>For context</big></strong>  before we begin, you may wish to revisit either of the pages for the <a href="/blog/perl-weekly-challenge-083/"><strong>original tasks</strong></a> or the summary <a href="/blog/recap-challenge-083/"><strong>recap</strong></a> of the challenge. But don&rsquo;t worry, the challenges themselves will be briefly summarized, presented below as we progress from task by task. Oh, and one more thing before we get started:</p>
<h3 id="getting-in-touch-with-us">Getting in Touch with Us</h3>
<p><a href="mailto:pwc.perfectwave@gmail.com"><img src="/images/blog/Email.svg" height="50" width="50"> Email</a> › Please email me (Colin) with any feedback, notes, clarifications or whatnot about this review.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge"><img src="/images/blog/Github.svg" height="50" width="50"> GitHub</a> › Submit a pull request to us for any issues you may find with this page.</p>
<p><a href="https://twitter.com/perlwchallenge"><img src="/images/blog/Twitter.svg" height="50" width="50"> Twitter</a> › Join the discussion on Twitter!</p>
<p>I&rsquo;m always curious as to what the people think of these efforts. Everyone here at the PWC would like to hear any feedback you&rsquo;d like to give.</p>
<p><strong>So finally, without further ado&hellip;</strong></p>
<hr>
<h2 id="---nbsp--nbsp--nbsp---task-1pwc083task1-------nbsp--nbsp--nbsp------nbsp--nbsp--nbsp---task-2pwc083task2---nbsp--nbsp--nbsp------nbsp--nbsp--nbsp---blogspwc083blogs----nbsp--nbsp--nbsp---">•             <a href="#PWC083TASK1">Task 1</a>                 •             <a href="#PWC083TASK2">Task 2</a>             	•             <a href="#PWC083BLOGS">BLOGS</a>              	•</h2>
<hr>
<h1 id="PWC083TASK1">TASK 1</h1>
<h1 id="words-length">Words Length</h1>
<p><em>Submitted by: Mohammad S Anwar</em></p>
<p>You are given a string $S with 3 or more words.
Write a script to find the length of the string except the first and last words ignoring whitespace.</p>
<p>Example 1:</p>
<pre><code>Input: $S = &quot;The Weekly Challenge&quot;
Output: 6
</code></pre>
<p>Example 2:</p>
<pre><code>Input: $S = &quot;The purpose of our lives is to be happy&quot;
Output: 23
</code></pre>
<h1 id="heading"></h1>
<h2 id="about-the-solutions">about the solutions</h2>
<p>There were 37 submissions for task 1 this last week. They fell out fairly evenly between those that treated the sentence as arrays of words, with array operators to manipulate them, and food for regexes, and all of the awesome power that implies.</p>
<h2 id="slices-and-splices-and-splitting-oh-my">SLICES and SPLICES and SPLITTING oh my!</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/adam-russell/perl/ch-1.pl"><strong>Adam Russell</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/alexander-pankoff/perl/ch-1.pl"><strong>Alexander Pankoff</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/andinus/perl/ch-1.pl"><strong>Andinus</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/athanasius/perl/ch-1.pl"><strong>Athanasius</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/colin-crain/perl/ch-1.pl"><strong>Colin Crain</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/cristian-heredia/perl/ch-1.pl"><strong>Cristina Heredia</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/daniel-mita/perl/ch-1.pl"><strong>Daniel Mita</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/dave-jacoby/perl/ch-1.pl"><strong>Dave Jacoby</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/ddobbelaere/perl/ch-1.pl"><strong>Dieter Dobbelaere</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/james-smith/perl/ch-1.pl"><strong>James Smith</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/jo-37/perl/ch-1.pl"><strong>Jorg Sommrey</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/lars-thegler/perl/ch-1.pl"><strong>Lars Thegler</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/laurent-rosenfeld/perl/ch-1.pl"><strong>Laurent Rosenfeld</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/lubos-kolouch/perl/ch-1.pl"><strong>Lubos Kolouch</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/jeongoon/perl/ch-1.pl"><strong>Myoungjin Jeon</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/ulrich-rieke/perl/ch-1.pl"><strong>Ulrich Rieke</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/vinod-k/perl/ch-1.pl"><strong>Vinod Kumar K</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/walt-mankowski/perl/ch-1.pl"><strong>Walt Mankowski</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/wanderdoc/perl/ch-1.pl"><strong>Wanderdoc</strong></a></p>
<p>In this form, the words in the sentence are separated by the whitespace we are told to ignore, so the phrase can be taken as a sequence of stuff that&rsquo;s not whitespace, and we can turn the sentence in string form into an array by using <code>split</code> on it.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/andinus/perl/ch-1.pl"><strong>Andinus</strong></a></p>
<p>starts the ball rolling with a nice pure demonstration:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span> @words <span style="color:#f92672">=</span> split <span style="color:#e6db74">/ /</span>, $ARGV[<span style="color:#ae81ff">0</span>];
    shift @words;
    pop @words;

    <span style="color:#66d9ef">my</span> $len;
    $len <span style="color:#f92672">+=</span> length($_) <span style="color:#66d9ef">foreach</span> @words;
</code></pre></div><p>We <code>split</code> on space, <code>shift</code> off the first word, <code>pop</code> off the last, then iterate through what&rsquo;s left and sum the lengths of the individual elements. Easy-peasy.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/lars-thegler/perl/ch-1.pl"><strong>Lars Thegler</strong></a></p>
<p>adds a <code>join</code> in the latter half to make the count that of a single string:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> $S <span style="color:#f92672">=</span> shift;                                <span style="color:#75715e"># get the string</span>
<span style="color:#66d9ef">my</span> @W <span style="color:#f92672">=</span> split <span style="color:#e6db74">/\s+/</span>, $S;                      <span style="color:#75715e"># convert into words</span>
die <span style="color:#e6db74">&#39;must be 3 or more words&#39;</span> <span style="color:#66d9ef">unless</span> @W <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">3</span>; <span style="color:#75715e"># check that it&#39;s long enough</span>
shift @W;                                     <span style="color:#75715e"># drop the first word</span>
pop @W;                                       <span style="color:#75715e"># drop the last word</span>
<span style="color:#66d9ef">my</span> $length <span style="color:#f92672">=</span> length(join <span style="color:#e6db74">&#39;&#39;</span>, @W);             <span style="color:#75715e"># the length of the rest</span>
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/dave-jacoby/perl/ch-1.pl"><strong>Dave Jacoby</strong></a></p>
<p>introduces the idea that there may well be superfluous whitespace before the first word or beyond the last. Splitting on whitespace would get fouled by this and produce the wrong result. So we whack it with a regex before we start. Many if not most people added this additional check, although I can&rsquo;t argue it&rsquo;s strictly speaking <em>necessary</em>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">words_length</span> ( $string ) {
        $string <span style="color:#f92672">=~</span> <span style="color:#e6db74">s/^\s|\s$//gmix</span>;
        <span style="color:#66d9ef">my</span> @string <span style="color:#f92672">=</span> split <span style="color:#e6db74">/\s+/</span>, $string;
        pop @string; shift @string;
        <span style="color:#66d9ef">my</span> $newstring <span style="color:#f92672">=</span> join <span style="color:#e6db74">&#39;&#39;</span>, @string;
        say $string;
        say length $newstring;
}
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/cristian-heredia/perl/ch-1.pl"><strong>Cristina Heredia</strong></a></p>
<p>covers similar territory, breaking her process down into discreet steps in different routines:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">convert2Array();

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">convert2Array</span> {
    @array <span style="color:#f92672">=</span> split <span style="color:#e6db74">/ /</span>, $S;
    removeFirstLast();
}

<span style="color:#66d9ef">sub</span>  <span style="color:#a6e22e">removeFirstLast</span> {
    shift @array;
    pop @array;
    lengthString();
}

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">lengthString</span> {
    <span style="color:#66d9ef">foreach</span> (<span style="color:#66d9ef">my</span> $i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; $i<span style="color:#f92672">&lt;</span>@array; $i<span style="color:#f92672">++</span>) {
        $count <span style="color:#f92672">=</span> $count <span style="color:#f92672">+</span> length $array[$i];
    }
    <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;Outout: $count \n&#34;</span>;
}
</code></pre></div><p>As you can see there&rsquo;s more than one way to do it. I do think people got a little bored with the arguably &ldquo;correct&rdquo; solutions, and decided to break out a bit and try something new. For example, here&rsquo;s</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/wanderdoc/perl/ch-1.pl"><strong>Wanderdoc</strong></a></p>
<p>getting creative with the final summation, importing <code>reduce</code> to do the work:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">use</span> List::Util <span style="color:#e6db74">qw(reduce)</span>;
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">words_length</span>
{
     <span style="color:#66d9ef">my</span> $string <span style="color:#f92672">=</span> $_[<span style="color:#ae81ff">0</span>];
     <span style="color:#66d9ef">my</span> @words <span style="color:#f92672">=</span> split(<span style="color:#e6db74">/\s+/</span>, $string);
     shift @words;
     pop @words;

     <span style="color:#66d9ef">my</span> $length <span style="color:#f92672">=</span> reduce {$a <span style="color:#f92672">+</span> $b} map length, @words;
     <span style="color:#66d9ef">return</span> $length;
}
</code></pre></div><p>Shifting and popping the array is an obvious and effective way to remove the first and last elements, but is hardly the only one. A few people seem to have thought: &ldquo;Why use two operations when one will do?&rdquo; and decided that <code>splice</code> would do the job just fine. And it does.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/ddobbelaere/perl/ch-1.pl"><strong>Dieter Dobbelaere</strong></a></p>
<p>demonstrates the technique. The three argument form of <code>splice</code> used here takes from an offset for a given length. As explained in <a href="https://perldoc.perl.org/perlfunc">perlfuc</a>:</p>
<blockquote>
<p>&quot;If LENGTH is negative, removes the elements from OFFSET onward except for -LENGTH elements at the end of the array&rdquo;</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">count_inner_chars</span> {
    <span style="color:#66d9ef">my</span> ($S) <span style="color:#f92672">=</span> @_;
    <span style="color:#66d9ef">my</span> @a   <span style="color:#f92672">=</span> split <span style="color:#e6db74">/\s+/</span>, $S;
    length join <span style="color:#e6db74">&#39;&#39;</span>, splice @a, <span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
}
</code></pre></div><p>We split, we splice, we join and ask for the length.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/jo-37/perl/ch-1.pl"><strong>Jorg Sommrey</strong></a></p>
<p>gives us a quite compact version:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    length join <span style="color:#e6db74">&#39;&#39;</span>, splice @{[SPLIT <span style="color:#e6db74">qr{\s+}</span>]}, <span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</code></pre></div><p>Of course, taking this idea one step further, why alter the array at all? Instead we can use an array slice to only examine those elements that interest us. There were quite a number of solutions that took this approach, including one of my own. I like slices, and cannot overstate how useful they can be.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/athanasius/perl/ch-1.pl"><strong>Athanasius</strong></a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span> @words <span style="color:#f92672">=</span> split <span style="color:#e6db74">/\s+/</span>, $S;

    scalar @words <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">3</span>           <span style="color:#f92672">or</span> error(<span style="color:#e6db74">&#39;Too few words in the input string&#39;</span>);

    <span style="color:#66d9ef">print</span> <span style="color:#e6db74">qq[Input: \$S = &#34;$S&#34;\n\n]</span>;

    <span style="color:#66d9ef">my</span> $length  <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
       $length <span style="color:#f92672">+=</span> length <span style="color:#66d9ef">for</span> @words[<span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> $#words <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];

    <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;Output: $length\n&#34;</span>;
</code></pre></div><p>The real work is all done in that one line. Clean and compact.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/james-smith/perl/ch-1.pl"><strong>James Smith</strong></a></p>
<p>gives us another view:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">other_chars</span> {
      <span style="color:#66d9ef">my</span> @A <span style="color:#f92672">=</span> split <span style="color:#e6db74">m{\s+}</span>, shift;            <span style="color:#75715e">## split into words...</span>
      <span style="color:#66d9ef">return</span> length join <span style="color:#e6db74">q()</span>, @A[<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>(@A<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>)];  <span style="color:#75715e">## compute length of words - simpler to join...</span>
                                              <span style="color:#75715e">## use array slice to remove first and last</span>
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/daniel-mita/perl/ch-1.pl"><strong>Daniel Mita</strong></a></p>
<p>by splitting the final string into its own array, Daniel cleverly goes to some length to avoid using the word <code>length</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span> @words <span style="color:#f92672">=</span> split(<span style="color:#e6db74"> /\s+/</span>, $ARGV[<span style="color:#ae81ff">0</span>] <span style="color:#e6db74">//</span> <span style="color:#e6db74">&#39;&#39;</span> );
    <span style="color:#66d9ef">if</span> ( @words <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">3</span> ) {
        say scalar( split(<span style="color:#e6db74"> //</span>, join( <span style="color:#e6db74">&#39;&#39;</span>, @words[ <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> $#words <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> ] ) ) );
    }
</code></pre></div><p>But I think if we&rsquo;re considering sparcity of words,</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/walt-mankowski/perl/ch-1.pl"><strong>Walt Mankowski</strong></a></p>
<p>apparently effortlessly avoids using very many words at all:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span> $s <span style="color:#f92672">=</span> $ARGV[<span style="color:#ae81ff">0</span>];
    <span style="color:#66d9ef">my</span> @s <span style="color:#f92672">=</span> split <span style="color:#e6db74">/ /</span>, $s;

    say length(join <span style="color:#e6db74">&#39;&#39;</span>, @s[<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$#s<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]);
</code></pre></div><p>That&rsquo;s the whole thing. How much more do you need? Lastly, we should have a look at the function submitted by</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/jeongoon/perl/ch-1.pl"><strong>Myoungjin Jeon</strong></a></p>
<p>Jeon provides us weekly with unique and often complex solutions in many languages. Here though, I found his solution a singular thing of grace and beauty. Its <em>pretty</em>. I don&rsquo;t know what else to say.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    say(
        sum
        map {length}        <span style="color:#75715e"># count each length</span>
        @words[
               <span style="color:#ae81ff">1</span>            <span style="color:#75715e"># from the second word</span>
               <span style="color:#f92672">..</span>
                $#words<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>   <span style="color:#75715e"># to   the second last one</span>
              ]
       );
</code></pre></div><h2 id="release-the-regexen">RELEASE the REGEXEN!</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/abigail/perl/ch-1.pl"><strong>Abigail</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/bob-lied/perl/ch-1.pl"><strong>Bob Lied</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/cheok-yin-fung/perl/ch-1.pl"><strong>Cheok-Yin Fung</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/colin-crain/perl/ch-1.pl"><strong>Colin Crain</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/dave-cross/perl/ch-1.pl"><strong>Dave Cross</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/e-choroba/perl/ch-1.pl"><strong>E. Choroba</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/polettix/perl/ch-1.pl"><strong>Flavio Poletti</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/jaldhar-h-vyas/perl/ch-1.pl"><strong>Jaldhar H. Vyas</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/jluis/perl/ch-1.pl"><strong>Jose Luis</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/juliodcs/perl/ch-1.pl"><strong>Julio de Castro</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/perlboy1967/perl/ch-1.pl"><strong>Niels van Dijke</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/nunovieira220/perl/ch-1.pl"><strong>Nuno Vieira</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/roger-bell-west/perl/ch-1.pl"><strong>Roger Bell_West</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/shawn-wagner/perl/ch-1.pl"><strong>Shawn Wagner</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/sgreen/perl/ch-1.pl"><strong>Simon Green</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/steve-rogerson/perl/ch-1.pl"><strong>Steve Rogerson</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/steven-wilson/perl/ch-1.pl"><strong>Steven Wilson</strong></a></p>
<p>Regular expressions open the doors to their own private world of string manipulation. Removing the first or last words or extracting the middle of a string to work on are actions easily codified into sets of rules and so matching and substitution are quite well suited to this task.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/bob-lied/perl/ch-1.pl"><strong>Bob Lied</strong></a></p>
<p>shows us how it&rsquo;s done with a kind of ridiculously thorough breakdown of the job, and I mean that in the kindest possible way:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#75715e"># Trim leading white space.</span>
    $S <span style="color:#f92672">=~</span> <span style="color:#e6db74">s/^\s+//</span>;

    <span style="color:#75715e"># Remove the first word -- anything that&#39;s not white space</span>
    $S <span style="color:#f92672">=~</span> <span style="color:#e6db74">s/^\S+//</span>;

    <span style="color:#75715e"># Turn the string around.</span>
    $S <span style="color:#f92672">=</span> reverse($S);

    <span style="color:#75715e"># Trim leading white space.</span>
    $S <span style="color:#f92672">=~</span> <span style="color:#e6db74">s/^\s+//</span>;

    <span style="color:#75715e"># Remove the first word again.</span>
    $S <span style="color:#f92672">=~</span> <span style="color:#e6db74">s/^\S+//</span>;

    <span style="color:#75715e"># Ignore white space.</span>
    $S <span style="color:#f92672">=~</span> <span style="color:#e6db74">s/\s*//g</span>;

    say length($S);
</code></pre></div><p>This quite matter-of-fact, clear and descriptive. All of the base components are there, one action per line. Most folks combined them into denser, more powerful statements.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/steven-wilson/perl/ch-1.pl"><strong>Steven Wilson</strong></a></p>
<p>for example, removes the first and last words with one fell swoop.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">length_of_excerpt</span> {
        <span style="color:#66d9ef">my</span> $input <span style="color:#f92672">=</span> shift;
        $input <span style="color:#f92672">=~</span> <span style="color:#e6db74">s/^\w+|\w+$//g</span>;    <span style="color:#75715e"># trim first and last words</span>
        $input <span style="color:#f92672">=~</span> <span style="color:#e6db74">s/\s//g</span>;           <span style="color:#75715e"># remove whitespace</span>
        <span style="color:#66d9ef">return</span> length $input;
    }
</code></pre></div><p>Alternately, instead of removing the ends, we can extract the center.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/roger-bell-west/perl/ch-1.pl"><strong>Roger Bell_West</strong></a></p>
<p>demonstrates:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">wl</span> {
  <span style="color:#66d9ef">my</span> $s<span style="color:#f92672">=</span>shift;
  $s <span style="color:#f92672">=~</span> <span style="color:#e6db74">s/^\S+\s+(.*?)\s+\S+$/$1/</span>;
  $s <span style="color:#f92672">=~</span> <span style="color:#e6db74">s/\s+//g</span>;
  <span style="color:#66d9ef">return</span> length($s);
}
</code></pre></div><p>Match the center and replace the line with the capture group. If anyone is having trouble following this,</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/steve-rogerson/perl/ch-1.pl"><strong>Steve Rogerson</strong></a></p>
<p>gives us a nice blow-by-blow for what amounts to largely the same effect. Steve uses words and non-words instead of whitespace and non-whitespace, and I would argue there is a slight difference between these ideas. The fact is the dataset is pretty poorly defined for us, and in no place is the concept of a word laid out for us. For example, what about punctuation? Or compound words, or abbreviations? These questions make the use of the <code>\w</code> character class problematic, if not actually wrong. I decided to sidestep the entire issue myself by observing the only thing that is actually defined is that whitespace is to be ignored. So I went with a word being anything that wasn&rsquo;t whitespace. I&rsquo;m well aware that isn&rsquo;t really right either, but what can you do? For a real answer to that question have a look at Abigail&rsquo;s submission, below. In any case I appreciate Steve for laying this out for us.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">find_middle_string_length</span>($string) {
        <span style="color:#66d9ef">my</span> ($middle) <span style="color:#f92672">=</span> $string <span style="color:#f92672">=~</span><span style="color:#e6db74"> /
</span><span style="color:#e6db74">        \A\W*   # skip leading junk before first word.
</span><span style="color:#e6db74">        \w+     # The first word.
</span><span style="color:#e6db74">        \W+     # at least one not word char
</span><span style="color:#e6db74">        (.*)    # everything else (inc c-r with s modifier)
</span><span style="color:#e6db74">        \W+     # at least one not word char
</span><span style="color:#e6db74">        \w+     # the final word
</span><span style="color:#e6db74">        \W*     # optional junk
</span><span style="color:#e6db74">        \z /msx</span>;

        <span style="color:#75715e"># end of string. Match on multi-line and have c-r included  in &#34;,*&#34; match</span>

        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>$middle;

        <span style="color:#75715e"># Strip out white space.</span>
        $middle <span style="color:#f92672">=~</span> <span style="color:#e6db74">s/\s//mgx</span>;
        <span style="color:#66d9ef">return</span> length($middle);
    }
</code></pre></div><p>When it comes down to it language, and with it Natural Language Processing, is a messy thing.</p>
<p>When using regexen, it&rsquo;s often useful to assign to <code>$_</code>, to allow using the default topic variable. Here</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/cheok-yin-fung/perl/ch-1.pl"><strong>Cheok-Yin Fung</strong></a></p>
<p>gives us not one but two examples:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    $_ <span style="color:#f92672">=</span> <span style="color:#e6db74">&lt;STDIN&gt;</span>;
    <span style="color:#e6db74">/(^\w+\s)([\w\s*]+)(\s\w+$)/</span>;
    $_ <span style="color:#f92672">=</span> $2;
    <span style="color:#e6db74">s/\s//g</span>;
    <span style="color:#66d9ef">print</span> length, <span style="color:#e6db74">&#34;\n&#34;</span>;
</code></pre></div><p>Ok, so we&rsquo;ve condensed the regex from many down to two, but can we do one?  Sure. Of course we can.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/juliodcs/perl/ch-1.pl"><strong>Julio de Castro</strong></a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">count_middle</span>($phrase) {
        length $phrase <span style="color:#f92672">=~</span> <span style="color:#e6db74">s/^\s*\w+|\w+\s*$|\s+//g</span>r
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/polettix/perl/ch-1.pl"><strong>Flavio Poletti</strong></a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">words_length</span> ($text) {
        length($text <span style="color:#f92672">=~</span> <span style="color:#e6db74">s{\A\s*\S+|\s+|\S+\s*\z}{}g</span>rmxs);
    }
</code></pre></div><p>or</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/colin-crain/perl/ch-1.pl"><strong>My Own Solution</strong></a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    $_ <span style="color:#f92672">=</span> $ARGV[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">||</span> <span style="color:#e6db74">&#34; The purpose of our lives is to be happy &#34;</span>;
    <span style="color:#e6db74">s/ ^\s* \S+ | \S+ \s*$ | \s+ //xg</span>;
    say length $_;
</code></pre></div><p>That compact enough for you?</p>
<h2 id="unique-approaches-and-other-things-that-caught-my-eye">UNIQUE approaches and other THINGS THAT CAUGHT MY EYE</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/abigail/perl/ch-1.pl"><strong>Abigail</strong></a></p>
<p>Abigail with a regex again, this time with full Unicode suport. After a lengthy dissertation on the meaning of a word, they go and encode that into a series of user-defined character classes, themselves extensively utilizing Unicode character properties and Unicode word boundary assertions.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span> $word <span style="color:#f92672">=</span>
         <span style="color:#e6db74">qr [(?(DEFINE)
</span><span style="color:#e6db74"> </span>               (?<span style="color:#e6db74">&lt;LETTERS&gt;</span>   <span style="color:#f92672">\</span>b{gcb} (?:(?<span style="color:#f92672">=\</span>pL)<span style="color:#f92672">\</span>X)<span style="color:#f92672">+</span> <span style="color:#f92672">\</span>b{gcb})
                (?<span style="color:#e6db74">&lt;SEPARATOR&gt;</span> [<span style="color:#e6db74">&#39;-] | &#39;</span><span style="color:#f92672">-</span> <span style="color:#f92672">|</span> <span style="color:#f92672">-</span><span style="color:#e6db74">&#39;)
</span><span style="color:#e6db74">                (?&lt;START&gt;     &#39;</span>?)
                (?<span style="color:#e6db74">&lt;END&gt;</span>       <span style="color:#960050;background-color:#1e0010">&#39;</span>?)
             )
              (?<span style="color:#f92672">&amp;</span>START)
              (?<span style="color:#f92672">&amp;</span>LETTERS) (?: (?<span style="color:#f92672">&amp;</span>SEPARATOR) (?<span style="color:#f92672">&amp;</span>LETTERS) ) <span style="color:#f92672">*</span>
              (?<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">END</span>)]x;
</code></pre></div><p>In case anyone&rsquo;s curious that&rsquo;s what all that unfamiliar backslashed notation is all about. <code>\pL</code> matches the <a href="https://perldoc.perl.org/perluniprops#Properties-accessible-through-%5Cp%7B%7D-and-%5CP%7B%7D">Unicode <strong>p</strong>roperty of a <strong>L</strong>etter</a>, \b{gcb} is a zero-width assertion for a <a href="https://perldoc.perl.org/perlrebackslash#%5Cb%7B%7D%2C-%5Cb%2C-%5CB%7B%7D%2C-%5CB">Unicode &ldquo;Grapheme Cluster Boundary&rdquo;</a>. When dealing with Unicode things are still a little hairy, to say the least. This is an impressive effort.</p>
<p>After this it&rsquo;s a familiar pattern:</p>
<ul>
<li>remove first word (as defined above)</li>
<li>remove last word (followed by anything not a Unicode letter)</li>
<li>remove whitespace</li>
<li>length of remaining string</li>
</ul>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/e-choroba/perl/ch-1.pl"><strong>E. Choroba</strong></a></p>
<p>Choroba gives us regular expressions cooked three ways. In the third of note is the use of the <code>tr///</code> translation operator. When given the <code>/c</code> modifier, those characters <em>not</em> in the searchlist are modified, being everything not whitespace. As <code>tr///</code> returns the number of actions taken, this counts the non-whitespace characters.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#75715e"># Substitution returns the number of substitutions.</span>
    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">words_length_subst</span> {
        local ($_) <span style="color:#f92672">=</span> @_;
        <span style="color:#e6db74">s/^\S+//</span>, <span style="color:#e6db74">s/\S+$//</span>;
        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">s/\S/ /g</span>
    }

    <span style="color:#75715e"># Or remove the words and all whitespace and measure the length.</span>
    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">words_length</span> {
        local ($_) <span style="color:#f92672">=</span> @_;
        <span style="color:#e6db74">s/^\S+//</span>, <span style="color:#e6db74">s/\S+$//</span>, <span style="color:#e6db74">s/ //g</span>;
        <span style="color:#66d9ef">return</span> length
    }

    <span style="color:#75715e"># Transliteration returns the number of replaced chars and is fast.</span>
    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">words_length_trans</span> {
        local ($_) <span style="color:#f92672">=</span> @_;
        <span style="color:#e6db74">s/^\S+//</span>, <span style="color:#e6db74">s/\S+$//</span>;
        <span style="color:#66d9ef">return</span> tr<span style="color:#e6db74">/\t\n\r\f\ck /</span><span style="color:#f92672">/</span>c
    }
</code></pre></div><h3 id="one-liners">ONE-LINERS</h3>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/jaldhar-h-vyas/perl/ch-1.pl"><strong>Jaldhar H. Vyas</strong></a></p>
<p>Jaldhar gives us everything we need to know in a regex one-liner:</p>
<pre><code>    perl -E '$_ = join q{ }, @ARGV; s/ \A .+? \s+ (.+) \s+ .+? \z / $1 =~ s{\s}{}gr; /emsx; say length;' $@
</code></pre><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/colin-crain/perl/ch-1.pl"><strong>My Own Solution</strong></a></p>
<p>I too decided to take things to their logical conclusion:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    perl <span style="color:#f92672">-</span>e <span style="color:#e6db74">&#39;$_=$ARGV[0];s/^\s*\S+|\S+\s*$|\s+//xg;print length $_, &#34;\n&#34;&#39;</span>
</code></pre></div><hr>
<h1 id="PWC083TASK2">TASK 2</h1>
<h1 id="flip-array">Flip Array</h1>
<p><em>Submitted by: Mohammad S Anwar</em></p>
<p>You are given an array @A of positive numbers.
Write a script to flip the sign of some members of the given array so that the sum of the all members is minimum non-negative.
Given an array of positive elements, you have to flip the sign of some of its elements such that the resultant sum of the elements of array should be minimum non-negative(as close to zero as possible).
Return the minimum no. of elements whose sign needs to be flipped such that the resultant sum is minimum non-negative.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: @A = (3, 10, 8)
Output: 1
</code></pre>
<p>Explanation: Flipping the sign of just one element 10 gives the result 1 i.e. (3) + (-10) + (8) = 1</p>
<p><strong>Example 2</strong>:</p>
<pre><code>Input: @A = (12, 2, 10)
Output: 1
</code></pre>
<p>Explanation: Flipping the sign of just one element 12 gives the result 0 i.e. (-12) + (2) + (10) = 0</p>
<h2 id="about-the-solutions-1">about the SOLUTIONS</h2>
<p>There were 34 submissions for task 2 this last week.</p>
<p>There were two core directives in this challenge: to obtain the number closest to zero, and to do so in the minimum number of moves. The order is important; we want the smallest value first. If you think about it, flipping the importance just asks for the smallest number you can get by negating one number, and this is neither interesting nor hard.</p>
<p>No, this task is much more complicated, because we&rsquo;re searching not for not a single solution, but for the best fit in two ordered criteria. There&rsquo;s always going to be an answer, so we need to sort out many possible outcomes.</p>
<p>We&rsquo;re only asked to actually return the <em>number</em> of elements flipped, not the identity of those elements nor the actual minimum found; we&rsquo;re not explicitly asked to show our work here, which can make assessment a little tricky.</p>
<p>Some people output the requested data, the number of flips required. Others output the minimum value achieved. Many did both, perhaps adding the numbers actually flipped or even wrote a completed equation. Although it was sometimes a bit confusing I decided I didn&rsquo;t care and any of these would do. I did have to make a pair of sequences, one with a high minimum sum attainable and the other with a high minimum number of flips to get the smallest value, just to make sure about some of the data. Outputting simply the number 1 proved to be uniquely ambiguous in this task.</p>
<h2 id="about-the-problem">about the PROBLEM</h2>
<p>Mathematically, this is a variant of what is known as the Partition Problem: we take a group of numbers and divide them into piles such that the sum of each pile is equal. In this version there are two piles and we want the number of elements in the pile that sums the smaller, so that if we subtract those elements from the sum of the greater the result will be positive.</p>
<p>The minimum of a group of numbers cannot always be 0. For the partitioning to work out that way, the numbers must be able to be divided groups of equal value, so that one minus the other will in turn equal zero. If the sum of all the numbers is an odd number, this sum is not evenly divisible by two. Equality will be impossible as there will always be a remaineder of 1, and so the ideal best fit sum, all other things working out, will still be that remaining 1. An extension of this reasoning reveals that for any set that includes a 0-sum, there cannot be a 1-sum solution, and vice-versa. So the two values share an equal title of optimal solution, each for one-half of the potential sets.</p>
<h2 id="use-a-binary-number-to-decide-the-signs">use a BINARY NUMBER to decide the SIGNS</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/adam-russell/perl/ch-2.pl"><strong>Adam Russell</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/cheok-yin-fung/perl/ch-2.pl"><strong>Cheok-Yin Fung</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/dave-cross/perl/ch-2.pl"><strong>Dave Cross</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/ddobbelaere/perl/ch-2.pl"><strong>Dieter Dobbelaere</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/duncan-c-white/perl/ch-2.pl"><strong>Duncan C. White</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/polettix/perl/ch-2.pl"><strong>Flavio Poletti</strong></a>
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/jo-37/perl/ch-2.pl"><strong>Jorg Sommrey</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/lars-thegler/perl/ch-2.pl"><strong>Lars Thegler</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/perlboy1967/perl/ch-2.pl"><strong>Niels van Dijke</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/pkmnx/perl/ch-2.pl"><strong>Philip Hood</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/roger-bell-west/perl/ch-2.pl"><strong>Roger Bell_West</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/sgreen/perl/ch-2.pl"><strong>Simon Green</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/steve-rogerson/perl/ch-2.pl"><strong>Steve Rogerson</strong></a></p>
<p>Of all the tools people reached for in approaching this task, the most common was a list of binary numbers. It goes like this: if we have a list on numbers of length <em>n</em>, and each item can have one of two states, a positive value or negative, then there are 2<sup><em>n</em></sup> combinations of positive and negative values that can constructed. If we create a list of binary numbers between 0 and 2<sup><em>n</em></sup> - 1, then the patterns of 1s and 0s in those numbers will provide a one-to-one mapping to the patterns of pluses and minuses in the constructed variations. Iterating through these numbers can produce a sequence of templates to guide the placement of the signs in evaluating a particular combination. For example, the with the array (2, 37, 42, 7) the number 0110 might encode the expression -2 + 37 + 42 - 7. As all combinations of 1s an 0s are symmetrically expressed in the binary numbers, it doesn&rsquo;t matter exactly how the digits are mapped to the signs &ndash; a 1 can arbitrarily either mean a &lsquo;+&rsquo; or &lsquo;-'. Either way all the combinations will eventually be examined.</p>
<p>The idea is to assign an individual bit to each element of the input array in a given combination. There were a couple of basic strategies employed.</p>
<h3 id="construct-a-parallel-array-of-bits">construct a parallel array of BITS</h3>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/adam-russell/perl/ch-2.pl"><strong>Adam Russell</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/cheok-yin-fung/perl/ch-2.pl"><strong>Cheok-Yin Fung</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/jo-37/perl/ch-2.pl"><strong>Jorg Sommrey</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/perlboy1967/perl/ch-2.pl"><strong>Niels van Dijke</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/pkmnx/perl/ch-2.pl"><strong>Philip Hood</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/steve-rogerson/perl/ch-2.pl"><strong>Steve Rogerson</strong></a></p>
<p>Most chose to split the binary number into a parallel array of bits, one for each element in the input array. The two arrays are walked through, with the sign of the element decided by the bit values.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/dave-cross/perl/ch-2.pl"><strong>Dave Cross</strong></a></p>
<p>demonstrates the principle:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">for</span> (<span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $options) {
        <span style="color:#66d9ef">my</span> $binary <span style="color:#f92672">=</span> sprintf <span style="color:#e6db74">&#34;%0${number_of_flags}b&#34;</span>, $_;
        <span style="color:#66d9ef">my</span> @flags <span style="color:#f92672">=</span> split <span style="color:#e6db74">//</span>, $binary;
        <span style="color:#66d9ef">my</span> $number_of_on_flags <span style="color:#f92672">=</span> grep { $_ } @flags;

        <span style="color:#66d9ef">my</span> $total <span style="color:#f92672">=</span> sum map {
            $flags[$_] ? <span style="color:#f92672">-</span>$ints[$_] : $ints[$_];
        } <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $#flags;

        <span style="color:#66d9ef">next</span> <span style="color:#66d9ef">if</span> $total <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>;

        <span style="color:#66d9ef">if</span> ($total <span style="color:#f92672">&lt;</span> $lowest_sum <span style="color:#f92672">or</span>
                $total <span style="color:#f92672">==</span> $lowest_sum <span style="color:#f92672">and</span> $number_of_on_flags <span style="color:#f92672">&lt;</span> $fewest_flips) {
            $lowest_sum <span style="color:#f92672">=</span> $total;
            $fewest_flips <span style="color:#f92672">=</span> $number_of_on_flags;
        }
    }
</code></pre></div><p>Here&rsquo;s another take by</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/perlboy1967/perl/ch-2.pl"><strong>Niels van Dijke</strong></a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> $min <span style="color:#f92672">=</span> sum(@A);
<span style="color:#66d9ef">my</span> $bits <span style="color:#f92672">=</span> scalar(@A);
<span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $i (<span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">**</span>$bits <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) {
    <span style="color:#66d9ef">my</span> @multiplyFactor <span style="color:#f92672">=</span> map { $_ ? <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> : <span style="color:#ae81ff">1</span> } split(<span style="color:#e6db74">//</span>,sprintf(<span style="color:#e6db74">&#34;%0${bits}b&#34;</span>, $i));
    <span style="color:#66d9ef">my</span> @flip <span style="color:#f92672">=</span> map { $_ <span style="color:#f92672">*</span> shift(@multiplyFactor) } @A;
    <span style="color:#66d9ef">my</span> $sum <span style="color:#f92672">=</span> sum(@flip);

    <span style="color:#66d9ef">if</span> ($sum <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> $sum <span style="color:#f92672">&lt;</span> $min) {
        $min <span style="color:#f92672">=</span> $sum;
        @A <span style="color:#f92672">=</span> @flip;
    }

    <span style="color:#66d9ef">last</span> <span style="color:#66d9ef">if</span> ($min <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>);
}
</code></pre></div><p>If you prefer the upside down world, then</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/pkmnx/perl/ch-2.pl"><strong>Philip Hood</strong></a></p>
<p>gives us a functional solution. As usual, best read from the bottom up. As a note I&rsquo;m still searching for the clearest formatting for the complex function applications.</p>
<p>Lets break it down: This takes the list <code>( 0 .. (2 ** $sza) -1 )</code> and maps it to bitstrings, which get passed to the grep where they have individual elements negated in the same manner we&rsquo;ve just seen, chopping the strings up into an array of bits. The sums are formed into a an array composed of the sum, the number of flipped elements to get there, and the actual array constructed.</p>
<p>Arrays with sums greater than 0 (the <code>grep</code> part) are sorted by sum and then negated elements and the smallest element of this sort is dereferenced and output. Pretty sure the last <code>map</code> is left over, but harmless. Do I need to say I really like these function chains?</p>
<p>The output, not show in code, is quite descriptive:</p>
<pre><code>    Input: 3 10 8 23 34 52 343 23 123 11 898 238 2 567 98
    Output: 5
    Flipping the sign of just 5 elements (23, 34, 23, 898, 238) gives the result 1.
     i.e.: (3) + (10) + (8) + (-23) + (-34) + (52) + (343) + (-23) + (123) + (11) + (-898) + (-238) + (2) + (567) + (98)
</code></pre><p>Anyway, here&rsquo;s the function:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span> @output <span style="color:#f92672">=</span> @{ (
       map { $_ }
       sort { $a<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] <span style="color:#e6db74">&lt;=&gt;</span> $b<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">||</span> $a<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>] <span style="color:#e6db74">&lt;=&gt;</span> $b<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>] }
       grep { $_<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&gt;</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> } map {

          <span style="color:#66d9ef">my</span> @k <span style="color:#f92672">=</span> split <span style="color:#e6db74">//</span>, $_;

          <span style="color:#66d9ef">my</span> $sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
          <span style="color:#66d9ef">my</span> $nsum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
          <span style="color:#66d9ef">my</span> @sum <span style="color:#f92672">=</span> ();
          <span style="color:#66d9ef">for</span> (<span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $#k) {

             <span style="color:#66d9ef">my</span> $acc <span style="color:#f92672">=</span> $A[$_];
             <span style="color:#66d9ef">if</span> ( $k[$_] <span style="color:#f92672">eq</span> <span style="color:#e6db74">&#34;1&#34;</span> ) {
                $acc <span style="color:#f92672">*=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
                $nsum<span style="color:#f92672">++</span>;
             }

             push @sum, $acc;
             $sum <span style="color:#f92672">+=</span> $acc;
          }

          [ $sum, $nsum, @sum ];

       }
       map { sprintf <span style="color:#e6db74">&#34;%0&#34;</span><span style="color:#f92672">.</span>$sza<span style="color:#f92672">.</span><span style="color:#e6db74">&#34;b&#34;</span>, $_ } ( <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> (<span style="color:#ae81ff">2</span> <span style="color:#f92672">**</span> $sza) <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> )
    )[<span style="color:#ae81ff">0</span>] };
</code></pre></div><h3 id="directly-address-the-bits-individually">DIRECTLY address the bits INDIVIDUALLY</h3>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/duncan-c-white/perl/ch-2.pl"><strong>Duncan C. White</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/polettix/perl/ch-2.pl"><strong>Flavio Poletti</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/roger-bell-west/perl/ch-2.pl"><strong>Roger Bell_West</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/walt-mankowski/perl/ch-2.pl"><strong>Walt Mankowski</strong></a></p>
<p>Directly looking inside the binary numbers is always an option. When done this way, we can use bitwise operators and don&rsquo;t need to actually represent the numbers in a binary format. After all, the numbers don&rsquo;t care.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/walt-mankowski/perl/ch-2.pl"><strong>Walt Mankowski</strong></a></p>
<p>gives us a nice example of addressing each bit individually:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $bits (<span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">**</span>@a <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) {
        <span style="color:#66d9ef">my</span> $sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">my</span> $num <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$#a) {
            <span style="color:#66d9ef">if</span> ($bits <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">**</span>$i) {
                $sum <span style="color:#f92672">+=</span> $a[$i];
            } <span style="color:#66d9ef">else</span> {
                $sum <span style="color:#f92672">-=</span> $a[$i];
                $num<span style="color:#f92672">++</span>;
            }
        }
        <span style="color:#66d9ef">if</span> (<span style="color:#ae81ff">0</span> <span style="color:#f92672">&lt;=</span> $sum <span style="color:#f92672">&lt;</span> $min_sum) {
            $min_sum <span style="color:#f92672">=</span> $sum;
            $min_num <span style="color:#f92672">=</span> $num;
        } <span style="color:#66d9ef">elsif</span> ($sum <span style="color:#f92672">==</span> $min_sum <span style="color:#f92672">&amp;&amp;</span> $num <span style="color:#f92672">&lt;</span> $min_num) {
            $min_num <span style="color:#f92672">=</span> $num;
        }
    }
</code></pre></div><p>Here the expression <code>$bits &amp; 2**$i</code> looks at a new bit in <code>$bits</code> for every index value.
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/sgreen/perl/ch-2.pl"><strong>Simon Green</strong></a> and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/roger-bell-west/perl/ch-2.pl"><strong>Roger Bell_West</strong></a>
also take this approach. Here&rsquo;s another by</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/polettix/perl/ch-2.pl"><strong>Flavio Poletti</strong></a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">flip_array</span> (@A) {
       <span style="color:#66d9ef">my</span> $first <span style="color:#f92672">=</span> shift @A;
       <span style="color:#66d9ef">my</span> $n <span style="color:#f92672">=</span> scalar(@A); <span style="color:#75715e"># number of signs that can be flipped</span>
       <span style="color:#66d9ef">my</span> $N <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">**</span> $n;
       <span style="color:#66d9ef">my</span> $i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
       <span style="color:#66d9ef">my</span> ($min, $retval);
       <span style="color:#66d9ef">while</span> ($i <span style="color:#f92672">&lt;</span> $N) {
          <span style="color:#66d9ef">my</span> $signs <span style="color:#f92672">=</span> $i<span style="color:#f92672">++</span>;
          <span style="color:#66d9ef">my</span> $sum <span style="color:#f92672">=</span> $first;
          <span style="color:#66d9ef">my</span> $flipped <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
          <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $j (<span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $#A) {
             <span style="color:#66d9ef">if</span> ($signs <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0x1</span>) { <span style="color:#75715e"># flip</span>
                $sum <span style="color:#f92672">-=</span> $A[$j];
                $flipped<span style="color:#f92672">++</span>;
             }
             <span style="color:#66d9ef">else</span> {
                $sum <span style="color:#f92672">+=</span> $A[$j];
             }
             $signs <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#ae81ff">1</span>;
          }
          <span style="color:#66d9ef">my</span> $complementary <span style="color:#f92672">=</span> $n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> $flipped;
          ($sum, $flipped) <span style="color:#f92672">=</span> (<span style="color:#f92672">-</span>$sum, $complementary) <span style="color:#66d9ef">if</span> $sum <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>;
          $flipped <span style="color:#f92672">=</span> $complementary <span style="color:#66d9ef">if</span> $sum <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> $flipped <span style="color:#f92672">&gt;</span> $complementary;
          ($min, $retval) <span style="color:#f92672">=</span> ($sum, $flipped)
             <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>defined($min)
                <span style="color:#f92672">||</span> $sum <span style="color:#f92672">&lt;</span> $min
                <span style="color:#f92672">||</span> ($sum <span style="color:#f92672">==</span> $min <span style="color:#f92672">&amp;&amp;</span> $flipped <span style="color:#f92672">&lt;</span> $retval);
       }
       <span style="color:#66d9ef">return</span> $retval;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/duncan-c-white/perl/ch-2.pl"><strong>Duncan C. White</strong></a></p>
<p>on the other hand, recognizes that a string by any other name will smell as sweet, and moves along with <code>substr</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span> $limit <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">**</span>$n;
    <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $i (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$limit<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
    {
        <span style="color:#66d9ef">my</span> $binary <span style="color:#f92672">=</span> sprintf( <span style="color:#e6db74">&#34;%0${n}b&#34;</span>, $i );
        <span style="color:#75715e">#say &#34;binary=$binary&#34;;</span>

        <span style="color:#66d9ef">my</span> $sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">my</span> $swaps <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $pos (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
        {
            <span style="color:#66d9ef">my</span> $x <span style="color:#f92672">=</span> $a[$pos];
            <span style="color:#66d9ef">if</span>( substr($binary,$pos,<span style="color:#ae81ff">1</span>) <span style="color:#f92672">eq</span> <span style="color:#e6db74">&#39;1&#39;</span> )
            {
                $x <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>$x;
                $swaps<span style="color:#f92672">++</span>;
            }
            $sum <span style="color:#f92672">+=</span> $x;
        }
        push @sum, $sum;
        push @swaps, $swaps;
        <span style="color:#75715e">#say &#34;sum=$sum&#34;;</span>
        <span style="color:#66d9ef">next</span> <span style="color:#66d9ef">if</span> $sum <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">if</span>( $sum <span style="color:#f92672">&lt;=</span> $minsum )
        {
            $minsum <span style="color:#f92672">=</span> $sum;
        }
    }
</code></pre></div><h2 id="other-combination-methods">other COMBINATION methods</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/alexander-pankoff/perl/ch-2.pl"><strong>Alexander Pankoff</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/athanasius/perl/ch-2.pl"><strong>Athanasius</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/colin-crain/perl/ch-2.pl"><strong>Colin Crain</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/daniel-mita/perl/ch-2.pl"><strong>Daniel Mita</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/jaldhar-h-vyas/perl/ch-2.pl"><strong>Jaldhar H. Vyas</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/jeongoon/perl/ch-2.pl"><strong>Myoungjin Jeon</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/pete-houston/perl/ch-2.pl"><strong>Pete Houston</strong></a></p>
<p>Using a binary number as a template for the arithmetic operations was of course not the only way to generate combinations.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/athanasius/perl/ch-2.pl"><strong>Athanasius</strong></a></p>
<p>The monk Athanasius draws on <code>Algorithm::Combinatorics</code> to produce <code>subsets</code> of the array. These subsets are considered as negated elements and are summed and have double their value subtracted from a base sum of all the elements. Minimums are kept for the smallest final sum, and the for the smallest number of negations required to produce that sum.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span> $iter <span style="color:#f92672">=</span> subsets(<span style="color:#f92672">\</span>@A);

    <span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">my</span> $comb <span style="color:#f92672">=</span> $iter<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">next</span>)
    {
        <span style="color:#66d9ef">next</span> <span style="color:#66d9ef">if</span> scalar @$comb <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span>
                scalar @$comb <span style="color:#f92672">==</span> scalar @A;

        <span style="color:#66d9ef">my</span> $comb_sum    <span style="color:#f92672">=</span> sum0 @$comb;
        <span style="color:#66d9ef">my</span> $flipped_sum <span style="color:#f92672">=</span> $total_sum <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> $comb_sum;

        <span style="color:#66d9ef">next</span> <span style="color:#66d9ef">if</span> $flipped_sum <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>;

        <span style="color:#66d9ef">if</span>    ($flipped_sum <span style="color:#f92672">&lt;</span>  $min_flipped_sum)
        {
            $min_flipped_sum <span style="color:#f92672">=</span> $flipped_sum;
            @nums_to_flip    <span style="color:#f92672">=</span> @$comb;
        }
        <span style="color:#66d9ef">elsif</span> ($flipped_sum <span style="color:#f92672">==</span> $min_flipped_sum <span style="color:#f92672">&amp;&amp;</span>
               scalar @$comb <span style="color:#f92672">&lt;</span>  scalar @nums_to_flip)
        {
            @nums_to_flip    <span style="color:#f92672">=</span> @$comb;
        }
    }

    <span style="color:#66d9ef">my</span> $nums_to_flip <span style="color:#f92672">=</span> scalar @nums_to_flip;
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/daniel-mita/perl/ch-2.pl"><strong>Daniel Mita</strong></a></p>
<p>Daniel opens by creating a list of index lists in a loop, with each iteration adding a new value to extend the sets with an additional element until all the lists reach n/2, halfway through the list. Each list can represent either the positive or negated values in the final equation, and, unless the lists are equal, only the list or its completment will produce a postive result. All positive results are kept and when done the list is sorted by first summed value and then list length to produce the solution.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    TOP: <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>) {

        <span style="color:#75715e"># Add a combination to our array if the sum of that combination</span>
        <span style="color:#75715e"># is ≤ half the sum of args i.e. we can make them all negative</span>
        push @combinations, [ @ARGV[@idxs] ]
            <span style="color:#66d9ef">if</span> sum( @ARGV[@idxs] ) <span style="color:#f92672">&lt;=</span> sum(@ARGV) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;

        <span style="color:#75715e"># Nothing left to do if all indexes are covered</span>
        <span style="color:#66d9ef">last</span> <span style="color:#66d9ef">if</span> @idxs <span style="color:#f92672">==</span> @ARGV;

        <span style="color:#75715e"># Increase last index if possible</span>
        <span style="color:#66d9ef">if</span> ( $idxs[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">&lt;</span> $#ARGV ) {
            $idxs[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">++</span>;
        }

        <span style="color:#75715e"># If we&#39;ve maxed out the last index</span>
        <span style="color:#66d9ef">else</span> {
            <span style="color:#75715e"># Loop through all the previous indexes</span>
            <span style="color:#66d9ef">for</span> ( <span style="color:#66d9ef">my</span> $i <span style="color:#f92672">=</span> $#idxs; $i <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>; $i<span style="color:#f92672">--</span> ) {

                <span style="color:#75715e"># If the difference between an index</span>
                <span style="color:#75715e"># and the one before is more than 1</span>
                <span style="color:#66d9ef">if</span> ( $idxs[$i] <span style="color:#f92672">-</span> $idxs[ $i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> ] <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span> ) {

                    <span style="color:#75715e"># Increase that previous index</span>
                    <span style="color:#66d9ef">my</span> $j <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>$idxs[ $i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> ];

                    <span style="color:#75715e"># Reset all the subsequent indexes (+1 of previous index)</span>
                    <span style="color:#66d9ef">for</span> ( @idxs[ $i <span style="color:#f92672">..</span> $#idxs ] ) {
                        $_ <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>$j;
                    }

                    <span style="color:#75715e"># Go back to the start</span>
                    <span style="color:#66d9ef">next</span> TOP;
                }
            }

            <span style="color:#75715e"># Reset all indexes and add an additional element</span>
            <span style="color:#75715e"># if we couldn&#39;t increase any further</span>
            @idxs <span style="color:#f92672">=</span> ( <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> @idxs );
        }
    }
</code></pre></div><p>If the plan is to generate the solution in the minimum number of negations, it makes sense to take a structured approach to testing: first try flipping individual elements, then combinations of two elements, then three, etc, working upwards. Mathematically, these combinations are known as nCk, &ldquo;<em>n</em> choose <em>k</em>&quot;, or picking <em>k</em> item combinations from a set of <em>n</em> members.</p>
<p>To implement a combination function Pete used <code>Math::Combinatorics</code>. Alexander Pankoff brought his own recursive routine to the party, as did Daniel Mita. Myself, I reached out to my old friend <code>Algorithm::Combinatorics</code>.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/pete-houston/perl/ch-2.pl"><strong>Pete Houston</strong></a></p>
<p>Pete draws on <code>Math::Combinatorics</code> for a nCk function. From this he can feed it increasing values for <em>k</em>, increasing the combination length up to one-half the complete input array. He looks at both sides of each list, the picked elements and the unpicked remainder, summing the value and subtracting from the unaltered sum. I particularly enjoyed his code implementing this reversal for some reason. He keeps a running talley for the minimum total, and the minimum number of elements to create it.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $count (<span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> int (($#in <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>)) {
        <span style="color:#66d9ef">my</span> $combi <span style="color:#f92672">=</span> Math::Combinatorics<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">new</span> (
            count <span style="color:#f92672">=&gt;</span> $count,
            data  <span style="color:#f92672">=&gt;</span> [@in]
        );
        <span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">my</span> @set <span style="color:#f92672">=</span> $combi<span style="color:#f92672">-&gt;</span>next_combination) {
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;count &#34;</span>, $count, <span style="color:#e6db74">&#34; combo &#34;</span>, <span style="color:#f92672">++</span>$combo, <span style="color:#e6db74">&#34;:   ( @set )\n&#34;</span>;
            <span style="color:#66d9ef">my</span> $diff <span style="color:#f92672">=</span> $tot <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> sum @set;
            <span style="color:#66d9ef">next</span> <span style="color:#66d9ef">unless</span> abs $diff <span style="color:#f92672">&lt;=</span> $min;
            <span style="color:#66d9ef">my</span> $numitems <span style="color:#f92672">=</span> $count;
            <span style="color:#66d9ef">if</span> ($diff <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
                <span style="color:#75715e"># It is the inverse of @set that we want</span>
                <span style="color:#75715e"># Invert diff and $numitems</span>
                $diff <span style="color:#f92672">*=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
                $numitems <span style="color:#f92672">=</span> @in <span style="color:#f92672">-</span> $count;
            }
            <span style="color:#66d9ef">if</span> ($diff <span style="color:#f92672">==</span> $min) {
                $minc <span style="color:#f92672">=</span> $numitems <span style="color:#66d9ef">if</span> $numitems <span style="color:#f92672">&lt;</span> $minc;
                <span style="color:#66d9ef">next</span>;
            }
            <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;New min $diff for @set\n&#34;</span>;
            $min <span style="color:#f92672">=</span> $diff;
            $minc <span style="color:#f92672">=</span> $numitems;
        }
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/alexander-pankoff/perl/ch-2.pl"><strong>Alexander Pankoff</strong></a></p>
<p>Alexander brings his own routine to make increasingly long chains of combinations, which he then sums. Counting backwards from the one-half the total sum of all the elements, he looks at combinations that will sum to that target value. First elements summing to one-half the total are searched for: if any are found then those, when added to the remaining non-negated elements, will produce a final sum of 0. If that cannot be achieved, or the total is not evenly divisible by 2, then the next target is to try for sums that total to n/2 - 1, producing a final sum of 1, etc.</p>
<p>The routine that searches for this combination is quite elegant. When any result is found it is the minimal solution.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">flip_array</span>(@numbers) {
        <span style="color:#66d9ef">my</span> $sum     <span style="color:#f92672">=</span> sum0(@numbers);
        <span style="color:#66d9ef">my</span> $ceiling <span style="color:#f92672">=</span> int( $sum <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span> );

        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $target ( reverse( <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $ceiling ) ) {
            <span style="color:#66d9ef">my</span> $count <span style="color:#f92672">=</span> first(
                <span style="color:#66d9ef">sub</span> {
                    any { sum0(@$_) <span style="color:#f92672">eq</span> $target } combinations( $_, @numbers );
                },
                <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> @numbers
            );

            <span style="color:#66d9ef">return</span> $count <span style="color:#66d9ef">if</span> $count;
        }

        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/colin-crain/perl/ch-2.pl"><strong>My Own Solution</strong></a></p>
<p>For my own solution I pulled out <code>Algorith::Combinatorics</code> which I fed increasing values of <em>k</em>. As we proceed through the various combinations of a given length we keep a running tally of the minimum and a list of the elements that created it stored in an array indexed by that minimum. The values in the minimums array can only be added once, so each element holds an array with the minimum number of elements required to produce it.</p>
<p>Because the length grows in an orderly way, if we are able to find a solution that sums to 0, we know immediately that that is the minimum sum, and hence the minimum length required, and we are done. If no 0 solution is found, however, at that point all of the combinations have already been processed and the minimum index of the holding array will contain the elements required in the solution, which is the length of this array. So a best-case 0-sum can be found quite quickly, and in a worst-case scenario all combinations will still only be examined once.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $k ( <span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>@arr ) {     <span style="color:#75715e">## for 1,2,3... numbers flipped</span>

        <span style="color:#66d9ef">my</span> $min <span style="color:#f92672">=</span> $base_sum;
        <span style="color:#66d9ef">my</span> $pick;

        <span style="color:#75715e">## make sets of nCk combinations of elements</span>
        <span style="color:#66d9ef">my</span> $iter <span style="color:#f92672">=</span> combinations(<span style="color:#f92672">\</span>@arr, $k);
        <span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">my</span> $c <span style="color:#f92672">=</span> $iter<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">next</span>) {

            <span style="color:#66d9ef">my</span> $new_sum <span style="color:#f92672">=</span> $base_sum <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> sum $c<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>
            if ( $new_sum <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> $new_sum <span style="color:#f92672">&lt;</span> $min ) {
                $min <span style="color:#f92672">=</span> $new_sum;
                $pick <span style="color:#f92672">=</span> $c;
            }
        }

        <span style="color:#75715e">## @results is array of minimum totals as indexes holding a list of the</span>
        <span style="color:#75715e">## flips that create it, set with first instance of that minimum so shorter</span>
        <span style="color:#75715e">## lengths will populate first</span>
        $results[$min] <span style="color:#f92672">||=</span> $pick;

        <span style="color:#66d9ef">last</span> <span style="color:#66d9ef">if</span> $min <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>;   <span style="color:#75715e">## we cannot do better than 0; we are done</span>
    }
</code></pre></div><h2 id="just-try-all-the-options">just try ALL THE OPTIONS</h2>
<h3 id="write-a-recursive-function-to-get-there">write a RECURSIVE function to get there</h3>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/dave-jacoby/perl/ch-2.pl"><strong>Dave Jacoby</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/juliodcs/perl/ch-2.pl"><strong>Julio de Castro</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/laurent-rosenfeld/perl/ch-2.pl"><strong>Laurent Rosenfeld</strong></a></p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/laurent-rosenfeld/perl/ch-2.pl"><strong>Laurent Rosenfeld</strong></a></p>
<p>Laurent&rsquo;s <code>sum_up</code> routine walks a binary tree through all possibilities and logs the solutions to a hash.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">sum_up</span> {
        <span style="color:#66d9ef">my</span> @in <span style="color:#f92672">=</span>  @{$_[<span style="color:#ae81ff">0</span>]};
        <span style="color:#66d9ef">my</span> @used_so_far <span style="color:#f92672">=</span>  @{$_[<span style="color:#ae81ff">1</span>]};
        <span style="color:#66d9ef">if</span> (@in <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>) {
            <span style="color:#66d9ef">my</span> $sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
            $sum <span style="color:#f92672">+=</span> $_ <span style="color:#66d9ef">for</span> @used_so_far;
            push @{$result{$sum}}, [@used_so_far] <span style="color:#66d9ef">if</span> $sum <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>;
        } <span style="color:#66d9ef">else</span> {
            <span style="color:#66d9ef">my</span> $item <span style="color:#f92672">=</span> shift @in;
            sum_up(<span style="color:#f92672">\</span>@in, [@used_so_far, $item]);
            sum_up(<span style="color:#f92672">\</span>@in, [@used_so_far, <span style="color:#f92672">-</span> $item]);
        }
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/dave-jacoby/perl/ch-2.pl"><strong>Dave Jacoby</strong></a></p>
<p>uses a loop with two values to achieve the same ends:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">_flip_array</span> ( $index, $array, $map ) {
    <span style="color:#66d9ef">if</span> ( $array<span style="color:#f92672">-&gt;</span>[$index] ) {
        <span style="color:#66d9ef">my</span> $nmap<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span> <span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#960050;background-color:#1e0010">$</span>map<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>
        for <span style="color:#66d9ef">my</span> $bit ( <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span> ) {
            $nmap<span style="color:#f92672">-&gt;</span>[$index] <span style="color:#f92672">=</span> $bit;
            <span style="color:#66d9ef">my</span> @munge <span style="color:#f92672">=</span> _munge( $array, $map );
            <span style="color:#66d9ef">my</span> $sum <span style="color:#f92672">=</span> sum @munge;
            _flip_array( $index <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, $array, $nmap );
        }
    }
    <span style="color:#66d9ef">else</span> {
        <span style="color:#66d9ef">my</span> @munge <span style="color:#f92672">=</span> _munge( $array, $map );
        <span style="color:#66d9ef">my</span> $map1 <span style="color:#f92672">=</span> join <span style="color:#e6db74">&#39;&#39;</span>, $map<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>
        my $sum <span style="color:#f92672">=</span> sum @munge;
        $hash<span style="color:#f92672">-&gt;</span>{$map1} <span style="color:#f92672">=</span> $sum;
        <span style="color:#66d9ef">if</span> ( $sum <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> $sum <span style="color:#f92672">&lt;</span> $min ) { $min <span style="color:#f92672">=</span> $sum }
    }
}
</code></pre></div><h3 id="loop-through-life-unfettered-by-self-reflection-non-recursive-solutions">LOOP through LIFE UNFETTERED by self reflection (NON-RECURSIVE solutions)</h3>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/james-smith/perl/ch-2.pl"><strong>James Smith</strong></a> and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/jluis/perl/ch-2.pl"><strong>Jose Luis</strong></a></p>
<p>In a similar manner to the recursion solutions above, a loop construct flips a pattern of individual elements in the array and the results are preserved.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/james-smith/perl/ch-2.pl"><strong>James Smith</strong></a></p>
<p>gives us an example. Passage through the loop structure variously flips and unflips the sign of individual elements, walking through the possibilities in an orderly fashion. It&rsquo;s quite elegant.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">         $sum <span style="color:#f92672">+=</span> $_ <span style="color:#66d9ef">foreach</span> @array; <span style="color:#75715e">## Initial &#34;unflipped&#34; sum...</span>
    <span style="color:#66d9ef">my</span>(  $flipped, $smallest, $best, $na  ) <span style="color:#f92672">=</span> (  <span style="color:#ae81ff">0</span>, $sum, $sum, scalar @array  ); <span style="color:#75715e">## Initialise counts/running sums...</span>

    <span style="color:#66d9ef">while</span>( <span style="color:#ae81ff">1</span> ) {
        ( $best, $smallest )<span style="color:#f92672">=</span>( $flipped, $sum ) <span style="color:#66d9ef">if</span> $sum <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> $sum <span style="color:#f92672">&lt;</span> $smallest <span style="color:#f92672">||</span> $sum <span style="color:#f92672">==</span> $smallest <span style="color:#f92672">&amp;&amp;</span> $flipped <span style="color:#f92672">&lt;</span> $best;
        <span style="color:#66d9ef">foreach</span>( <span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$na ) {
            <span style="color:#66d9ef">return</span> $best <span style="color:#66d9ef">if</span> $_ <span style="color:#f92672">==</span> $na;                    <span style="color:#75715e">## Now reached the end as we have flipped the last element back...</span>
            $sum <span style="color:#f92672">+=</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>( $array[$_]<span style="color:#f92672">=-</span>$array[$_] ); <span style="color:#75715e">## Flip bit and update sum...</span>
            <span style="color:#66d9ef">if</span>(  $array[$_]<span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>  ) {                              <span style="color:#75715e">## We carry over to the next bit ( if the element has been flipped back )</span>
                $flipped <span style="color:#f92672">--</span>;
            } <span style="color:#66d9ef">else</span> {                                                         <span style="color:#75715e">## No need to carry so finish loop...</span>
                $flipped <span style="color:#f92672">++</span>;
                <span style="color:#66d9ef">last</span>;
            }
        }
    }
</code></pre></div><h2 id="the-heuristic-algorithms">the HEURISTIC ALGORITHMS</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/lubos-kolouch/perl/ch-2.pl"><strong>Lubos Kolouch</strong></a></p>
<p>The heuristic algorithm referred to here by Lubos says to first sort the array from largest to smallest. Then make two piles, @a and @b. Starting with the largest element, deposit it into whichever array sums the smallest (or array @b). At the end, the scalar size of the smaller of the two arrays is returned.</p>
<p>No, this puzzle is not that simple. But this method, he notes, is <em>fast</em>. And as it appears he knows perfectly well it doesn&rsquo;t answer properly for this puzzle, I feel comfortable discussing it here in its dissolute state.</p>
<p>As it stands, it works by distributing the elements into piles, not necessarily alternately, but in a manner that one is added to until it exceeds the other. For random data that&rsquo;s been sorted, the next element on the list will likely to be as close to the next number as it was from the previous, so the differences in the change to the two groups will likely balance out. When finished, the two piles will have been divided into similarly sized partitions, with the differences minimized along the way.</p>
<p>There&rsquo;s a couple of small things wrong with this implementation, but one problem with applying this generalized algorithm to the task is that it finds the absolute difference between the two piles. Should the two piles not equal in value, then there is only one way to subtract one from the other to yield a positive outcome, so simply picking the pile with fewer elements to subtract will not do. Picking the smaller <em>sum</em> is the right move at that stage, because it is specified that we need a positive result.</p>
<p>This particular quick-and-dirty method is known as the &ldquo;greedy&rdquo; heuristic algorithm, and as all algorithms of this type is perhaps best considered an educated guess. It may or may not be right, but is unlikely to be very wrong, either. But again, the challenge is to find the best solution in the shortest number of moves, not to find what is likely to be the smallest number of negations to find something close to the smallest sum. Several other people submitted heuristic solutions to the generalized partition problem, with varying accuracy. It&rsquo;s pretty easy to produce data that will send this strategy to a horribly wrong conclusion. Actual construction will be left as an exercise to the reader.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">get_nr_flips</span> {

        <span style="color:#66d9ef">my</span> $arr <span style="color:#f92672">=</span> shift;

        <span style="color:#75715e"># split the array into two sets, using the heuristic algorithm, which may</span>
        <span style="color:#75715e"># not be perfect, but runs fast!</span>

        <span style="color:#66d9ef">my</span> @a <span style="color:#f92672">=</span> <span style="color:#f92672">[]</span>;
        <span style="color:#66d9ef">my</span> @b <span style="color:#f92672">=</span> <span style="color:#f92672">[]</span>;

        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i (sort {$b <span style="color:#e6db74">&lt;=&gt;</span> $a} @$arr) {
            <span style="color:#66d9ef">if</span> (sum(@a) <span style="color:#f92672">&lt;</span> sum(@b)) {
                push @a, $i;
            } <span style="color:#66d9ef">else</span> {
                push @b, $i;
            }
        }

        <span style="color:#75715e"># now flip the smaller list</span>
        <span style="color:#66d9ef">return</span> scalar @a <span style="color:#66d9ef">if</span> scalar @a <span style="color:#f92672">&lt;</span> scalar @b;

        <span style="color:#66d9ef">return</span> scalar @b;

    }
</code></pre></div><h2 id="unique-approaches-and-other-things-that-caught-my-eye-1">UNIQUE approaches and other THINGS THAT CAUGHT MY EYE</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/abigail/perl/ch-2.pl"><strong>Abigail</strong></a></p>
<p>Abigail has hands-down put the most elaborate analysis to the task this week. He starts with a binary tree, as checking all solutions is the only way to be sure. From here, though, he takes a singularly aggressive approach to pruning that would give an arborist PTSD. This pruning takes a layered approach over multiple levels:</p>
<ul>
<li>
<p>eliminating branches that from a given point forward can no longer provide a valid solution, either greater than 0 or less than the current minimum</p>
</li>
<li>
<p>using a quick-and-dirty heuristic to provide an upper bound on the best score</p>
</li>
<li>
<p>applying refactoring to the dataset to remove duplicate pathways, leaving only one representitive to be examined</p>
</li>
</ul>
<p>Taken together these steps have the potential to drastically reduce the number of paths descended and assessed. The first is the big one, considering whether it is pointless to continue. If, for instance, adding every element from a given point to the end of the array still leaves the sum negative, we&rsquo;re out. An array of partial sums for the rest of the array facilitates this.</p>
<p>The second item goes straight to the second part of the first: establishing the point when even if we subtract every element from a given point forward we will still be above the minimum. Remember that the heuristic algorithms cannot guarantee that the result provided  is in fact the minimum. However, unrolled, the greedy heuristic does represent a valid solution, only perhaps not the best. Therefore this can be used to quickly establish an upper bound for the minimum value, and any path that cannot continue to a point of at least this value can be eliminated.</p>
<p>The third item is structural, and may or may not apply: that we never unflip the number we just flipped, should they be the same. This goes nowhere and produces duplication of effort.</p>
<p>The code is exceedingly well documented with much more complete explanations, and very clearly laid out. We aren&rsquo;t using 1200 baud modems any more to talk the mainframe &ndash; spaces and meaningful variable names are neither expensive nor exotic.</p>
<p>I can&rsquo;t really isolate a representative piece of this tapestry, so I&rsquo;ll just provide the greedy algorithm segment as example:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span> $best_score <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">my</span> $best_flips <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

    <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $number (@$set) {
        <span style="color:#66d9ef">if</span> ($best_score <span style="color:#f92672">-</span>  $number <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
            $best_score <span style="color:#f92672">+=</span> $number;
        }
        <span style="color:#66d9ef">else</span> {
            $best_score <span style="color:#f92672">-=</span> $number;
            $best_flips <span style="color:#f92672">++</span>;
        }
    }
</code></pre></div><p>See? Clean and approachable. Go have a look for yourself. It will be entirely worth it.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-083/e-choroba/perl/ch-2.pl"><strong>E. Choroba</strong></a></p>
<p>Choroba provides two solutions, but one is a method not otherwise covered here, using dynamic programming. Enjoy:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">flip_array_dp</span> {  <span style="color:#75715e"># DP stands for Dynamic Programming</span>
        <span style="color:#66d9ef">my</span> @arr <span style="color:#f92672">=</span> @_;
        <span style="color:#66d9ef">my</span> %sums <span style="color:#f92672">=</span> (<span style="color:#ae81ff">0</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">0</span>);
        <span style="color:#66d9ef">my</span> %best;
        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $element (@arr) {
            <span style="color:#66d9ef">my</span> %next;
            <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $sum (keys %sums) {
                <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $multiply_add ([<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>], [<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>]) {
                    <span style="color:#66d9ef">my</span> $new_sum <span style="color:#f92672">=</span> $sum <span style="color:#f92672">+</span> $element <span style="color:#f92672">*</span> $multiply_add<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>];
                    <span style="color:#66d9ef">my</span> $new_flip_tally <span style="color:#f92672">=</span> $sums{$sum} <span style="color:#f92672">+</span> $multiply_add<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>];
                    $next{$new_sum} <span style="color:#f92672">=</span> $new_flip_tally
                        <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span> exists $next{$new_sum}
                        <span style="color:#f92672">||</span> $next{$new_sum} <span style="color:#f92672">&gt;</span> $new_flip_tally;
                }
            }
            %sums <span style="color:#f92672">=</span> %next;
        }
        <span style="color:#66d9ef">my</span> $best <span style="color:#f92672">=</span> first { $_ <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> } keys %sums;
        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $sum (keys %sums) {
            $best <span style="color:#f92672">=</span> $sum <span style="color:#66d9ef">if</span> $sum <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> $sum <span style="color:#f92672">&lt;</span> $best;
        }
        <span style="color:#66d9ef">return</span> $sums{$best}
    }
</code></pre></div><hr>
<h1 id="PWC083BLOGS">BLOGS</h1>
<hr>
<p><strong>That’s it for me this week, people! Resolute and unbroken by the torrential influx, I have maintained my bearings. Looking forward to next wave, the perfect wave, I am, your humble servant.</strong></p>
<h2 id="PWC083BLOGS">But if Your <em>THIRST</em> for <em>KNOWLEDGE</em> is not <em>SLAKED</em>,</h2>
<h2 id="then-run-dont-walk-to-the-watering-hole">then <em>RUN</em> <em>(dont walk!)</em> to the <em>WATERING HOLE</em></h2>
<h2 id="and-read-these-blog-links">and <em>READ</em> these <em>BLOG</em> <em>LINKS</em>:</h2>
<p><em><strong>( don&rsquo;t think, trust your training, you&rsquo;re in the zone, just do it &hellip; )</strong></em></p>
<p><strong>Adam Russell</strong></p>
<ul>
<li><a href="http://www.rabbitfarm.com/cgi-bin/blosxom/2020/10/25#pwc083">Perl Weekly Challenge 083 - RabbitFarm</a> ( <em>Perl</em> )</li>
</ul>
<p><strong>Andinus</strong></p>
<ul>
<li><a href="https://andinus.tilde.institute/pwc/challenge-083/">Challenge 083</a> ( <em>Perl</em> )</li>
<li><a href="https://andinus.tilde.institute/pwc/challenge-083/">Challenge 083</a> ( <em>Perl</em> )</li>
</ul>
<p><strong>Arne Sommer</strong></p>
<ul>
<li><a href="https://raku-musings.com/wordly-array.html">Wordly Array with Raku</a> ( <em>Raku</em> )</li>
</ul>
<p><strong>Cheok-Yin Fung</strong></p>
<ul>
<li><a href="http://blogs.perl.org/users/c_y_fung/2020/10/cys-take-on-pwc083.html">CY&rsquo;s Take on PWC#083 | Moments on Perl or other Programming Issues</a> ( <em>Perl</em> )</li>
</ul>
<p><strong>Colin Crain</strong></p>
<ul>
<li><a href="https://colincrain.com/2020/10/24/no-no-not-that-word-flip-the-pain-away/">No, no! Not THAT Word! FLIP the Pain Away! – Programming Excursions in Perl and Raku</a> ( <em>Perl &amp; Raku</em> )</li>
</ul>
<p><strong>Dieter Dobbelaere</strong></p>
<ul>
<li><a href="https://magneticcharge.wordpress.com/2020/10/25/perl-weekly-challenge-083/">Perl Weekly Challenge 083 – Magnetic Charge</a> ( <em>Perl</em> )</li>
</ul>
<p><strong>Flavio Poletti</strong></p>
<ul>
<li><a href="https://github.polettix.it/ETOOBUSY/2020/10/21/pwc083-words-length/">PWC083 - Words Length</a> ( <em>Perl</em> )</li>
<li><a href="https://github.polettix.it/ETOOBUSY/2020/10/22/pwc083-flip-array/">PWC083 - Flip Array</a> ( <em>Perl</em> )</li>
</ul>
<p><strong>Jaldhar H. Vyas</strong></p>
<ul>
<li><a href="https://www.braincells.com/perl/2020/10/perl_weekly_challenge_week_83.html">Perl Weekly Challenge: Week 83</a> ( <em>Perl &amp; Raku</em> )</li>
</ul>
<p><strong>Laurent Rosenfeld</strong></p>
<ul>
<li><a href="http://blogs.perl.org/users/laurent_r/2020/10/perl-weekly-challenge-83-words-length-and-flip-array.html">Perl Weekly Challenge 83: Words Length and Flip Array</a> ( <em>Perl &amp; Raku</em> )</li>
</ul>
<p><strong>Myoungjin Jeon</strong></p>
<ul>
<li><a href="https://dev.to/jeongoon/weekly-challenge-083-task-2-perl-8d0">Weekly Challenge #083 Task #2 :: Perl</a> ( <em>Perl</em> )</li>
<li><a href="https://dev.to/jeongoon/weekly-challenge-083-task-2-raku-2cjm">Weekly Challenge #083 Task #2 :: Raku</a> ( <em>Raku</em> )</li>
</ul>
<p><strong>Roger Bell_West</strong></p>
<ul>
<li><a href="https://blog.firedrake.org/archive/2020/10/Perl_Weekly_Challenge_83__Length_and_Inversion.html">RogerBW's Blog: Perl Weekly Challenge 83: Length and Inversion</a> ( <em>Perl &amp; Raku</em> )</li>
</ul>
<p><strong>Simon Green</strong></p>
<ul>
<li><a href="https://dev.to/simongreennet/weekly-challenge-083-4ga6">Weekly Challenge 083</a> ( <em>Perl</em> )</li>
</ul>
<p><strong>Walt Mankowski</strong></p>
<ul>
<li><a href="http://www.mawode.com/blog/blog/2020/10/19/perl-weekly-challenge-83/">Perl Weekly Challenge #83</a> ( <em>Perl</em> )</li>
</ul>

                </div>
            </div>
        </div>
    </div>
</section>


<!-- Call To Action Section Start -->
<section id="call-to-action">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2 class="title wow fadeInDown" data-wow-delay=".3s" data-wow-duration="500ms">SO WHAT DO YOU THINK ?</h2>
                    <p class="wow fadeInDown" data-wow-delay=".5s" data-wow-duration="500ms">If you have any suggestions or ideas then please do share with us.</p>
                    <a href="mailto:mohammad.anwar@yahoo.com" class="btn btn-default btn-contact wow fadeInDown" data-wow-delay=".7s" data-wow-duration="500ms">Contact with me</a>
                </div>
            </div>

        </div>
    </div>
</section>
<!-- Call To Action Section End -->



<!-- Footer Section Start -->
<footer id="footer">
    <div class="container">
        <div class="row content-justify-between">
            <div class="col-md-8 col-12 text-center text-lg-left text-md-left">
                <p class="copyright">Copyright:
                    <span>
                        2019 - 2025
                    </span> The Weekly Challenge. Theme Design and Developed by
                    <a href="http://www.Themefisher.com" rel="noreferrer" rel="noreferrer" target="_blank">Themefisher</a>.
                </p>
            </div>
            <div class="col-md-4 col-12">
                <!-- Social Media -->
                <ul class="social text-center text-md-right text-lg-right">
                    <li>
                        <a href="https://twitter.com/PerlWChallenge" class="twitter" rel="noreferrer" target="_blank" title="Follow us">
                            <i class="ion-social-twitter"></i>
                        </a>
                    </li>
                    <li>
                        <a href="/rss.xml" class="rss" target="_blank" title="RSS Feed">
                            <i class="ion-social-rss"></i>
                        </a>
                    </li>
                </ul>
            </div>
        </div>
    </div>
</footer>
<!-- footer section end -->

<!-- jquery -->
<script src="https://theweeklychallenge.org/plugins/jquery/jquery.min.js"></script>
<!-- Form Validation -->
<script src="https://theweeklychallenge.org/plugins/form-validation/jquery.form.min.js"></script>
<script src="https://theweeklychallenge.org/plugins/form-validation/jquery.validate.min.js"></script>
<!-- slick slider -->
<script src="https://theweeklychallenge.org/plugins/slick/slick.min.js"></script>
<!-- bootstrap js -->
<script src="https://theweeklychallenge.org/plugins/bootstrap/bootstrap.min.js"></script>
<!-- chart js -->
<script src="https://theweeklychallenge.org/plugins/chart/highstock.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/drilldown.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/data.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/chart.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/pwc-challenge.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/gc-challenge.js"></script>
<!-- wow js -->
<script src="https://theweeklychallenge.org/plugins/wow-js/wow.min.js"></script>
<!-- slider js -->
<script src="https://theweeklychallenge.org/plugins/slider/slider.js"></script>
<!-- Fancybox -->
<script src="https://theweeklychallenge.org/plugins/facncybox/jquery.fancybox.js"></script>
<!-- template main js -->

<script src="https://theweeklychallenge.org/js/script.min.js"></script>
<!-- google analitycs -->

<script async src="https://www.googletagmanager.com/gtag/js?id=G-CJTPYM9SB8"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-CJTPYM9SB8');
</script>
</body>

</html>

